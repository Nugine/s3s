use crate::dto::RustTypes;
use crate::f;
use crate::gen::Codegen;
use crate::ops::Operations;
use crate::rust;

use heck::ToSnakeCase;

pub fn codegen(ops: &Operations, rust_types: &RustTypes, g: &mut Codegen) {
    g.lines([
        "//! Auto generated by `codegen/src/aws_proxy.rs`",
        "",
        "use super::*;",
        "",
        "use crate::conv::{try_from_aws, try_into_aws};",
        "",
        "use s3s::S3;",
        "use s3s::S3Request;",
        "use s3s::S3Result;",
        "",
        "use tracing::debug;",
        "",
    ]);

    g.ln("#[async_trait::async_trait]");
    g.ln("impl S3 for Proxy {");

    for op in ops.values() {
        let method_name = op.name.to_snake_case();
        let s3s_input = f!("s3s::dto::{}", op.input);
        let s3s_output = f!("s3s::dto::{}", op.output);

        g.ln("#[tracing::instrument(skip(self, req))]");
        g.ln(f!(
            "async fn {method_name}(&self, req: S3Request<{s3s_input}>) -> S3Result<{s3s_output}> {{"
        ));

        g.ln("let input = req.input;");
        g.ln("debug!(?input);");

        if op.smithy_input == "Unit" {
            g.ln(f!("let result = self.0.{method_name}().send().await;"));
        } else {
            g.ln(f!("let mut b = self.0.{method_name}();"));
            let rust::Type::Struct(ty) = &rust_types[op.input.as_str()] else { panic!() };

            let flattened_fields = if ty.name == "SelectObjectContentInput" {
                let rust::Type::Struct(flattened_ty) = &rust_types["SelectObjectContentRequest"] else { panic!() };
                flattened_ty.fields.as_slice()
            } else {
                &[]
            };

            for field in ty.fields.iter().chain(flattened_fields) {
                let s3s_field_name = match ty.name.as_str() {
                    "SelectObjectContentInput" if field.name == "request" => continue,
                    "SelectObjectContentInput" if field.position == "xml" => f!("request.{}", field.name),
                    _ => field.name.clone(),
                };
                let aws_field_name = match ty.name.as_str() {
                    "SelectObjectContentInput" => field.name.as_str(),
                    _ => match s3s_field_name.as_str() {
                        "checksum_crc32c" => "checksum_crc32_c",
                        "type_" => "type",
                        s => s,
                    },
                };

                // // hack
                // if op.name == "PutObject" && field.type_ == "ChecksumAlgorithm" {
                //     assert!(field.option_type);
                //     let default_val = "aws_sdk_s3::model::ChecksumAlgorithm::Sha256";
                //     let val = f!("try_into_aws(input.{s3s_field_name})?.or(Some({default_val}))");
                //     g.ln(f!("b = b.set_{aws_field_name}({val});"));
                //     continue;
                // }

                if field.option_type {
                    g.ln(f!("b = b.set_{aws_field_name}(try_into_aws(input.{s3s_field_name})?);"));
                } else {
                    g.ln(f!("b = b.set_{aws_field_name}(Some(try_into_aws(input.{s3s_field_name})?));"));
                }
            }
            g.ln("let result = b.send().await;");
        }

        g.ln("match result {");
        g.ln("Ok(output) => {");
        g.ln("    let output = try_from_aws(output)?;");
        g.ln("    debug!(?output);");
        g.ln("    Ok(output)");
        g.ln("},");
        g.ln("Err(e) => Err(wrap_sdk_error!(e)),");
        g.ln("}");

        g.ln("}");
        g.lf();
    }

    g.ln("}");
}
