//! Auto generated by `s3s_codegen::v1::xml::codegen`

#![allow(clippy::too_many_lines)]

use super::*;

use crate::dto::*;

use std::io::Write;

//   Serialize: AccelerateConfiguration
// Deserialize: AccelerateConfiguration
//   Serialize: AccessControlPolicy
// Deserialize: AccessControlPolicy
//   Serialize: AnalyticsConfiguration
// Deserialize: AnalyticsConfiguration
//   Serialize: BucketLifecycleConfiguration "LifecycleConfiguration"
// Deserialize: BucketLifecycleConfiguration "LifecycleConfiguration"
//   Serialize: BucketLoggingStatus
// Deserialize: BucketLoggingStatus
//   Serialize: CORSConfiguration
// Deserialize: CORSConfiguration
//   Serialize: CompleteMultipartUploadOutput
//   Serialize: CompletedMultipartUpload "CompleteMultipartUpload"
// Deserialize: CompletedMultipartUpload "CompleteMultipartUpload"
//   Serialize: CopyObjectResult
// Deserialize: CopyObjectResult
//   Serialize: CopyPartResult
// Deserialize: CopyPartResult
//   Serialize: CreateBucketConfiguration
// Deserialize: CreateBucketConfiguration
//   Serialize: CreateMultipartUploadOutput
//   Serialize: Delete
// Deserialize: Delete
//   Serialize: DeleteObjectsOutput
//   Serialize: GetBucketAccelerateConfigurationOutput
//   Serialize: GetBucketAclOutput
// Deserialize: GetBucketAclOutput
//   Serialize: GetBucketCorsOutput
// Deserialize: GetBucketCorsOutput
//   Serialize: GetBucketLifecycleConfigurationOutput
//   Serialize: GetBucketLocationOutput
// Deserialize: GetBucketLocationOutput
//   Serialize: GetBucketLoggingOutput
// Deserialize: GetBucketLoggingOutput
//   Serialize: GetBucketMetadataTableConfigurationResult
// Deserialize: GetBucketMetadataTableConfigurationResult
//   Serialize: GetBucketNotificationConfigurationOutput
// Deserialize: GetBucketNotificationConfigurationOutput
//   Serialize: GetBucketRequestPaymentOutput
// Deserialize: GetBucketRequestPaymentOutput
//   Serialize: GetBucketTaggingOutput
// Deserialize: GetBucketTaggingOutput
//   Serialize: GetBucketVersioningOutput
// Deserialize: GetBucketVersioningOutput
//   Serialize: GetBucketWebsiteOutput
// Deserialize: GetBucketWebsiteOutput
//   Serialize: GetObjectAclOutput
//   Serialize: GetObjectAttributesOutput
//   Serialize: GetObjectTaggingOutput
//   Serialize: IntelligentTieringConfiguration
// Deserialize: IntelligentTieringConfiguration
//   Serialize: InventoryConfiguration
// Deserialize: InventoryConfiguration
//   Serialize: ListBucketAnalyticsConfigurationsOutput
// Deserialize: ListBucketAnalyticsConfigurationsOutput
//   Serialize: ListBucketIntelligentTieringConfigurationsOutput
// Deserialize: ListBucketIntelligentTieringConfigurationsOutput
//   Serialize: ListBucketInventoryConfigurationsOutput
// Deserialize: ListBucketInventoryConfigurationsOutput
//   Serialize: ListBucketMetricsConfigurationsOutput
// Deserialize: ListBucketMetricsConfigurationsOutput
//   Serialize: ListBucketsOutput
// Deserialize: ListBucketsOutput
//   Serialize: ListMultipartUploadsOutput
//   Serialize: ListObjectVersionsOutput
//   Serialize: ListObjectsOutput
//   Serialize: ListObjectsV2Output
//   Serialize: ListPartsOutput
//   Serialize: MetadataTableConfiguration
// Deserialize: MetadataTableConfiguration
//   Serialize: MetricsConfiguration
// Deserialize: MetricsConfiguration
//   Serialize: NotificationConfiguration
// Deserialize: NotificationConfiguration
//   Serialize: ObjectLockConfiguration
// Deserialize: ObjectLockConfiguration
//   Serialize: ObjectLockLegalHold "LegalHold"
// Deserialize: ObjectLockLegalHold "LegalHold"
//   Serialize: ObjectLockRetention "Retention"
// Deserialize: ObjectLockRetention "Retention"
//   Serialize: OwnershipControls
// Deserialize: OwnershipControls
//   Serialize: PolicyStatus
// Deserialize: PolicyStatus
//   Serialize: Progress
// Deserialize: Progress
//   Serialize: PublicAccessBlockConfiguration
// Deserialize: PublicAccessBlockConfiguration
//   Serialize: ReplicationConfiguration
// Deserialize: ReplicationConfiguration
//   Serialize: RequestPaymentConfiguration
// Deserialize: RequestPaymentConfiguration
//   Serialize: RestoreRequest
// Deserialize: RestoreRequest
//   Serialize: SelectObjectContentRequest
// Deserialize: SelectObjectContentRequest
//   Serialize: ServerSideEncryptionConfiguration
// Deserialize: ServerSideEncryptionConfiguration
//   Serialize: Stats
// Deserialize: Stats
//   Serialize: Tagging
// Deserialize: Tagging
//   Serialize: VersioningConfiguration
// Deserialize: VersioningConfiguration
//   Serialize: WebsiteConfiguration
// Deserialize: WebsiteConfiguration

//   SerializeContent: AbortIncompleteMultipartUpload
// DeserializeContent: AbortIncompleteMultipartUpload
//   SerializeContent: AccelerateConfiguration
// DeserializeContent: AccelerateConfiguration
//   SerializeContent: AccessControlPolicy
// DeserializeContent: AccessControlPolicy
//   SerializeContent: AccessControlTranslation
// DeserializeContent: AccessControlTranslation
//   SerializeContent: AccessKeyIdType
// DeserializeContent: AccessKeyIdType
//   SerializeContent: AccessKeySecretType
// DeserializeContent: AccessKeySecretType
//   SerializeContent: AccessPointArn
// DeserializeContent: AccessPointArn
//   SerializeContent: AccountId
// DeserializeContent: AccountId
//   SerializeContent: AllowQuotedRecordDelimiter
// DeserializeContent: AllowQuotedRecordDelimiter
//   SerializeContent: AllowedHeader
// DeserializeContent: AllowedHeader
//   SerializeContent: AllowedMethod
// DeserializeContent: AllowedMethod
//   SerializeContent: AllowedOrigin
// DeserializeContent: AllowedOrigin
//   SerializeContent: AnalyticsAndOperator
// DeserializeContent: AnalyticsAndOperator
//   SerializeContent: AnalyticsConfiguration
// DeserializeContent: AnalyticsConfiguration
//   SerializeContent: AnalyticsExportDestination
// DeserializeContent: AnalyticsExportDestination
//   SerializeContent: AnalyticsFilter
// DeserializeContent: AnalyticsFilter
//   SerializeContent: AnalyticsId
// DeserializeContent: AnalyticsId
//   SerializeContent: AnalyticsS3BucketDestination
// DeserializeContent: AnalyticsS3BucketDestination
//   SerializeContent: AnalyticsS3ExportFileFormat
// DeserializeContent: AnalyticsS3ExportFileFormat
//   SerializeContent: ArnType
// DeserializeContent: ArnType
//   SerializeContent: AssumeRoleOutput
// DeserializeContent: AssumeRoleOutput
//   SerializeContent: AssumedRoleIdType
// DeserializeContent: AssumedRoleIdType
//   SerializeContent: AssumedRoleUser
// DeserializeContent: AssumedRoleUser
//   SerializeContent: Bucket
// DeserializeContent: Bucket
//   SerializeContent: BucketAccelerateStatus
// DeserializeContent: BucketAccelerateStatus
//   SerializeContent: BucketInfo
// DeserializeContent: BucketInfo
//   SerializeContent: BucketKeyEnabled
// DeserializeContent: BucketKeyEnabled
//   SerializeContent: BucketLifecycleConfiguration
// DeserializeContent: BucketLifecycleConfiguration
//   SerializeContent: BucketLocationConstraint
// DeserializeContent: BucketLocationConstraint
//   SerializeContent: BucketLoggingStatus
// DeserializeContent: BucketLoggingStatus
//   SerializeContent: BucketLogsPermission
// DeserializeContent: BucketLogsPermission
//   SerializeContent: BucketName
// DeserializeContent: BucketName
//   SerializeContent: BucketRegion
// DeserializeContent: BucketRegion
//   SerializeContent: BucketType
// DeserializeContent: BucketType
//   SerializeContent: BucketVersioningStatus
// DeserializeContent: BucketVersioningStatus
//   SerializeContent: BytesProcessed
// DeserializeContent: BytesProcessed
//   SerializeContent: BytesReturned
// DeserializeContent: BytesReturned
//   SerializeContent: BytesScanned
// DeserializeContent: BytesScanned
//   SerializeContent: CORSConfiguration
// DeserializeContent: CORSConfiguration
//   SerializeContent: CORSRule
// DeserializeContent: CORSRule
//   SerializeContent: CSVInput
// DeserializeContent: CSVInput
//   SerializeContent: CSVOutput
// DeserializeContent: CSVOutput
//   SerializeContent: Checksum
// DeserializeContent: Checksum
//   SerializeContent: ChecksumAlgorithm
// DeserializeContent: ChecksumAlgorithm
//   SerializeContent: ChecksumCRC32
// DeserializeContent: ChecksumCRC32
//   SerializeContent: ChecksumCRC32C
// DeserializeContent: ChecksumCRC32C
//   SerializeContent: ChecksumCRC64NVME
// DeserializeContent: ChecksumCRC64NVME
//   SerializeContent: ChecksumSHA1
// DeserializeContent: ChecksumSHA1
//   SerializeContent: ChecksumSHA256
// DeserializeContent: ChecksumSHA256
//   SerializeContent: ChecksumType
// DeserializeContent: ChecksumType
//   SerializeContent: Code
// DeserializeContent: Code
//   SerializeContent: Comments
// DeserializeContent: Comments
//   SerializeContent: CommonPrefix
// DeserializeContent: CommonPrefix
//   SerializeContent: CompleteMultipartUploadOutput
//   SerializeContent: CompletedMultipartUpload
// DeserializeContent: CompletedMultipartUpload
//   SerializeContent: CompletedPart
// DeserializeContent: CompletedPart
//   SerializeContent: CompressionType
// DeserializeContent: CompressionType
//   SerializeContent: Condition
// DeserializeContent: Condition
//   SerializeContent: CopyObjectResult
// DeserializeContent: CopyObjectResult
//   SerializeContent: CopyPartResult
// DeserializeContent: CopyPartResult
//   SerializeContent: CreateBucketConfiguration
// DeserializeContent: CreateBucketConfiguration
//   SerializeContent: CreateMultipartUploadOutput
//   SerializeContent: CreationDate
// DeserializeContent: CreationDate
//   SerializeContent: Credentials
// DeserializeContent: Credentials
//   SerializeContent: DataRedundancy
// DeserializeContent: DataRedundancy
//   SerializeContent: Date
// DeserializeContent: Date
//   SerializeContent: DateType
// DeserializeContent: DateType
//   SerializeContent: Days
// DeserializeContent: Days
//   SerializeContent: DaysAfterInitiation
// DeserializeContent: DaysAfterInitiation
//   SerializeContent: DefaultRetention
// DeserializeContent: DefaultRetention
//   SerializeContent: Delete
// DeserializeContent: Delete
//   SerializeContent: DeleteMarker
// DeserializeContent: DeleteMarker
//   SerializeContent: DeleteMarkerEntry
// DeserializeContent: DeleteMarkerEntry
//   SerializeContent: DeleteMarkerReplication
// DeserializeContent: DeleteMarkerReplication
//   SerializeContent: DeleteMarkerReplicationStatus
// DeserializeContent: DeleteMarkerReplicationStatus
//   SerializeContent: DeleteMarkerVersionId
// DeserializeContent: DeleteMarkerVersionId
//   SerializeContent: DeleteObjectsOutput
//   SerializeContent: DeleteReplication
// DeserializeContent: DeleteReplication
//   SerializeContent: DeleteReplicationStatus
// DeserializeContent: DeleteReplicationStatus
//   SerializeContent: DeletedObject
// DeserializeContent: DeletedObject
//   SerializeContent: Delimiter
// DeserializeContent: Delimiter
//   SerializeContent: Description
// DeserializeContent: Description
//   SerializeContent: Destination
// DeserializeContent: Destination
//   SerializeContent: DisplayName
// DeserializeContent: DisplayName
//   SerializeContent: ETag
// DeserializeContent: ETag
//   SerializeContent: EmailAddress
// DeserializeContent: EmailAddress
//   SerializeContent: EnableRequestProgress
// DeserializeContent: EnableRequestProgress
//   SerializeContent: EncodingType
// DeserializeContent: EncodingType
//   SerializeContent: Encryption
// DeserializeContent: Encryption
//   SerializeContent: EncryptionConfiguration
// DeserializeContent: EncryptionConfiguration
//   SerializeContent: End
// DeserializeContent: End
//   SerializeContent: Error
// DeserializeContent: Error
//   SerializeContent: ErrorCode
// DeserializeContent: ErrorCode
//   SerializeContent: ErrorDetails
// DeserializeContent: ErrorDetails
//   SerializeContent: ErrorDocument
// DeserializeContent: ErrorDocument
//   SerializeContent: ErrorMessage
// DeserializeContent: ErrorMessage
//   SerializeContent: Event
// DeserializeContent: Event
//   SerializeContent: EventBridgeConfiguration
// DeserializeContent: EventBridgeConfiguration
//   SerializeContent: ExcludeFolders
// DeserializeContent: ExcludeFolders
//   SerializeContent: ExcludedPrefix
// DeserializeContent: ExcludedPrefix
//   SerializeContent: ExistingObjectReplication
// DeserializeContent: ExistingObjectReplication
//   SerializeContent: ExistingObjectReplicationStatus
// DeserializeContent: ExistingObjectReplicationStatus
//   SerializeContent: ExpirationStatus
// DeserializeContent: ExpirationStatus
//   SerializeContent: ExpiredObjectDeleteMarker
// DeserializeContent: ExpiredObjectDeleteMarker
//   SerializeContent: ExposeHeader
// DeserializeContent: ExposeHeader
//   SerializeContent: Expression
// DeserializeContent: Expression
//   SerializeContent: ExpressionType
// DeserializeContent: ExpressionType
//   SerializeContent: FieldDelimiter
// DeserializeContent: FieldDelimiter
//   SerializeContent: FileHeaderInfo
// DeserializeContent: FileHeaderInfo
//   SerializeContent: FilterRule
// DeserializeContent: FilterRule
//   SerializeContent: FilterRuleName
// DeserializeContent: FilterRuleName
//   SerializeContent: FilterRuleValue
// DeserializeContent: FilterRuleValue
//   SerializeContent: GetBucketAccelerateConfigurationOutput
//   SerializeContent: GetBucketAclOutput
// DeserializeContent: GetBucketAclOutput
//   SerializeContent: GetBucketCorsOutput
// DeserializeContent: GetBucketCorsOutput
//   SerializeContent: GetBucketLifecycleConfigurationOutput
//   SerializeContent: GetBucketLocationOutput
// DeserializeContent: GetBucketLocationOutput
//   SerializeContent: GetBucketLoggingOutput
// DeserializeContent: GetBucketLoggingOutput
//   SerializeContent: GetBucketMetadataTableConfigurationResult
// DeserializeContent: GetBucketMetadataTableConfigurationResult
//   SerializeContent: GetBucketNotificationConfigurationOutput
// DeserializeContent: GetBucketNotificationConfigurationOutput
//   SerializeContent: GetBucketRequestPaymentOutput
// DeserializeContent: GetBucketRequestPaymentOutput
//   SerializeContent: GetBucketTaggingOutput
// DeserializeContent: GetBucketTaggingOutput
//   SerializeContent: GetBucketVersioningOutput
// DeserializeContent: GetBucketVersioningOutput
//   SerializeContent: GetBucketWebsiteOutput
// DeserializeContent: GetBucketWebsiteOutput
//   SerializeContent: GetObjectAclOutput
//   SerializeContent: GetObjectAttributesOutput
//   SerializeContent: GetObjectAttributesParts
// DeserializeContent: GetObjectAttributesParts
//   SerializeContent: GetObjectTaggingOutput
//   SerializeContent: GlacierJobParameters
// DeserializeContent: GlacierJobParameters
//   SerializeContent: Grant
// DeserializeContent: Grant
//   SerializeContent: Grantee
//   SerializeContent: HostName
// DeserializeContent: HostName
//   SerializeContent: HttpErrorCodeReturnedEquals
// DeserializeContent: HttpErrorCodeReturnedEquals
//   SerializeContent: HttpRedirectCode
// DeserializeContent: HttpRedirectCode
//   SerializeContent: ID
// DeserializeContent: ID
//   SerializeContent: IndexDocument
// DeserializeContent: IndexDocument
//   SerializeContent: Initiated
// DeserializeContent: Initiated
//   SerializeContent: Initiator
// DeserializeContent: Initiator
//   SerializeContent: InputSerialization
// DeserializeContent: InputSerialization
//   SerializeContent: IntelligentTieringAccessTier
// DeserializeContent: IntelligentTieringAccessTier
//   SerializeContent: IntelligentTieringAndOperator
// DeserializeContent: IntelligentTieringAndOperator
//   SerializeContent: IntelligentTieringConfiguration
// DeserializeContent: IntelligentTieringConfiguration
//   SerializeContent: IntelligentTieringDays
// DeserializeContent: IntelligentTieringDays
//   SerializeContent: IntelligentTieringFilter
// DeserializeContent: IntelligentTieringFilter
//   SerializeContent: IntelligentTieringId
// DeserializeContent: IntelligentTieringId
//   SerializeContent: IntelligentTieringStatus
// DeserializeContent: IntelligentTieringStatus
//   SerializeContent: InventoryConfiguration
// DeserializeContent: InventoryConfiguration
//   SerializeContent: InventoryDestination
// DeserializeContent: InventoryDestination
//   SerializeContent: InventoryEncryption
// DeserializeContent: InventoryEncryption
//   SerializeContent: InventoryFilter
// DeserializeContent: InventoryFilter
//   SerializeContent: InventoryFormat
// DeserializeContent: InventoryFormat
//   SerializeContent: InventoryFrequency
// DeserializeContent: InventoryFrequency
//   SerializeContent: InventoryId
// DeserializeContent: InventoryId
//   SerializeContent: InventoryIncludedObjectVersions
// DeserializeContent: InventoryIncludedObjectVersions
//   SerializeContent: InventoryOptionalField
// DeserializeContent: InventoryOptionalField
//   SerializeContent: InventoryS3BucketDestination
// DeserializeContent: InventoryS3BucketDestination
//   SerializeContent: InventorySchedule
// DeserializeContent: InventorySchedule
//   SerializeContent: IsEnabled
// DeserializeContent: IsEnabled
//   SerializeContent: IsLatest
// DeserializeContent: IsLatest
//   SerializeContent: IsPublic
// DeserializeContent: IsPublic
//   SerializeContent: IsRestoreInProgress
// DeserializeContent: IsRestoreInProgress
//   SerializeContent: IsTruncated
// DeserializeContent: IsTruncated
//   SerializeContent: JSONInput
// DeserializeContent: JSONInput
//   SerializeContent: JSONOutput
// DeserializeContent: JSONOutput
//   SerializeContent: JSONType
// DeserializeContent: JSONType
//   SerializeContent: KMSContext
// DeserializeContent: KMSContext
//   SerializeContent: KeyCount
// DeserializeContent: KeyCount
//   SerializeContent: KeyMarker
// DeserializeContent: KeyMarker
//   SerializeContent: KeyPrefixEquals
// DeserializeContent: KeyPrefixEquals
//   SerializeContent: LambdaFunctionArn
// DeserializeContent: LambdaFunctionArn
//   SerializeContent: LambdaFunctionConfiguration
// DeserializeContent: LambdaFunctionConfiguration
//   SerializeContent: LastModified
// DeserializeContent: LastModified
//   SerializeContent: LastModifiedTime
// DeserializeContent: LastModifiedTime
//   SerializeContent: LifecycleExpiration
// DeserializeContent: LifecycleExpiration
//   SerializeContent: LifecycleRule
// DeserializeContent: LifecycleRule
//   SerializeContent: LifecycleRuleAndOperator
// DeserializeContent: LifecycleRuleAndOperator
//   SerializeContent: LifecycleRuleFilter
// DeserializeContent: LifecycleRuleFilter
//   SerializeContent: ListBucketAnalyticsConfigurationsOutput
// DeserializeContent: ListBucketAnalyticsConfigurationsOutput
//   SerializeContent: ListBucketIntelligentTieringConfigurationsOutput
// DeserializeContent: ListBucketIntelligentTieringConfigurationsOutput
//   SerializeContent: ListBucketInventoryConfigurationsOutput
// DeserializeContent: ListBucketInventoryConfigurationsOutput
//   SerializeContent: ListBucketMetricsConfigurationsOutput
// DeserializeContent: ListBucketMetricsConfigurationsOutput
//   SerializeContent: ListBucketsOutput
// DeserializeContent: ListBucketsOutput
//   SerializeContent: ListMultipartUploadsOutput
//   SerializeContent: ListObjectVersionsOutput
//   SerializeContent: ListObjectsOutput
//   SerializeContent: ListObjectsV2Output
//   SerializeContent: ListPartsOutput
//   SerializeContent: Location
// DeserializeContent: Location
//   SerializeContent: LocationInfo
// DeserializeContent: LocationInfo
//   SerializeContent: LocationNameAsString
// DeserializeContent: LocationNameAsString
//   SerializeContent: LocationPrefix
// DeserializeContent: LocationPrefix
//   SerializeContent: LocationType
// DeserializeContent: LocationType
//   SerializeContent: LoggingEnabled
// DeserializeContent: LoggingEnabled
//   SerializeContent: MFADelete
// DeserializeContent: MFADelete
//   SerializeContent: MFADeleteStatus
// DeserializeContent: MFADeleteStatus
//   SerializeContent: Marker
// DeserializeContent: Marker
//   SerializeContent: MaxAgeSeconds
// DeserializeContent: MaxAgeSeconds
//   SerializeContent: MaxKeys
// DeserializeContent: MaxKeys
//   SerializeContent: MaxParts
// DeserializeContent: MaxParts
//   SerializeContent: MaxUploads
// DeserializeContent: MaxUploads
//   SerializeContent: Message
// DeserializeContent: Message
//   SerializeContent: MetadataEntry
// DeserializeContent: MetadataEntry
//   SerializeContent: MetadataKey
// DeserializeContent: MetadataKey
//   SerializeContent: MetadataTableConfiguration
// DeserializeContent: MetadataTableConfiguration
//   SerializeContent: MetadataTableConfigurationResult
// DeserializeContent: MetadataTableConfigurationResult
//   SerializeContent: MetadataTableStatus
// DeserializeContent: MetadataTableStatus
//   SerializeContent: MetadataValue
// DeserializeContent: MetadataValue
//   SerializeContent: Metrics
// DeserializeContent: Metrics
//   SerializeContent: MetricsAndOperator
// DeserializeContent: MetricsAndOperator
//   SerializeContent: MetricsConfiguration
// DeserializeContent: MetricsConfiguration
//   SerializeContent: MetricsFilter
// DeserializeContent: MetricsFilter
//   SerializeContent: MetricsId
// DeserializeContent: MetricsId
//   SerializeContent: MetricsStatus
// DeserializeContent: MetricsStatus
//   SerializeContent: Minutes
// DeserializeContent: Minutes
//   SerializeContent: MultipartUpload
// DeserializeContent: MultipartUpload
//   SerializeContent: MultipartUploadId
// DeserializeContent: MultipartUploadId
//   SerializeContent: NextKeyMarker
// DeserializeContent: NextKeyMarker
//   SerializeContent: NextMarker
// DeserializeContent: NextMarker
//   SerializeContent: NextPartNumberMarker
// DeserializeContent: NextPartNumberMarker
//   SerializeContent: NextToken
// DeserializeContent: NextToken
//   SerializeContent: NextUploadIdMarker
// DeserializeContent: NextUploadIdMarker
//   SerializeContent: NextVersionIdMarker
// DeserializeContent: NextVersionIdMarker
//   SerializeContent: NonNegativeIntegerType
// DeserializeContent: NonNegativeIntegerType
//   SerializeContent: NoncurrentVersionExpiration
// DeserializeContent: NoncurrentVersionExpiration
//   SerializeContent: NoncurrentVersionTransition
// DeserializeContent: NoncurrentVersionTransition
//   SerializeContent: NotificationConfiguration
// DeserializeContent: NotificationConfiguration
//   SerializeContent: NotificationConfigurationFilter
// DeserializeContent: NotificationConfigurationFilter
//   SerializeContent: NotificationId
// DeserializeContent: NotificationId
//   SerializeContent: Object
// DeserializeContent: Object
//   SerializeContent: ObjectCannedACL
// DeserializeContent: ObjectCannedACL
//   SerializeContent: ObjectIdentifier
// DeserializeContent: ObjectIdentifier
//   SerializeContent: ObjectKey
// DeserializeContent: ObjectKey
//   SerializeContent: ObjectLockConfiguration
// DeserializeContent: ObjectLockConfiguration
//   SerializeContent: ObjectLockEnabled
// DeserializeContent: ObjectLockEnabled
//   SerializeContent: ObjectLockLegalHold
// DeserializeContent: ObjectLockLegalHold
//   SerializeContent: ObjectLockLegalHoldStatus
// DeserializeContent: ObjectLockLegalHoldStatus
//   SerializeContent: ObjectLockRetention
// DeserializeContent: ObjectLockRetention
//   SerializeContent: ObjectLockRetentionMode
// DeserializeContent: ObjectLockRetentionMode
//   SerializeContent: ObjectLockRule
// DeserializeContent: ObjectLockRule
//   SerializeContent: ObjectOwnership
// DeserializeContent: ObjectOwnership
//   SerializeContent: ObjectPart
// DeserializeContent: ObjectPart
//   SerializeContent: ObjectSize
// DeserializeContent: ObjectSize
//   SerializeContent: ObjectSizeGreaterThanBytes
// DeserializeContent: ObjectSizeGreaterThanBytes
//   SerializeContent: ObjectSizeLessThanBytes
// DeserializeContent: ObjectSizeLessThanBytes
//   SerializeContent: ObjectStorageClass
// DeserializeContent: ObjectStorageClass
//   SerializeContent: ObjectVersion
// DeserializeContent: ObjectVersion
//   SerializeContent: ObjectVersionId
// DeserializeContent: ObjectVersionId
//   SerializeContent: ObjectVersionStorageClass
// DeserializeContent: ObjectVersionStorageClass
//   SerializeContent: OutputLocation
// DeserializeContent: OutputLocation
//   SerializeContent: OutputSerialization
// DeserializeContent: OutputSerialization
//   SerializeContent: Owner
// DeserializeContent: Owner
//   SerializeContent: OwnerOverride
// DeserializeContent: OwnerOverride
//   SerializeContent: OwnershipControls
// DeserializeContent: OwnershipControls
//   SerializeContent: OwnershipControlsRule
// DeserializeContent: OwnershipControlsRule
//   SerializeContent: ParquetInput
// DeserializeContent: ParquetInput
//   SerializeContent: Part
// DeserializeContent: Part
//   SerializeContent: PartNumber
// DeserializeContent: PartNumber
//   SerializeContent: PartNumberMarker
// DeserializeContent: PartNumberMarker
//   SerializeContent: PartitionDateSource
// DeserializeContent: PartitionDateSource
//   SerializeContent: PartitionedPrefix
// DeserializeContent: PartitionedPrefix
//   SerializeContent: PartsCount
// DeserializeContent: PartsCount
//   SerializeContent: Payer
// DeserializeContent: Payer
//   SerializeContent: Permission
// DeserializeContent: Permission
//   SerializeContent: PolicyStatus
// DeserializeContent: PolicyStatus
//   SerializeContent: Prefix
// DeserializeContent: Prefix
//   SerializeContent: Priority
// DeserializeContent: Priority
//   SerializeContent: Progress
// DeserializeContent: Progress
//   SerializeContent: Protocol
// DeserializeContent: Protocol
//   SerializeContent: PublicAccessBlockConfiguration
// DeserializeContent: PublicAccessBlockConfiguration
//   SerializeContent: QueueArn
// DeserializeContent: QueueArn
//   SerializeContent: QueueConfiguration
// DeserializeContent: QueueConfiguration
//   SerializeContent: Quiet
// DeserializeContent: Quiet
//   SerializeContent: QuoteCharacter
// DeserializeContent: QuoteCharacter
//   SerializeContent: QuoteEscapeCharacter
// DeserializeContent: QuoteEscapeCharacter
//   SerializeContent: QuoteFields
// DeserializeContent: QuoteFields
//   SerializeContent: RecordDelimiter
// DeserializeContent: RecordDelimiter
//   SerializeContent: Redirect
// DeserializeContent: Redirect
//   SerializeContent: RedirectAllRequestsTo
// DeserializeContent: RedirectAllRequestsTo
//   SerializeContent: ReplaceKeyPrefixWith
// DeserializeContent: ReplaceKeyPrefixWith
//   SerializeContent: ReplaceKeyWith
// DeserializeContent: ReplaceKeyWith
//   SerializeContent: ReplicaKmsKeyID
// DeserializeContent: ReplicaKmsKeyID
//   SerializeContent: ReplicaModifications
// DeserializeContent: ReplicaModifications
//   SerializeContent: ReplicaModificationsStatus
// DeserializeContent: ReplicaModificationsStatus
//   SerializeContent: ReplicationConfiguration
// DeserializeContent: ReplicationConfiguration
//   SerializeContent: ReplicationRule
// DeserializeContent: ReplicationRule
//   SerializeContent: ReplicationRuleAndOperator
// DeserializeContent: ReplicationRuleAndOperator
//   SerializeContent: ReplicationRuleFilter
// DeserializeContent: ReplicationRuleFilter
//   SerializeContent: ReplicationRuleStatus
// DeserializeContent: ReplicationRuleStatus
//   SerializeContent: ReplicationTime
// DeserializeContent: ReplicationTime
//   SerializeContent: ReplicationTimeStatus
// DeserializeContent: ReplicationTimeStatus
//   SerializeContent: ReplicationTimeValue
// DeserializeContent: ReplicationTimeValue
//   SerializeContent: RequestPaymentConfiguration
// DeserializeContent: RequestPaymentConfiguration
//   SerializeContent: RequestProgress
// DeserializeContent: RequestProgress
//   SerializeContent: RestoreExpiryDate
// DeserializeContent: RestoreExpiryDate
//   SerializeContent: RestoreRequest
// DeserializeContent: RestoreRequest
//   SerializeContent: RestoreRequestType
// DeserializeContent: RestoreRequestType
//   SerializeContent: RestoreStatus
// DeserializeContent: RestoreStatus
//   SerializeContent: Role
// DeserializeContent: Role
//   SerializeContent: RoutingRule
// DeserializeContent: RoutingRule
//   SerializeContent: S3KeyFilter
// DeserializeContent: S3KeyFilter
//   SerializeContent: S3Location
// DeserializeContent: S3Location
//   SerializeContent: S3TablesArn
// DeserializeContent: S3TablesArn
//   SerializeContent: S3TablesBucketArn
// DeserializeContent: S3TablesBucketArn
//   SerializeContent: S3TablesDestination
// DeserializeContent: S3TablesDestination
//   SerializeContent: S3TablesDestinationResult
// DeserializeContent: S3TablesDestinationResult
//   SerializeContent: S3TablesName
// DeserializeContent: S3TablesName
//   SerializeContent: S3TablesNamespace
// DeserializeContent: S3TablesNamespace
//   SerializeContent: SSEKMS
// DeserializeContent: SSEKMS
//   SerializeContent: SSEKMSKeyId
// DeserializeContent: SSEKMSKeyId
//   SerializeContent: SSES3
// DeserializeContent: SSES3
//   SerializeContent: ScanRange
// DeserializeContent: ScanRange
//   SerializeContent: SelectObjectContentRequest
// DeserializeContent: SelectObjectContentRequest
//   SerializeContent: SelectParameters
// DeserializeContent: SelectParameters
//   SerializeContent: ServerSideEncryption
// DeserializeContent: ServerSideEncryption
//   SerializeContent: ServerSideEncryptionByDefault
// DeserializeContent: ServerSideEncryptionByDefault
//   SerializeContent: ServerSideEncryptionConfiguration
// DeserializeContent: ServerSideEncryptionConfiguration
//   SerializeContent: ServerSideEncryptionRule
// DeserializeContent: ServerSideEncryptionRule
//   SerializeContent: Setting
// DeserializeContent: Setting
//   SerializeContent: SimplePrefix
// DeserializeContent: SimplePrefix
//   SerializeContent: Size
// DeserializeContent: Size
//   SerializeContent: SourceIdentityType
// DeserializeContent: SourceIdentityType
//   SerializeContent: SourceSelectionCriteria
// DeserializeContent: SourceSelectionCriteria
//   SerializeContent: SseKmsEncryptedObjects
// DeserializeContent: SseKmsEncryptedObjects
//   SerializeContent: SseKmsEncryptedObjectsStatus
// DeserializeContent: SseKmsEncryptedObjectsStatus
//   SerializeContent: Start
// DeserializeContent: Start
//   SerializeContent: StartAfter
// DeserializeContent: StartAfter
//   SerializeContent: Stats
// DeserializeContent: Stats
//   SerializeContent: StorageClass
// DeserializeContent: StorageClass
//   SerializeContent: StorageClassAnalysis
// DeserializeContent: StorageClassAnalysis
//   SerializeContent: StorageClassAnalysisDataExport
// DeserializeContent: StorageClassAnalysisDataExport
//   SerializeContent: StorageClassAnalysisSchemaVersion
// DeserializeContent: StorageClassAnalysisSchemaVersion
//   SerializeContent: Suffix
// DeserializeContent: Suffix
//   SerializeContent: Tag
// DeserializeContent: Tag
//   SerializeContent: Tagging
// DeserializeContent: Tagging
//   SerializeContent: TargetBucket
// DeserializeContent: TargetBucket
//   SerializeContent: TargetGrant
// DeserializeContent: TargetGrant
//   SerializeContent: TargetObjectKeyFormat
// DeserializeContent: TargetObjectKeyFormat
//   SerializeContent: TargetPrefix
// DeserializeContent: TargetPrefix
//   SerializeContent: Tier
// DeserializeContent: Tier
//   SerializeContent: Tiering
// DeserializeContent: Tiering
//   SerializeContent: Token
// DeserializeContent: Token
//   SerializeContent: TokenType
// DeserializeContent: TokenType
//   SerializeContent: TopicArn
// DeserializeContent: TopicArn
//   SerializeContent: TopicConfiguration
// DeserializeContent: TopicConfiguration
//   SerializeContent: Transition
// DeserializeContent: Transition
//   SerializeContent: TransitionStorageClass
// DeserializeContent: TransitionStorageClass
//   SerializeContent: Type
// DeserializeContent: Type
//   SerializeContent: URI
// DeserializeContent: URI
//   SerializeContent: UploadIdMarker
// DeserializeContent: UploadIdMarker
//   SerializeContent: Value
// DeserializeContent: Value
//   SerializeContent: VersionCount
// DeserializeContent: VersionCount
//   SerializeContent: VersionIdMarker
// DeserializeContent: VersionIdMarker
//   SerializeContent: VersioningConfiguration
// DeserializeContent: VersioningConfiguration
//   SerializeContent: WebsiteConfiguration
// DeserializeContent: WebsiteConfiguration
//   SerializeContent: Years
// DeserializeContent: Years

const XMLNS_S3: &str = "http://s3.amazonaws.com/doc/2006-03-01/";

impl Serialize for AccelerateConfiguration {
    fn serialize<W: Write>(&self, s: &mut Serializer<W>) -> SerResult {
        s.content("AccelerateConfiguration", self)
    }
}

impl<'xml> Deserialize<'xml> for AccelerateConfiguration {
    fn deserialize(d: &mut Deserializer<'xml>) -> DeResult<Self> {
        d.named_element("AccelerateConfiguration", Deserializer::content)
    }
}

impl Serialize for AccessControlPolicy {
    fn serialize<W: Write>(&self, s: &mut Serializer<W>) -> SerResult {
        s.content("AccessControlPolicy", self)
    }
}

impl<'xml> Deserialize<'xml> for AccessControlPolicy {
    fn deserialize(d: &mut Deserializer<'xml>) -> DeResult<Self> {
        d.named_element("AccessControlPolicy", Deserializer::content)
    }
}

impl Serialize for AnalyticsConfiguration {
    fn serialize<W: Write>(&self, s: &mut Serializer<W>) -> SerResult {
        s.content("AnalyticsConfiguration", self)
    }
}

impl<'xml> Deserialize<'xml> for AnalyticsConfiguration {
    fn deserialize(d: &mut Deserializer<'xml>) -> DeResult<Self> {
        d.named_element("AnalyticsConfiguration", Deserializer::content)
    }
}

impl Serialize for BucketLifecycleConfiguration {
    fn serialize<W: Write>(&self, s: &mut Serializer<W>) -> SerResult {
        s.content("LifecycleConfiguration", self)
    }
}

impl<'xml> Deserialize<'xml> for BucketLifecycleConfiguration {
    fn deserialize(d: &mut Deserializer<'xml>) -> DeResult<Self> {
        d.named_element("LifecycleConfiguration", Deserializer::content)
    }
}

impl Serialize for BucketLoggingStatus {
    fn serialize<W: Write>(&self, s: &mut Serializer<W>) -> SerResult {
        s.content("BucketLoggingStatus", self)
    }
}

impl<'xml> Deserialize<'xml> for BucketLoggingStatus {
    fn deserialize(d: &mut Deserializer<'xml>) -> DeResult<Self> {
        d.named_element("BucketLoggingStatus", Deserializer::content)
    }
}

impl Serialize for CORSConfiguration {
    fn serialize<W: Write>(&self, s: &mut Serializer<W>) -> SerResult {
        s.content("CORSConfiguration", self)
    }
}

impl<'xml> Deserialize<'xml> for CORSConfiguration {
    fn deserialize(d: &mut Deserializer<'xml>) -> DeResult<Self> {
        d.named_element("CORSConfiguration", Deserializer::content)
    }
}

impl Serialize for CompleteMultipartUploadOutput {
    fn serialize<W: Write>(&self, s: &mut Serializer<W>) -> SerResult {
        s.content_with_ns("CompleteMultipartUploadResult", XMLNS_S3, self)
    }
}

impl Serialize for CompletedMultipartUpload {
    fn serialize<W: Write>(&self, s: &mut Serializer<W>) -> SerResult {
        s.content("CompleteMultipartUpload", self)
    }
}

impl<'xml> Deserialize<'xml> for CompletedMultipartUpload {
    fn deserialize(d: &mut Deserializer<'xml>) -> DeResult<Self> {
        d.named_element("CompleteMultipartUpload", Deserializer::content)
    }
}

impl Serialize for CopyObjectResult {
    fn serialize<W: Write>(&self, s: &mut Serializer<W>) -> SerResult {
        s.content("CopyObjectResult", self)
    }
}

impl<'xml> Deserialize<'xml> for CopyObjectResult {
    fn deserialize(d: &mut Deserializer<'xml>) -> DeResult<Self> {
        d.named_element("CopyObjectResult", Deserializer::content)
    }
}

impl Serialize for CopyPartResult {
    fn serialize<W: Write>(&self, s: &mut Serializer<W>) -> SerResult {
        s.content("CopyPartResult", self)
    }
}

impl<'xml> Deserialize<'xml> for CopyPartResult {
    fn deserialize(d: &mut Deserializer<'xml>) -> DeResult<Self> {
        d.named_element("CopyPartResult", Deserializer::content)
    }
}

impl Serialize for CreateBucketConfiguration {
    fn serialize<W: Write>(&self, s: &mut Serializer<W>) -> SerResult {
        s.content("CreateBucketConfiguration", self)
    }
}

impl<'xml> Deserialize<'xml> for CreateBucketConfiguration {
    fn deserialize(d: &mut Deserializer<'xml>) -> DeResult<Self> {
        d.named_element("CreateBucketConfiguration", Deserializer::content)
    }
}

impl Serialize for CreateMultipartUploadOutput {
    fn serialize<W: Write>(&self, s: &mut Serializer<W>) -> SerResult {
        s.content_with_ns("InitiateMultipartUploadResult", XMLNS_S3, self)
    }
}

impl Serialize for Delete {
    fn serialize<W: Write>(&self, s: &mut Serializer<W>) -> SerResult {
        s.content("Delete", self)
    }
}

impl<'xml> Deserialize<'xml> for Delete {
    fn deserialize(d: &mut Deserializer<'xml>) -> DeResult<Self> {
        d.named_element("Delete", Deserializer::content)
    }
}

impl Serialize for DeleteObjectsOutput {
    fn serialize<W: Write>(&self, s: &mut Serializer<W>) -> SerResult {
        s.content_with_ns("DeleteResult", XMLNS_S3, self)
    }
}

impl Serialize for GetBucketAccelerateConfigurationOutput {
    fn serialize<W: Write>(&self, s: &mut Serializer<W>) -> SerResult {
        s.content_with_ns("AccelerateConfiguration", XMLNS_S3, self)
    }
}

impl Serialize for GetBucketAclOutput {
    fn serialize<W: Write>(&self, s: &mut Serializer<W>) -> SerResult {
        s.content_with_ns("AccessControlPolicy", XMLNS_S3, self)
    }
}

impl<'xml> Deserialize<'xml> for GetBucketAclOutput {
    fn deserialize(d: &mut Deserializer<'xml>) -> DeResult<Self> {
        d.named_element("AccessControlPolicy", Deserializer::content)
    }
}

impl Serialize for GetBucketCorsOutput {
    fn serialize<W: Write>(&self, s: &mut Serializer<W>) -> SerResult {
        s.content_with_ns("CORSConfiguration", XMLNS_S3, self)
    }
}

impl<'xml> Deserialize<'xml> for GetBucketCorsOutput {
    fn deserialize(d: &mut Deserializer<'xml>) -> DeResult<Self> {
        d.named_element("CORSConfiguration", Deserializer::content)
    }
}

impl Serialize for GetBucketLifecycleConfigurationOutput {
    fn serialize<W: Write>(&self, s: &mut Serializer<W>) -> SerResult {
        s.content_with_ns("LifecycleConfiguration", XMLNS_S3, self)
    }
}

impl Serialize for GetBucketLoggingOutput {
    fn serialize<W: Write>(&self, s: &mut Serializer<W>) -> SerResult {
        s.content_with_ns("BucketLoggingStatus", XMLNS_S3, self)
    }
}

impl<'xml> Deserialize<'xml> for GetBucketLoggingOutput {
    fn deserialize(d: &mut Deserializer<'xml>) -> DeResult<Self> {
        d.named_element("BucketLoggingStatus", Deserializer::content)
    }
}

impl Serialize for GetBucketMetadataTableConfigurationResult {
    fn serialize<W: Write>(&self, s: &mut Serializer<W>) -> SerResult {
        s.content("GetBucketMetadataTableConfigurationResult", self)
    }
}

impl<'xml> Deserialize<'xml> for GetBucketMetadataTableConfigurationResult {
    fn deserialize(d: &mut Deserializer<'xml>) -> DeResult<Self> {
        d.named_element("GetBucketMetadataTableConfigurationResult", Deserializer::content)
    }
}

impl Serialize for GetBucketNotificationConfigurationOutput {
    fn serialize<W: Write>(&self, s: &mut Serializer<W>) -> SerResult {
        s.content_with_ns("NotificationConfiguration", XMLNS_S3, self)
    }
}

impl<'xml> Deserialize<'xml> for GetBucketNotificationConfigurationOutput {
    fn deserialize(d: &mut Deserializer<'xml>) -> DeResult<Self> {
        d.named_element("NotificationConfiguration", Deserializer::content)
    }
}

impl Serialize for GetBucketRequestPaymentOutput {
    fn serialize<W: Write>(&self, s: &mut Serializer<W>) -> SerResult {
        s.content_with_ns("RequestPaymentConfiguration", XMLNS_S3, self)
    }
}

impl<'xml> Deserialize<'xml> for GetBucketRequestPaymentOutput {
    fn deserialize(d: &mut Deserializer<'xml>) -> DeResult<Self> {
        d.named_element("RequestPaymentConfiguration", Deserializer::content)
    }
}

impl Serialize for GetBucketTaggingOutput {
    fn serialize<W: Write>(&self, s: &mut Serializer<W>) -> SerResult {
        s.content_with_ns("Tagging", XMLNS_S3, self)
    }
}

impl<'xml> Deserialize<'xml> for GetBucketTaggingOutput {
    fn deserialize(d: &mut Deserializer<'xml>) -> DeResult<Self> {
        d.named_element("Tagging", Deserializer::content)
    }
}

impl Serialize for GetBucketVersioningOutput {
    fn serialize<W: Write>(&self, s: &mut Serializer<W>) -> SerResult {
        s.content_with_ns("VersioningConfiguration", XMLNS_S3, self)
    }
}

impl<'xml> Deserialize<'xml> for GetBucketVersioningOutput {
    fn deserialize(d: &mut Deserializer<'xml>) -> DeResult<Self> {
        d.named_element("VersioningConfiguration", Deserializer::content)
    }
}

impl Serialize for GetBucketWebsiteOutput {
    fn serialize<W: Write>(&self, s: &mut Serializer<W>) -> SerResult {
        s.content_with_ns("WebsiteConfiguration", XMLNS_S3, self)
    }
}

impl<'xml> Deserialize<'xml> for GetBucketWebsiteOutput {
    fn deserialize(d: &mut Deserializer<'xml>) -> DeResult<Self> {
        d.named_element("WebsiteConfiguration", Deserializer::content)
    }
}

impl Serialize for GetObjectAclOutput {
    fn serialize<W: Write>(&self, s: &mut Serializer<W>) -> SerResult {
        s.content_with_ns("AccessControlPolicy", XMLNS_S3, self)
    }
}

impl Serialize for GetObjectAttributesOutput {
    fn serialize<W: Write>(&self, s: &mut Serializer<W>) -> SerResult {
        s.content_with_ns("GetObjectAttributesResponse", XMLNS_S3, self)
    }
}

impl Serialize for GetObjectTaggingOutput {
    fn serialize<W: Write>(&self, s: &mut Serializer<W>) -> SerResult {
        s.content_with_ns("Tagging", XMLNS_S3, self)
    }
}

impl Serialize for IntelligentTieringConfiguration {
    fn serialize<W: Write>(&self, s: &mut Serializer<W>) -> SerResult {
        s.content("IntelligentTieringConfiguration", self)
    }
}

impl<'xml> Deserialize<'xml> for IntelligentTieringConfiguration {
    fn deserialize(d: &mut Deserializer<'xml>) -> DeResult<Self> {
        d.named_element("IntelligentTieringConfiguration", Deserializer::content)
    }
}

impl Serialize for InventoryConfiguration {
    fn serialize<W: Write>(&self, s: &mut Serializer<W>) -> SerResult {
        s.content("InventoryConfiguration", self)
    }
}

impl<'xml> Deserialize<'xml> for InventoryConfiguration {
    fn deserialize(d: &mut Deserializer<'xml>) -> DeResult<Self> {
        d.named_element("InventoryConfiguration", Deserializer::content)
    }
}

impl Serialize for ListBucketAnalyticsConfigurationsOutput {
    fn serialize<W: Write>(&self, s: &mut Serializer<W>) -> SerResult {
        s.content_with_ns("ListBucketAnalyticsConfigurationResult", XMLNS_S3, self)
    }
}

impl<'xml> Deserialize<'xml> for ListBucketAnalyticsConfigurationsOutput {
    fn deserialize(d: &mut Deserializer<'xml>) -> DeResult<Self> {
        d.named_element("ListBucketAnalyticsConfigurationResult", Deserializer::content)
    }
}

impl Serialize for ListBucketIntelligentTieringConfigurationsOutput {
    fn serialize<W: Write>(&self, s: &mut Serializer<W>) -> SerResult {
        s.content_with_ns("ListBucketIntelligentTieringConfigurationsOutput", XMLNS_S3, self)
    }
}

impl<'xml> Deserialize<'xml> for ListBucketIntelligentTieringConfigurationsOutput {
    fn deserialize(d: &mut Deserializer<'xml>) -> DeResult<Self> {
        d.named_element("ListBucketIntelligentTieringConfigurationsOutput", Deserializer::content)
    }
}

impl Serialize for ListBucketInventoryConfigurationsOutput {
    fn serialize<W: Write>(&self, s: &mut Serializer<W>) -> SerResult {
        s.content_with_ns("ListInventoryConfigurationsResult", XMLNS_S3, self)
    }
}

impl<'xml> Deserialize<'xml> for ListBucketInventoryConfigurationsOutput {
    fn deserialize(d: &mut Deserializer<'xml>) -> DeResult<Self> {
        d.named_element("ListInventoryConfigurationsResult", Deserializer::content)
    }
}

impl Serialize for ListBucketMetricsConfigurationsOutput {
    fn serialize<W: Write>(&self, s: &mut Serializer<W>) -> SerResult {
        s.content_with_ns("ListMetricsConfigurationsResult", XMLNS_S3, self)
    }
}

impl<'xml> Deserialize<'xml> for ListBucketMetricsConfigurationsOutput {
    fn deserialize(d: &mut Deserializer<'xml>) -> DeResult<Self> {
        d.named_element("ListMetricsConfigurationsResult", Deserializer::content)
    }
}

impl Serialize for ListBucketsOutput {
    fn serialize<W: Write>(&self, s: &mut Serializer<W>) -> SerResult {
        s.content_with_ns("ListAllMyBucketsResult", XMLNS_S3, self)
    }
}

impl<'xml> Deserialize<'xml> for ListBucketsOutput {
    fn deserialize(d: &mut Deserializer<'xml>) -> DeResult<Self> {
        d.named_element("ListAllMyBucketsResult", Deserializer::content)
    }
}

impl Serialize for ListMultipartUploadsOutput {
    fn serialize<W: Write>(&self, s: &mut Serializer<W>) -> SerResult {
        s.content_with_ns("ListMultipartUploadsResult", XMLNS_S3, self)
    }
}

impl Serialize for ListObjectVersionsOutput {
    fn serialize<W: Write>(&self, s: &mut Serializer<W>) -> SerResult {
        s.content_with_ns("ListVersionsResult", XMLNS_S3, self)
    }
}

impl Serialize for ListObjectsOutput {
    fn serialize<W: Write>(&self, s: &mut Serializer<W>) -> SerResult {
        s.content_with_ns("ListBucketResult", XMLNS_S3, self)
    }
}

impl Serialize for ListObjectsV2Output {
    fn serialize<W: Write>(&self, s: &mut Serializer<W>) -> SerResult {
        s.content_with_ns("ListBucketResult", XMLNS_S3, self)
    }
}

impl Serialize for ListPartsOutput {
    fn serialize<W: Write>(&self, s: &mut Serializer<W>) -> SerResult {
        s.content_with_ns("ListPartsResult", XMLNS_S3, self)
    }
}

impl Serialize for MetadataTableConfiguration {
    fn serialize<W: Write>(&self, s: &mut Serializer<W>) -> SerResult {
        s.content("MetadataTableConfiguration", self)
    }
}

impl<'xml> Deserialize<'xml> for MetadataTableConfiguration {
    fn deserialize(d: &mut Deserializer<'xml>) -> DeResult<Self> {
        d.named_element("MetadataTableConfiguration", Deserializer::content)
    }
}

impl Serialize for MetricsConfiguration {
    fn serialize<W: Write>(&self, s: &mut Serializer<W>) -> SerResult {
        s.content("MetricsConfiguration", self)
    }
}

impl<'xml> Deserialize<'xml> for MetricsConfiguration {
    fn deserialize(d: &mut Deserializer<'xml>) -> DeResult<Self> {
        d.named_element("MetricsConfiguration", Deserializer::content)
    }
}

impl Serialize for NotificationConfiguration {
    fn serialize<W: Write>(&self, s: &mut Serializer<W>) -> SerResult {
        s.content("NotificationConfiguration", self)
    }
}

impl<'xml> Deserialize<'xml> for NotificationConfiguration {
    fn deserialize(d: &mut Deserializer<'xml>) -> DeResult<Self> {
        d.named_element("NotificationConfiguration", Deserializer::content)
    }
}

impl Serialize for ObjectLockConfiguration {
    fn serialize<W: Write>(&self, s: &mut Serializer<W>) -> SerResult {
        s.content("ObjectLockConfiguration", self)
    }
}

impl<'xml> Deserialize<'xml> for ObjectLockConfiguration {
    fn deserialize(d: &mut Deserializer<'xml>) -> DeResult<Self> {
        d.named_element("ObjectLockConfiguration", Deserializer::content)
    }
}

impl Serialize for ObjectLockLegalHold {
    fn serialize<W: Write>(&self, s: &mut Serializer<W>) -> SerResult {
        s.content("LegalHold", self)
    }
}

impl<'xml> Deserialize<'xml> for ObjectLockLegalHold {
    fn deserialize(d: &mut Deserializer<'xml>) -> DeResult<Self> {
        d.named_element("LegalHold", Deserializer::content)
    }
}

impl Serialize for ObjectLockRetention {
    fn serialize<W: Write>(&self, s: &mut Serializer<W>) -> SerResult {
        s.content("Retention", self)
    }
}

impl<'xml> Deserialize<'xml> for ObjectLockRetention {
    fn deserialize(d: &mut Deserializer<'xml>) -> DeResult<Self> {
        d.named_element("Retention", Deserializer::content)
    }
}

impl Serialize for OwnershipControls {
    fn serialize<W: Write>(&self, s: &mut Serializer<W>) -> SerResult {
        s.content("OwnershipControls", self)
    }
}

impl<'xml> Deserialize<'xml> for OwnershipControls {
    fn deserialize(d: &mut Deserializer<'xml>) -> DeResult<Self> {
        d.named_element("OwnershipControls", Deserializer::content)
    }
}

impl Serialize for PolicyStatus {
    fn serialize<W: Write>(&self, s: &mut Serializer<W>) -> SerResult {
        s.content("PolicyStatus", self)
    }
}

impl<'xml> Deserialize<'xml> for PolicyStatus {
    fn deserialize(d: &mut Deserializer<'xml>) -> DeResult<Self> {
        d.named_element("PolicyStatus", Deserializer::content)
    }
}

impl Serialize for Progress {
    fn serialize<W: Write>(&self, s: &mut Serializer<W>) -> SerResult {
        s.content("Progress", self)
    }
}

impl<'xml> Deserialize<'xml> for Progress {
    fn deserialize(d: &mut Deserializer<'xml>) -> DeResult<Self> {
        d.named_element("Progress", Deserializer::content)
    }
}

impl Serialize for PublicAccessBlockConfiguration {
    fn serialize<W: Write>(&self, s: &mut Serializer<W>) -> SerResult {
        s.content("PublicAccessBlockConfiguration", self)
    }
}

impl<'xml> Deserialize<'xml> for PublicAccessBlockConfiguration {
    fn deserialize(d: &mut Deserializer<'xml>) -> DeResult<Self> {
        d.named_element("PublicAccessBlockConfiguration", Deserializer::content)
    }
}

impl Serialize for ReplicationConfiguration {
    fn serialize<W: Write>(&self, s: &mut Serializer<W>) -> SerResult {
        s.content("ReplicationConfiguration", self)
    }
}

impl<'xml> Deserialize<'xml> for ReplicationConfiguration {
    fn deserialize(d: &mut Deserializer<'xml>) -> DeResult<Self> {
        d.named_element("ReplicationConfiguration", Deserializer::content)
    }
}

impl Serialize for RequestPaymentConfiguration {
    fn serialize<W: Write>(&self, s: &mut Serializer<W>) -> SerResult {
        s.content("RequestPaymentConfiguration", self)
    }
}

impl<'xml> Deserialize<'xml> for RequestPaymentConfiguration {
    fn deserialize(d: &mut Deserializer<'xml>) -> DeResult<Self> {
        d.named_element("RequestPaymentConfiguration", Deserializer::content)
    }
}

impl Serialize for RestoreRequest {
    fn serialize<W: Write>(&self, s: &mut Serializer<W>) -> SerResult {
        s.content("RestoreRequest", self)
    }
}

impl<'xml> Deserialize<'xml> for RestoreRequest {
    fn deserialize(d: &mut Deserializer<'xml>) -> DeResult<Self> {
        d.named_element("RestoreRequest", Deserializer::content)
    }
}

impl Serialize for SelectObjectContentRequest {
    fn serialize<W: Write>(&self, s: &mut Serializer<W>) -> SerResult {
        s.content("SelectObjectContentRequest", self)
    }
}

impl<'xml> Deserialize<'xml> for SelectObjectContentRequest {
    fn deserialize(d: &mut Deserializer<'xml>) -> DeResult<Self> {
        d.named_element("SelectObjectContentRequest", Deserializer::content)
    }
}

impl Serialize for ServerSideEncryptionConfiguration {
    fn serialize<W: Write>(&self, s: &mut Serializer<W>) -> SerResult {
        s.content("ServerSideEncryptionConfiguration", self)
    }
}

impl<'xml> Deserialize<'xml> for ServerSideEncryptionConfiguration {
    fn deserialize(d: &mut Deserializer<'xml>) -> DeResult<Self> {
        d.named_element("ServerSideEncryptionConfiguration", Deserializer::content)
    }
}

impl Serialize for Stats {
    fn serialize<W: Write>(&self, s: &mut Serializer<W>) -> SerResult {
        s.content("Stats", self)
    }
}

impl<'xml> Deserialize<'xml> for Stats {
    fn deserialize(d: &mut Deserializer<'xml>) -> DeResult<Self> {
        d.named_element("Stats", Deserializer::content)
    }
}

impl Serialize for Tagging {
    fn serialize<W: Write>(&self, s: &mut Serializer<W>) -> SerResult {
        s.content("Tagging", self)
    }
}

impl<'xml> Deserialize<'xml> for Tagging {
    fn deserialize(d: &mut Deserializer<'xml>) -> DeResult<Self> {
        d.named_element("Tagging", Deserializer::content)
    }
}

impl Serialize for VersioningConfiguration {
    fn serialize<W: Write>(&self, s: &mut Serializer<W>) -> SerResult {
        s.content("VersioningConfiguration", self)
    }
}

impl<'xml> Deserialize<'xml> for VersioningConfiguration {
    fn deserialize(d: &mut Deserializer<'xml>) -> DeResult<Self> {
        d.named_element("VersioningConfiguration", Deserializer::content)
    }
}

impl Serialize for WebsiteConfiguration {
    fn serialize<W: Write>(&self, s: &mut Serializer<W>) -> SerResult {
        s.content("WebsiteConfiguration", self)
    }
}

impl<'xml> Deserialize<'xml> for WebsiteConfiguration {
    fn deserialize(d: &mut Deserializer<'xml>) -> DeResult<Self> {
        d.named_element("WebsiteConfiguration", Deserializer::content)
    }
}

impl SerializeContent for AbortIncompleteMultipartUpload {
    fn serialize_content<W: Write>(&self, s: &mut Serializer<W>) -> SerResult {
        if let Some(ref val) = self.days_after_initiation {
            s.content("DaysAfterInitiation", val)?;
        }
        Ok(())
    }
}

impl<'xml> DeserializeContent<'xml> for AbortIncompleteMultipartUpload {
    fn deserialize_content(d: &mut Deserializer<'xml>) -> DeResult<Self> {
        let mut days_after_initiation: Option<DaysAfterInitiation> = None;
        d.for_each_element(|d, x| match x {
            b"DaysAfterInitiation" => {
                if days_after_initiation.is_some() {
                    return Err(DeError::DuplicateField);
                }
                days_after_initiation = Some(d.content()?);
                Ok(())
            }
            _ => Err(DeError::UnexpectedTagName),
        })?;
        Ok(Self { days_after_initiation })
    }
}
impl SerializeContent for AccelerateConfiguration {
    fn serialize_content<W: Write>(&self, s: &mut Serializer<W>) -> SerResult {
        if let Some(ref val) = self.status {
            s.content("Status", val)?;
        }
        Ok(())
    }
}

impl<'xml> DeserializeContent<'xml> for AccelerateConfiguration {
    fn deserialize_content(d: &mut Deserializer<'xml>) -> DeResult<Self> {
        let mut status: Option<BucketAccelerateStatus> = None;
        d.for_each_element(|d, x| match x {
            b"Status" => {
                if status.is_some() {
                    return Err(DeError::DuplicateField);
                }
                status = Some(d.content()?);
                Ok(())
            }
            _ => Err(DeError::UnexpectedTagName),
        })?;
        Ok(Self { status })
    }
}
impl SerializeContent for AccessControlPolicy {
    fn serialize_content<W: Write>(&self, s: &mut Serializer<W>) -> SerResult {
        if let Some(iter) = &self.grants {
            s.list("AccessControlList", "Grant", iter)?;
        }
        if let Some(ref val) = self.owner {
            s.content("Owner", val)?;
        }
        Ok(())
    }
}

impl<'xml> DeserializeContent<'xml> for AccessControlPolicy {
    fn deserialize_content(d: &mut Deserializer<'xml>) -> DeResult<Self> {
        let mut grants: Option<Grants> = None;
        let mut owner: Option<Owner> = None;
        d.for_each_element(|d, x| match x {
            b"AccessControlList" => {
                if grants.is_some() {
                    return Err(DeError::DuplicateField);
                }
                grants = Some(d.list_content("Grant")?);
                Ok(())
            }
            b"Owner" => {
                if owner.is_some() {
                    return Err(DeError::DuplicateField);
                }
                owner = Some(d.content()?);
                Ok(())
            }
            _ => Err(DeError::UnexpectedTagName),
        })?;
        Ok(Self { grants, owner })
    }
}
impl SerializeContent for AccessControlTranslation {
    fn serialize_content<W: Write>(&self, s: &mut Serializer<W>) -> SerResult {
        s.content("Owner", &self.owner)?;
        Ok(())
    }
}

impl<'xml> DeserializeContent<'xml> for AccessControlTranslation {
    fn deserialize_content(d: &mut Deserializer<'xml>) -> DeResult<Self> {
        let mut owner: Option<OwnerOverride> = None;
        d.for_each_element(|d, x| match x {
            b"Owner" => {
                if owner.is_some() {
                    return Err(DeError::DuplicateField);
                }
                owner = Some(d.content()?);
                Ok(())
            }
            _ => Err(DeError::UnexpectedTagName),
        })?;
        Ok(Self {
            owner: owner.ok_or(DeError::MissingField)?,
        })
    }
}
impl SerializeContent for AnalyticsAndOperator {
    fn serialize_content<W: Write>(&self, s: &mut Serializer<W>) -> SerResult {
        if let Some(ref val) = self.prefix {
            s.content("Prefix", val)?;
        }
        if let Some(iter) = &self.tags {
            s.flattened_list("Tag", iter)?;
        }
        Ok(())
    }
}

impl<'xml> DeserializeContent<'xml> for AnalyticsAndOperator {
    fn deserialize_content(d: &mut Deserializer<'xml>) -> DeResult<Self> {
        let mut prefix: Option<Prefix> = None;
        let mut tags: Option<TagSet> = None;
        d.for_each_element(|d, x| match x {
            b"Prefix" => {
                if prefix.is_some() {
                    return Err(DeError::DuplicateField);
                }
                prefix = Some(d.content()?);
                Ok(())
            }
            b"Tag" => {
                let ans: Tag = d.content()?;
                tags.get_or_insert_with(List::new).push(ans);
                Ok(())
            }
            _ => Err(DeError::UnexpectedTagName),
        })?;
        Ok(Self { prefix, tags })
    }
}
impl SerializeContent for AnalyticsConfiguration {
    fn serialize_content<W: Write>(&self, s: &mut Serializer<W>) -> SerResult {
        if let Some(ref val) = self.filter {
            s.content("Filter", val)?;
        }
        s.content("Id", &self.id)?;
        s.content("StorageClassAnalysis", &self.storage_class_analysis)?;
        Ok(())
    }
}

impl<'xml> DeserializeContent<'xml> for AnalyticsConfiguration {
    fn deserialize_content(d: &mut Deserializer<'xml>) -> DeResult<Self> {
        let mut filter: Option<AnalyticsFilter> = None;
        let mut id: Option<AnalyticsId> = None;
        let mut storage_class_analysis: Option<StorageClassAnalysis> = None;
        d.for_each_element(|d, x| match x {
            b"Filter" => {
                if filter.is_some() {
                    return Err(DeError::DuplicateField);
                }
                filter = Some(d.content()?);
                Ok(())
            }
            b"Id" => {
                if id.is_some() {
                    return Err(DeError::DuplicateField);
                }
                id = Some(d.content()?);
                Ok(())
            }
            b"StorageClassAnalysis" => {
                if storage_class_analysis.is_some() {
                    return Err(DeError::DuplicateField);
                }
                storage_class_analysis = Some(d.content()?);
                Ok(())
            }
            _ => Err(DeError::UnexpectedTagName),
        })?;
        Ok(Self {
            filter,
            id: id.ok_or(DeError::MissingField)?,
            storage_class_analysis: storage_class_analysis.ok_or(DeError::MissingField)?,
        })
    }
}
impl SerializeContent for AnalyticsExportDestination {
    fn serialize_content<W: Write>(&self, s: &mut Serializer<W>) -> SerResult {
        s.content("S3BucketDestination", &self.s3_bucket_destination)?;
        Ok(())
    }
}

impl<'xml> DeserializeContent<'xml> for AnalyticsExportDestination {
    fn deserialize_content(d: &mut Deserializer<'xml>) -> DeResult<Self> {
        let mut s3_bucket_destination: Option<AnalyticsS3BucketDestination> = None;
        d.for_each_element(|d, x| match x {
            b"S3BucketDestination" => {
                if s3_bucket_destination.is_some() {
                    return Err(DeError::DuplicateField);
                }
                s3_bucket_destination = Some(d.content()?);
                Ok(())
            }
            _ => Err(DeError::UnexpectedTagName),
        })?;
        Ok(Self {
            s3_bucket_destination: s3_bucket_destination.ok_or(DeError::MissingField)?,
        })
    }
}
impl SerializeContent for AnalyticsFilter {
    fn serialize_content<W: Write>(&self, s: &mut Serializer<W>) -> SerResult {
        match self {
            Self::And(x) => s.content("And", x),
            Self::Prefix(x) => s.content("Prefix", x),
            Self::Tag(x) => s.content("Tag", x),
        }
    }
}
impl<'xml> DeserializeContent<'xml> for AnalyticsFilter {
    fn deserialize_content(d: &mut Deserializer<'xml>) -> DeResult<Self> {
        d.element(|d, x| match x {
            b"And" => Ok(Self::And(d.content()?)),
            b"Prefix" => Ok(Self::Prefix(d.content()?)),
            b"Tag" => Ok(Self::Tag(d.content()?)),
            _ => Err(DeError::UnexpectedTagName),
        })
    }
}
impl SerializeContent for AnalyticsS3BucketDestination {
    fn serialize_content<W: Write>(&self, s: &mut Serializer<W>) -> SerResult {
        s.content("Bucket", &self.bucket)?;
        if let Some(ref val) = self.bucket_account_id {
            s.content("BucketAccountId", val)?;
        }
        s.content("Format", &self.format)?;
        if let Some(ref val) = self.prefix {
            s.content("Prefix", val)?;
        }
        Ok(())
    }
}

impl<'xml> DeserializeContent<'xml> for AnalyticsS3BucketDestination {
    fn deserialize_content(d: &mut Deserializer<'xml>) -> DeResult<Self> {
        let mut bucket: Option<BucketName> = None;
        let mut bucket_account_id: Option<AccountId> = None;
        let mut format: Option<AnalyticsS3ExportFileFormat> = None;
        let mut prefix: Option<Prefix> = None;
        d.for_each_element(|d, x| match x {
            b"Bucket" => {
                if bucket.is_some() {
                    return Err(DeError::DuplicateField);
                }
                bucket = Some(d.content()?);
                Ok(())
            }
            b"BucketAccountId" => {
                if bucket_account_id.is_some() {
                    return Err(DeError::DuplicateField);
                }
                bucket_account_id = Some(d.content()?);
                Ok(())
            }
            b"Format" => {
                if format.is_some() {
                    return Err(DeError::DuplicateField);
                }
                format = Some(d.content()?);
                Ok(())
            }
            b"Prefix" => {
                if prefix.is_some() {
                    return Err(DeError::DuplicateField);
                }
                prefix = Some(d.content()?);
                Ok(())
            }
            _ => Err(DeError::UnexpectedTagName),
        })?;
        Ok(Self {
            bucket: bucket.ok_or(DeError::MissingField)?,
            bucket_account_id,
            format: format.ok_or(DeError::MissingField)?,
            prefix,
        })
    }
}
impl SerializeContent for AnalyticsS3ExportFileFormat {
    fn serialize_content<W: Write>(&self, s: &mut Serializer<W>) -> SerResult {
        self.as_str().serialize_content(s)
    }
}
impl<'xml> DeserializeContent<'xml> for AnalyticsS3ExportFileFormat {
    fn deserialize_content(d: &mut Deserializer<'xml>) -> DeResult<Self> {
        d.text(|t| {
            let b: &[u8] = &t;
            match b {
                b"CSV" => Ok(Self::from_static(AnalyticsS3ExportFileFormat::CSV)),
                _ => Ok(Self::from(t.unescape().map_err(DeError::InvalidXml)?.into_owned())),
            }
        })
    }
}
impl SerializeContent for AssumeRoleOutput {
    fn serialize_content<W: Write>(&self, s: &mut Serializer<W>) -> SerResult {
        if let Some(ref val) = self.assumed_role_user {
            s.content("AssumedRoleUser", val)?;
        }
        if let Some(ref val) = self.credentials {
            s.content("Credentials", val)?;
        }
        if let Some(ref val) = self.packed_policy_size {
            s.content("PackedPolicySize", val)?;
        }
        if let Some(ref val) = self.source_identity {
            s.content("SourceIdentity", val)?;
        }
        Ok(())
    }
}

impl<'xml> DeserializeContent<'xml> for AssumeRoleOutput {
    fn deserialize_content(d: &mut Deserializer<'xml>) -> DeResult<Self> {
        let mut assumed_role_user: Option<AssumedRoleUser> = None;
        let mut credentials: Option<Credentials> = None;
        let mut packed_policy_size: Option<NonNegativeIntegerType> = None;
        let mut source_identity: Option<SourceIdentityType> = None;
        d.for_each_element(|d, x| match x {
            b"AssumedRoleUser" => {
                if assumed_role_user.is_some() {
                    return Err(DeError::DuplicateField);
                }
                assumed_role_user = Some(d.content()?);
                Ok(())
            }
            b"Credentials" => {
                if credentials.is_some() {
                    return Err(DeError::DuplicateField);
                }
                credentials = Some(d.content()?);
                Ok(())
            }
            b"PackedPolicySize" => {
                if packed_policy_size.is_some() {
                    return Err(DeError::DuplicateField);
                }
                packed_policy_size = Some(d.content()?);
                Ok(())
            }
            b"SourceIdentity" => {
                if source_identity.is_some() {
                    return Err(DeError::DuplicateField);
                }
                source_identity = Some(d.content()?);
                Ok(())
            }
            _ => Err(DeError::UnexpectedTagName),
        })?;
        Ok(Self {
            assumed_role_user,
            credentials,
            packed_policy_size,
            source_identity,
        })
    }
}
impl SerializeContent for AssumedRoleUser {
    fn serialize_content<W: Write>(&self, s: &mut Serializer<W>) -> SerResult {
        s.content("Arn", &self.arn)?;
        s.content("AssumedRoleId", &self.assumed_role_id)?;
        Ok(())
    }
}

impl<'xml> DeserializeContent<'xml> for AssumedRoleUser {
    fn deserialize_content(d: &mut Deserializer<'xml>) -> DeResult<Self> {
        let mut arn: Option<ArnType> = None;
        let mut assumed_role_id: Option<AssumedRoleIdType> = None;
        d.for_each_element(|d, x| match x {
            b"Arn" => {
                if arn.is_some() {
                    return Err(DeError::DuplicateField);
                }
                arn = Some(d.content()?);
                Ok(())
            }
            b"AssumedRoleId" => {
                if assumed_role_id.is_some() {
                    return Err(DeError::DuplicateField);
                }
                assumed_role_id = Some(d.content()?);
                Ok(())
            }
            _ => Err(DeError::UnexpectedTagName),
        })?;
        Ok(Self {
            arn: arn.ok_or(DeError::MissingField)?,
            assumed_role_id: assumed_role_id.ok_or(DeError::MissingField)?,
        })
    }
}
impl SerializeContent for Bucket {
    fn serialize_content<W: Write>(&self, s: &mut Serializer<W>) -> SerResult {
        if let Some(ref val) = self.bucket_region {
            s.content("BucketRegion", val)?;
        }
        if let Some(ref val) = self.creation_date {
            s.timestamp("CreationDate", val, TimestampFormat::DateTime)?;
        }
        if let Some(ref val) = self.name {
            s.content("Name", val)?;
        }
        Ok(())
    }
}

impl<'xml> DeserializeContent<'xml> for Bucket {
    fn deserialize_content(d: &mut Deserializer<'xml>) -> DeResult<Self> {
        let mut bucket_region: Option<BucketRegion> = None;
        let mut creation_date: Option<CreationDate> = None;
        let mut name: Option<BucketName> = None;
        d.for_each_element(|d, x| match x {
            b"BucketRegion" => {
                if bucket_region.is_some() {
                    return Err(DeError::DuplicateField);
                }
                bucket_region = Some(d.content()?);
                Ok(())
            }
            b"CreationDate" => {
                if creation_date.is_some() {
                    return Err(DeError::DuplicateField);
                }
                creation_date = Some(d.timestamp(TimestampFormat::DateTime)?);
                Ok(())
            }
            b"Name" => {
                if name.is_some() {
                    return Err(DeError::DuplicateField);
                }
                name = Some(d.content()?);
                Ok(())
            }
            _ => Err(DeError::UnexpectedTagName),
        })?;
        Ok(Self {
            bucket_region,
            creation_date,
            name,
        })
    }
}
impl SerializeContent for BucketAccelerateStatus {
    fn serialize_content<W: Write>(&self, s: &mut Serializer<W>) -> SerResult {
        self.as_str().serialize_content(s)
    }
}
impl<'xml> DeserializeContent<'xml> for BucketAccelerateStatus {
    fn deserialize_content(d: &mut Deserializer<'xml>) -> DeResult<Self> {
        d.text(|t| {
            let b: &[u8] = &t;
            match b {
                b"Enabled" => Ok(Self::from_static(BucketAccelerateStatus::ENABLED)),
                b"Suspended" => Ok(Self::from_static(BucketAccelerateStatus::SUSPENDED)),
                _ => Ok(Self::from(t.unescape().map_err(DeError::InvalidXml)?.into_owned())),
            }
        })
    }
}
impl SerializeContent for BucketInfo {
    fn serialize_content<W: Write>(&self, s: &mut Serializer<W>) -> SerResult {
        if let Some(ref val) = self.data_redundancy {
            s.content("DataRedundancy", val)?;
        }
        if let Some(ref val) = self.type_ {
            s.content("Type", val)?;
        }
        Ok(())
    }
}

impl<'xml> DeserializeContent<'xml> for BucketInfo {
    fn deserialize_content(d: &mut Deserializer<'xml>) -> DeResult<Self> {
        let mut data_redundancy: Option<DataRedundancy> = None;
        let mut type_: Option<BucketType> = None;
        d.for_each_element(|d, x| match x {
            b"DataRedundancy" => {
                if data_redundancy.is_some() {
                    return Err(DeError::DuplicateField);
                }
                data_redundancy = Some(d.content()?);
                Ok(())
            }
            b"Type" => {
                if type_.is_some() {
                    return Err(DeError::DuplicateField);
                }
                type_ = Some(d.content()?);
                Ok(())
            }
            _ => Err(DeError::UnexpectedTagName),
        })?;
        Ok(Self { data_redundancy, type_ })
    }
}
impl SerializeContent for BucketLifecycleConfiguration {
    fn serialize_content<W: Write>(&self, s: &mut Serializer<W>) -> SerResult {
        {
            let iter = &self.rules;
            s.flattened_list("Rule", iter)?;
        }
        Ok(())
    }
}

impl<'xml> DeserializeContent<'xml> for BucketLifecycleConfiguration {
    fn deserialize_content(d: &mut Deserializer<'xml>) -> DeResult<Self> {
        let mut rules: Option<LifecycleRules> = None;
        d.for_each_element(|d, x| match x {
            b"Rule" => {
                let ans: LifecycleRule = d.content()?;
                rules.get_or_insert_with(List::new).push(ans);
                Ok(())
            }
            _ => Err(DeError::UnexpectedTagName),
        })?;
        Ok(Self {
            rules: rules.ok_or(DeError::MissingField)?,
        })
    }
}
impl SerializeContent for BucketLocationConstraint {
    fn serialize_content<W: Write>(&self, s: &mut Serializer<W>) -> SerResult {
        self.as_str().serialize_content(s)
    }
}
impl<'xml> DeserializeContent<'xml> for BucketLocationConstraint {
    fn deserialize_content(d: &mut Deserializer<'xml>) -> DeResult<Self> {
        d.text(|t| {
            let b: &[u8] = &t;
            match b {
                b"EU" => Ok(Self::from_static(BucketLocationConstraint::EU)),
                b"af-south-1" => Ok(Self::from_static(BucketLocationConstraint::AF_SOUTH_1)),
                b"ap-east-1" => Ok(Self::from_static(BucketLocationConstraint::AP_EAST_1)),
                b"ap-northeast-1" => Ok(Self::from_static(BucketLocationConstraint::AP_NORTHEAST_1)),
                b"ap-northeast-2" => Ok(Self::from_static(BucketLocationConstraint::AP_NORTHEAST_2)),
                b"ap-northeast-3" => Ok(Self::from_static(BucketLocationConstraint::AP_NORTHEAST_3)),
                b"ap-south-1" => Ok(Self::from_static(BucketLocationConstraint::AP_SOUTH_1)),
                b"ap-south-2" => Ok(Self::from_static(BucketLocationConstraint::AP_SOUTH_2)),
                b"ap-southeast-1" => Ok(Self::from_static(BucketLocationConstraint::AP_SOUTHEAST_1)),
                b"ap-southeast-2" => Ok(Self::from_static(BucketLocationConstraint::AP_SOUTHEAST_2)),
                b"ap-southeast-3" => Ok(Self::from_static(BucketLocationConstraint::AP_SOUTHEAST_3)),
                b"ap-southeast-4" => Ok(Self::from_static(BucketLocationConstraint::AP_SOUTHEAST_4)),
                b"ap-southeast-5" => Ok(Self::from_static(BucketLocationConstraint::AP_SOUTHEAST_5)),
                b"ca-central-1" => Ok(Self::from_static(BucketLocationConstraint::CA_CENTRAL_1)),
                b"cn-north-1" => Ok(Self::from_static(BucketLocationConstraint::CN_NORTH_1)),
                b"cn-northwest-1" => Ok(Self::from_static(BucketLocationConstraint::CN_NORTHWEST_1)),
                b"eu-central-1" => Ok(Self::from_static(BucketLocationConstraint::EU_CENTRAL_1)),
                b"eu-central-2" => Ok(Self::from_static(BucketLocationConstraint::EU_CENTRAL_2)),
                b"eu-north-1" => Ok(Self::from_static(BucketLocationConstraint::EU_NORTH_1)),
                b"eu-south-1" => Ok(Self::from_static(BucketLocationConstraint::EU_SOUTH_1)),
                b"eu-south-2" => Ok(Self::from_static(BucketLocationConstraint::EU_SOUTH_2)),
                b"eu-west-1" => Ok(Self::from_static(BucketLocationConstraint::EU_WEST_1)),
                b"eu-west-2" => Ok(Self::from_static(BucketLocationConstraint::EU_WEST_2)),
                b"eu-west-3" => Ok(Self::from_static(BucketLocationConstraint::EU_WEST_3)),
                b"il-central-1" => Ok(Self::from_static(BucketLocationConstraint::IL_CENTRAL_1)),
                b"me-central-1" => Ok(Self::from_static(BucketLocationConstraint::ME_CENTRAL_1)),
                b"me-south-1" => Ok(Self::from_static(BucketLocationConstraint::ME_SOUTH_1)),
                b"sa-east-1" => Ok(Self::from_static(BucketLocationConstraint::SA_EAST_1)),
                b"us-east-2" => Ok(Self::from_static(BucketLocationConstraint::US_EAST_2)),
                b"us-gov-east-1" => Ok(Self::from_static(BucketLocationConstraint::US_GOV_EAST_1)),
                b"us-gov-west-1" => Ok(Self::from_static(BucketLocationConstraint::US_GOV_WEST_1)),
                b"us-west-1" => Ok(Self::from_static(BucketLocationConstraint::US_WEST_1)),
                b"us-west-2" => Ok(Self::from_static(BucketLocationConstraint::US_WEST_2)),
                _ => Ok(Self::from(t.unescape().map_err(DeError::InvalidXml)?.into_owned())),
            }
        })
    }
}
impl SerializeContent for BucketLoggingStatus {
    fn serialize_content<W: Write>(&self, s: &mut Serializer<W>) -> SerResult {
        if let Some(ref val) = self.logging_enabled {
            s.content("LoggingEnabled", val)?;
        }
        Ok(())
    }
}

impl<'xml> DeserializeContent<'xml> for BucketLoggingStatus {
    fn deserialize_content(d: &mut Deserializer<'xml>) -> DeResult<Self> {
        let mut logging_enabled: Option<LoggingEnabled> = None;
        d.for_each_element(|d, x| match x {
            b"LoggingEnabled" => {
                if logging_enabled.is_some() {
                    return Err(DeError::DuplicateField);
                }
                logging_enabled = Some(d.content()?);
                Ok(())
            }
            _ => Err(DeError::UnexpectedTagName),
        })?;
        Ok(Self { logging_enabled })
    }
}
impl SerializeContent for BucketLogsPermission {
    fn serialize_content<W: Write>(&self, s: &mut Serializer<W>) -> SerResult {
        self.as_str().serialize_content(s)
    }
}
impl<'xml> DeserializeContent<'xml> for BucketLogsPermission {
    fn deserialize_content(d: &mut Deserializer<'xml>) -> DeResult<Self> {
        d.text(|t| {
            let b: &[u8] = &t;
            match b {
                b"FULL_CONTROL" => Ok(Self::from_static(BucketLogsPermission::FULL_CONTROL)),
                b"READ" => Ok(Self::from_static(BucketLogsPermission::READ)),
                b"WRITE" => Ok(Self::from_static(BucketLogsPermission::WRITE)),
                _ => Ok(Self::from(t.unescape().map_err(DeError::InvalidXml)?.into_owned())),
            }
        })
    }
}
impl SerializeContent for BucketType {
    fn serialize_content<W: Write>(&self, s: &mut Serializer<W>) -> SerResult {
        self.as_str().serialize_content(s)
    }
}
impl<'xml> DeserializeContent<'xml> for BucketType {
    fn deserialize_content(d: &mut Deserializer<'xml>) -> DeResult<Self> {
        d.text(|t| {
            let b: &[u8] = &t;
            match b {
                b"Directory" => Ok(Self::from_static(BucketType::DIRECTORY)),
                _ => Ok(Self::from(t.unescape().map_err(DeError::InvalidXml)?.into_owned())),
            }
        })
    }
}
impl SerializeContent for BucketVersioningStatus {
    fn serialize_content<W: Write>(&self, s: &mut Serializer<W>) -> SerResult {
        self.as_str().serialize_content(s)
    }
}
impl<'xml> DeserializeContent<'xml> for BucketVersioningStatus {
    fn deserialize_content(d: &mut Deserializer<'xml>) -> DeResult<Self> {
        d.text(|t| {
            let b: &[u8] = &t;
            match b {
                b"Enabled" => Ok(Self::from_static(BucketVersioningStatus::ENABLED)),
                b"Suspended" => Ok(Self::from_static(BucketVersioningStatus::SUSPENDED)),
                _ => Ok(Self::from(t.unescape().map_err(DeError::InvalidXml)?.into_owned())),
            }
        })
    }
}
impl SerializeContent for CORSConfiguration {
    fn serialize_content<W: Write>(&self, s: &mut Serializer<W>) -> SerResult {
        {
            let iter = &self.cors_rules;
            s.flattened_list("CORSRule", iter)?;
        }
        Ok(())
    }
}

impl<'xml> DeserializeContent<'xml> for CORSConfiguration {
    fn deserialize_content(d: &mut Deserializer<'xml>) -> DeResult<Self> {
        let mut cors_rules: Option<CORSRules> = None;
        d.for_each_element(|d, x| match x {
            b"CORSRule" => {
                let ans: CORSRule = d.content()?;
                cors_rules.get_or_insert_with(List::new).push(ans);
                Ok(())
            }
            _ => Err(DeError::UnexpectedTagName),
        })?;
        Ok(Self {
            cors_rules: cors_rules.ok_or(DeError::MissingField)?,
        })
    }
}
impl SerializeContent for CORSRule {
    fn serialize_content<W: Write>(&self, s: &mut Serializer<W>) -> SerResult {
        if let Some(iter) = &self.allowed_headers {
            s.flattened_list("AllowedHeader", iter)?;
        }
        {
            let iter = &self.allowed_methods;
            s.flattened_list("AllowedMethod", iter)?;
        }
        {
            let iter = &self.allowed_origins;
            s.flattened_list("AllowedOrigin", iter)?;
        }
        if let Some(iter) = &self.expose_headers {
            s.flattened_list("ExposeHeader", iter)?;
        }
        if let Some(ref val) = self.id {
            s.content("ID", val)?;
        }
        if let Some(ref val) = self.max_age_seconds {
            s.content("MaxAgeSeconds", val)?;
        }
        Ok(())
    }
}

impl<'xml> DeserializeContent<'xml> for CORSRule {
    fn deserialize_content(d: &mut Deserializer<'xml>) -> DeResult<Self> {
        let mut allowed_headers: Option<AllowedHeaders> = None;
        let mut allowed_methods: Option<AllowedMethods> = None;
        let mut allowed_origins: Option<AllowedOrigins> = None;
        let mut expose_headers: Option<ExposeHeaders> = None;
        let mut id: Option<ID> = None;
        let mut max_age_seconds: Option<MaxAgeSeconds> = None;
        d.for_each_element(|d, x| match x {
            b"AllowedHeader" => {
                let ans: AllowedHeader = d.content()?;
                allowed_headers.get_or_insert_with(List::new).push(ans);
                Ok(())
            }
            b"AllowedMethod" => {
                let ans: AllowedMethod = d.content()?;
                allowed_methods.get_or_insert_with(List::new).push(ans);
                Ok(())
            }
            b"AllowedOrigin" => {
                let ans: AllowedOrigin = d.content()?;
                allowed_origins.get_or_insert_with(List::new).push(ans);
                Ok(())
            }
            b"ExposeHeader" => {
                let ans: ExposeHeader = d.content()?;
                expose_headers.get_or_insert_with(List::new).push(ans);
                Ok(())
            }
            b"ID" => {
                if id.is_some() {
                    return Err(DeError::DuplicateField);
                }
                id = Some(d.content()?);
                Ok(())
            }
            b"MaxAgeSeconds" => {
                if max_age_seconds.is_some() {
                    return Err(DeError::DuplicateField);
                }
                max_age_seconds = Some(d.content()?);
                Ok(())
            }
            _ => Err(DeError::UnexpectedTagName),
        })?;
        Ok(Self {
            allowed_headers,
            allowed_methods: allowed_methods.ok_or(DeError::MissingField)?,
            allowed_origins: allowed_origins.ok_or(DeError::MissingField)?,
            expose_headers,
            id,
            max_age_seconds,
        })
    }
}
impl SerializeContent for CSVInput {
    fn serialize_content<W: Write>(&self, s: &mut Serializer<W>) -> SerResult {
        if let Some(ref val) = self.allow_quoted_record_delimiter {
            s.content("AllowQuotedRecordDelimiter", val)?;
        }
        if let Some(ref val) = self.comments {
            s.content("Comments", val)?;
        }
        if let Some(ref val) = self.field_delimiter {
            s.content("FieldDelimiter", val)?;
        }
        if let Some(ref val) = self.file_header_info {
            s.content("FileHeaderInfo", val)?;
        }
        if let Some(ref val) = self.quote_character {
            s.content("QuoteCharacter", val)?;
        }
        if let Some(ref val) = self.quote_escape_character {
            s.content("QuoteEscapeCharacter", val)?;
        }
        if let Some(ref val) = self.record_delimiter {
            s.content("RecordDelimiter", val)?;
        }
        Ok(())
    }
}

impl<'xml> DeserializeContent<'xml> for CSVInput {
    fn deserialize_content(d: &mut Deserializer<'xml>) -> DeResult<Self> {
        let mut allow_quoted_record_delimiter: Option<AllowQuotedRecordDelimiter> = None;
        let mut comments: Option<Comments> = None;
        let mut field_delimiter: Option<FieldDelimiter> = None;
        let mut file_header_info: Option<FileHeaderInfo> = None;
        let mut quote_character: Option<QuoteCharacter> = None;
        let mut quote_escape_character: Option<QuoteEscapeCharacter> = None;
        let mut record_delimiter: Option<RecordDelimiter> = None;
        d.for_each_element(|d, x| match x {
            b"AllowQuotedRecordDelimiter" => {
                if allow_quoted_record_delimiter.is_some() {
                    return Err(DeError::DuplicateField);
                }
                allow_quoted_record_delimiter = Some(d.content()?);
                Ok(())
            }
            b"Comments" => {
                if comments.is_some() {
                    return Err(DeError::DuplicateField);
                }
                comments = Some(d.content()?);
                Ok(())
            }
            b"FieldDelimiter" => {
                if field_delimiter.is_some() {
                    return Err(DeError::DuplicateField);
                }
                field_delimiter = Some(d.content()?);
                Ok(())
            }
            b"FileHeaderInfo" => {
                if file_header_info.is_some() {
                    return Err(DeError::DuplicateField);
                }
                file_header_info = Some(d.content()?);
                Ok(())
            }
            b"QuoteCharacter" => {
                if quote_character.is_some() {
                    return Err(DeError::DuplicateField);
                }
                quote_character = Some(d.content()?);
                Ok(())
            }
            b"QuoteEscapeCharacter" => {
                if quote_escape_character.is_some() {
                    return Err(DeError::DuplicateField);
                }
                quote_escape_character = Some(d.content()?);
                Ok(())
            }
            b"RecordDelimiter" => {
                if record_delimiter.is_some() {
                    return Err(DeError::DuplicateField);
                }
                record_delimiter = Some(d.content()?);
                Ok(())
            }
            _ => Err(DeError::UnexpectedTagName),
        })?;
        Ok(Self {
            allow_quoted_record_delimiter,
            comments,
            field_delimiter,
            file_header_info,
            quote_character,
            quote_escape_character,
            record_delimiter,
        })
    }
}
impl SerializeContent for CSVOutput {
    fn serialize_content<W: Write>(&self, s: &mut Serializer<W>) -> SerResult {
        if let Some(ref val) = self.field_delimiter {
            s.content("FieldDelimiter", val)?;
        }
        if let Some(ref val) = self.quote_character {
            s.content("QuoteCharacter", val)?;
        }
        if let Some(ref val) = self.quote_escape_character {
            s.content("QuoteEscapeCharacter", val)?;
        }
        if let Some(ref val) = self.quote_fields {
            s.content("QuoteFields", val)?;
        }
        if let Some(ref val) = self.record_delimiter {
            s.content("RecordDelimiter", val)?;
        }
        Ok(())
    }
}

impl<'xml> DeserializeContent<'xml> for CSVOutput {
    fn deserialize_content(d: &mut Deserializer<'xml>) -> DeResult<Self> {
        let mut field_delimiter: Option<FieldDelimiter> = None;
        let mut quote_character: Option<QuoteCharacter> = None;
        let mut quote_escape_character: Option<QuoteEscapeCharacter> = None;
        let mut quote_fields: Option<QuoteFields> = None;
        let mut record_delimiter: Option<RecordDelimiter> = None;
        d.for_each_element(|d, x| match x {
            b"FieldDelimiter" => {
                if field_delimiter.is_some() {
                    return Err(DeError::DuplicateField);
                }
                field_delimiter = Some(d.content()?);
                Ok(())
            }
            b"QuoteCharacter" => {
                if quote_character.is_some() {
                    return Err(DeError::DuplicateField);
                }
                quote_character = Some(d.content()?);
                Ok(())
            }
            b"QuoteEscapeCharacter" => {
                if quote_escape_character.is_some() {
                    return Err(DeError::DuplicateField);
                }
                quote_escape_character = Some(d.content()?);
                Ok(())
            }
            b"QuoteFields" => {
                if quote_fields.is_some() {
                    return Err(DeError::DuplicateField);
                }
                quote_fields = Some(d.content()?);
                Ok(())
            }
            b"RecordDelimiter" => {
                if record_delimiter.is_some() {
                    return Err(DeError::DuplicateField);
                }
                record_delimiter = Some(d.content()?);
                Ok(())
            }
            _ => Err(DeError::UnexpectedTagName),
        })?;
        Ok(Self {
            field_delimiter,
            quote_character,
            quote_escape_character,
            quote_fields,
            record_delimiter,
        })
    }
}
impl SerializeContent for Checksum {
    fn serialize_content<W: Write>(&self, s: &mut Serializer<W>) -> SerResult {
        if let Some(ref val) = self.checksum_crc32 {
            s.content("ChecksumCRC32", val)?;
        }
        if let Some(ref val) = self.checksum_crc32c {
            s.content("ChecksumCRC32C", val)?;
        }
        if let Some(ref val) = self.checksum_crc64nvme {
            s.content("ChecksumCRC64NVME", val)?;
        }
        if let Some(ref val) = self.checksum_sha1 {
            s.content("ChecksumSHA1", val)?;
        }
        if let Some(ref val) = self.checksum_sha256 {
            s.content("ChecksumSHA256", val)?;
        }
        if let Some(ref val) = self.checksum_type {
            s.content("ChecksumType", val)?;
        }
        Ok(())
    }
}

impl<'xml> DeserializeContent<'xml> for Checksum {
    fn deserialize_content(d: &mut Deserializer<'xml>) -> DeResult<Self> {
        let mut checksum_crc32: Option<ChecksumCRC32> = None;
        let mut checksum_crc32c: Option<ChecksumCRC32C> = None;
        let mut checksum_crc64nvme: Option<ChecksumCRC64NVME> = None;
        let mut checksum_sha1: Option<ChecksumSHA1> = None;
        let mut checksum_sha256: Option<ChecksumSHA256> = None;
        let mut checksum_type: Option<ChecksumType> = None;
        d.for_each_element(|d, x| match x {
            b"ChecksumCRC32" => {
                if checksum_crc32.is_some() {
                    return Err(DeError::DuplicateField);
                }
                checksum_crc32 = Some(d.content()?);
                Ok(())
            }
            b"ChecksumCRC32C" => {
                if checksum_crc32c.is_some() {
                    return Err(DeError::DuplicateField);
                }
                checksum_crc32c = Some(d.content()?);
                Ok(())
            }
            b"ChecksumCRC64NVME" => {
                if checksum_crc64nvme.is_some() {
                    return Err(DeError::DuplicateField);
                }
                checksum_crc64nvme = Some(d.content()?);
                Ok(())
            }
            b"ChecksumSHA1" => {
                if checksum_sha1.is_some() {
                    return Err(DeError::DuplicateField);
                }
                checksum_sha1 = Some(d.content()?);
                Ok(())
            }
            b"ChecksumSHA256" => {
                if checksum_sha256.is_some() {
                    return Err(DeError::DuplicateField);
                }
                checksum_sha256 = Some(d.content()?);
                Ok(())
            }
            b"ChecksumType" => {
                if checksum_type.is_some() {
                    return Err(DeError::DuplicateField);
                }
                checksum_type = Some(d.content()?);
                Ok(())
            }
            _ => Err(DeError::UnexpectedTagName),
        })?;
        Ok(Self {
            checksum_crc32,
            checksum_crc32c,
            checksum_crc64nvme,
            checksum_sha1,
            checksum_sha256,
            checksum_type,
        })
    }
}
impl SerializeContent for ChecksumAlgorithm {
    fn serialize_content<W: Write>(&self, s: &mut Serializer<W>) -> SerResult {
        self.as_str().serialize_content(s)
    }
}
impl<'xml> DeserializeContent<'xml> for ChecksumAlgorithm {
    fn deserialize_content(d: &mut Deserializer<'xml>) -> DeResult<Self> {
        d.text(|t| {
            let b: &[u8] = &t;
            match b {
                b"CRC32" => Ok(Self::from_static(ChecksumAlgorithm::CRC32)),
                b"CRC32C" => Ok(Self::from_static(ChecksumAlgorithm::CRC32C)),
                b"CRC64NVME" => Ok(Self::from_static(ChecksumAlgorithm::CRC64NVME)),
                b"SHA1" => Ok(Self::from_static(ChecksumAlgorithm::SHA1)),
                b"SHA256" => Ok(Self::from_static(ChecksumAlgorithm::SHA256)),
                _ => Ok(Self::from(t.unescape().map_err(DeError::InvalidXml)?.into_owned())),
            }
        })
    }
}
impl SerializeContent for ChecksumType {
    fn serialize_content<W: Write>(&self, s: &mut Serializer<W>) -> SerResult {
        self.as_str().serialize_content(s)
    }
}
impl<'xml> DeserializeContent<'xml> for ChecksumType {
    fn deserialize_content(d: &mut Deserializer<'xml>) -> DeResult<Self> {
        d.text(|t| {
            let b: &[u8] = &t;
            match b {
                b"COMPOSITE" => Ok(Self::from_static(ChecksumType::COMPOSITE)),
                b"FULL_OBJECT" => Ok(Self::from_static(ChecksumType::FULL_OBJECT)),
                _ => Ok(Self::from(t.unescape().map_err(DeError::InvalidXml)?.into_owned())),
            }
        })
    }
}
impl SerializeContent for CommonPrefix {
    fn serialize_content<W: Write>(&self, s: &mut Serializer<W>) -> SerResult {
        if let Some(ref val) = self.prefix {
            s.content("Prefix", val)?;
        }
        Ok(())
    }
}

impl<'xml> DeserializeContent<'xml> for CommonPrefix {
    fn deserialize_content(d: &mut Deserializer<'xml>) -> DeResult<Self> {
        let mut prefix: Option<Prefix> = None;
        d.for_each_element(|d, x| match x {
            b"Prefix" => {
                if prefix.is_some() {
                    return Err(DeError::DuplicateField);
                }
                prefix = Some(d.content()?);
                Ok(())
            }
            _ => Err(DeError::UnexpectedTagName),
        })?;
        Ok(Self { prefix })
    }
}
impl SerializeContent for CompleteMultipartUploadOutput {
    fn serialize_content<W: Write>(&self, s: &mut Serializer<W>) -> SerResult {
        if let Some(ref val) = self.bucket {
            s.content("Bucket", val)?;
        }
        if let Some(ref val) = self.checksum_crc32 {
            s.content("ChecksumCRC32", val)?;
        }
        if let Some(ref val) = self.checksum_crc32c {
            s.content("ChecksumCRC32C", val)?;
        }
        if let Some(ref val) = self.checksum_crc64nvme {
            s.content("ChecksumCRC64NVME", val)?;
        }
        if let Some(ref val) = self.checksum_sha1 {
            s.content("ChecksumSHA1", val)?;
        }
        if let Some(ref val) = self.checksum_sha256 {
            s.content("ChecksumSHA256", val)?;
        }
        if let Some(ref val) = self.checksum_type {
            s.content("ChecksumType", val)?;
        }
        if let Some(ref val) = self.e_tag {
            s.content("ETag", val)?;
        }
        if let Some(ref val) = self.key {
            s.content("Key", val)?;
        }
        if let Some(ref val) = self.location {
            s.content("Location", val)?;
        }
        Ok(())
    }
}

impl SerializeContent for CompletedMultipartUpload {
    fn serialize_content<W: Write>(&self, s: &mut Serializer<W>) -> SerResult {
        if let Some(iter) = &self.parts {
            s.flattened_list("Part", iter)?;
        }
        Ok(())
    }
}

impl<'xml> DeserializeContent<'xml> for CompletedMultipartUpload {
    fn deserialize_content(d: &mut Deserializer<'xml>) -> DeResult<Self> {
        let mut parts: Option<CompletedPartList> = None;
        d.for_each_element(|d, x| match x {
            b"Part" => {
                let ans: CompletedPart = d.content()?;
                parts.get_or_insert_with(List::new).push(ans);
                Ok(())
            }
            _ => Err(DeError::UnexpectedTagName),
        })?;
        Ok(Self { parts })
    }
}
impl SerializeContent for CompletedPart {
    fn serialize_content<W: Write>(&self, s: &mut Serializer<W>) -> SerResult {
        if let Some(ref val) = self.checksum_crc32 {
            s.content("ChecksumCRC32", val)?;
        }
        if let Some(ref val) = self.checksum_crc32c {
            s.content("ChecksumCRC32C", val)?;
        }
        if let Some(ref val) = self.checksum_crc64nvme {
            s.content("ChecksumCRC64NVME", val)?;
        }
        if let Some(ref val) = self.checksum_sha1 {
            s.content("ChecksumSHA1", val)?;
        }
        if let Some(ref val) = self.checksum_sha256 {
            s.content("ChecksumSHA256", val)?;
        }
        if let Some(ref val) = self.e_tag {
            s.content("ETag", val)?;
        }
        if let Some(ref val) = self.part_number {
            s.content("PartNumber", val)?;
        }
        Ok(())
    }
}

impl<'xml> DeserializeContent<'xml> for CompletedPart {
    fn deserialize_content(d: &mut Deserializer<'xml>) -> DeResult<Self> {
        let mut checksum_crc32: Option<ChecksumCRC32> = None;
        let mut checksum_crc32c: Option<ChecksumCRC32C> = None;
        let mut checksum_crc64nvme: Option<ChecksumCRC64NVME> = None;
        let mut checksum_sha1: Option<ChecksumSHA1> = None;
        let mut checksum_sha256: Option<ChecksumSHA256> = None;
        let mut e_tag: Option<ETag> = None;
        let mut part_number: Option<PartNumber> = None;
        d.for_each_element(|d, x| match x {
            b"ChecksumCRC32" => {
                if checksum_crc32.is_some() {
                    return Err(DeError::DuplicateField);
                }
                checksum_crc32 = Some(d.content()?);
                Ok(())
            }
            b"ChecksumCRC32C" => {
                if checksum_crc32c.is_some() {
                    return Err(DeError::DuplicateField);
                }
                checksum_crc32c = Some(d.content()?);
                Ok(())
            }
            b"ChecksumCRC64NVME" => {
                if checksum_crc64nvme.is_some() {
                    return Err(DeError::DuplicateField);
                }
                checksum_crc64nvme = Some(d.content()?);
                Ok(())
            }
            b"ChecksumSHA1" => {
                if checksum_sha1.is_some() {
                    return Err(DeError::DuplicateField);
                }
                checksum_sha1 = Some(d.content()?);
                Ok(())
            }
            b"ChecksumSHA256" => {
                if checksum_sha256.is_some() {
                    return Err(DeError::DuplicateField);
                }
                checksum_sha256 = Some(d.content()?);
                Ok(())
            }
            b"ETag" => {
                if e_tag.is_some() {
                    return Err(DeError::DuplicateField);
                }
                e_tag = Some(d.content()?);
                Ok(())
            }
            b"PartNumber" => {
                if part_number.is_some() {
                    return Err(DeError::DuplicateField);
                }
                part_number = Some(d.content()?);
                Ok(())
            }
            _ => Err(DeError::UnexpectedTagName),
        })?;
        Ok(Self {
            checksum_crc32,
            checksum_crc32c,
            checksum_crc64nvme,
            checksum_sha1,
            checksum_sha256,
            e_tag,
            part_number,
        })
    }
}
impl SerializeContent for CompressionType {
    fn serialize_content<W: Write>(&self, s: &mut Serializer<W>) -> SerResult {
        self.as_str().serialize_content(s)
    }
}
impl<'xml> DeserializeContent<'xml> for CompressionType {
    fn deserialize_content(d: &mut Deserializer<'xml>) -> DeResult<Self> {
        d.text(|t| {
            let b: &[u8] = &t;
            match b {
                b"BZIP2" => Ok(Self::from_static(CompressionType::BZIP2)),
                b"GZIP" => Ok(Self::from_static(CompressionType::GZIP)),
                b"NONE" => Ok(Self::from_static(CompressionType::NONE)),
                _ => Ok(Self::from(t.unescape().map_err(DeError::InvalidXml)?.into_owned())),
            }
        })
    }
}
impl SerializeContent for Condition {
    fn serialize_content<W: Write>(&self, s: &mut Serializer<W>) -> SerResult {
        if let Some(ref val) = self.http_error_code_returned_equals {
            s.content("HttpErrorCodeReturnedEquals", val)?;
        }
        if let Some(ref val) = self.key_prefix_equals {
            s.content("KeyPrefixEquals", val)?;
        }
        Ok(())
    }
}

impl<'xml> DeserializeContent<'xml> for Condition {
    fn deserialize_content(d: &mut Deserializer<'xml>) -> DeResult<Self> {
        let mut http_error_code_returned_equals: Option<HttpErrorCodeReturnedEquals> = None;
        let mut key_prefix_equals: Option<KeyPrefixEquals> = None;
        d.for_each_element(|d, x| match x {
            b"HttpErrorCodeReturnedEquals" => {
                if http_error_code_returned_equals.is_some() {
                    return Err(DeError::DuplicateField);
                }
                http_error_code_returned_equals = Some(d.content()?);
                Ok(())
            }
            b"KeyPrefixEquals" => {
                if key_prefix_equals.is_some() {
                    return Err(DeError::DuplicateField);
                }
                key_prefix_equals = Some(d.content()?);
                Ok(())
            }
            _ => Err(DeError::UnexpectedTagName),
        })?;
        Ok(Self {
            http_error_code_returned_equals,
            key_prefix_equals,
        })
    }
}
impl SerializeContent for CopyObjectResult {
    fn serialize_content<W: Write>(&self, s: &mut Serializer<W>) -> SerResult {
        if let Some(ref val) = self.checksum_crc32 {
            s.content("ChecksumCRC32", val)?;
        }
        if let Some(ref val) = self.checksum_crc32c {
            s.content("ChecksumCRC32C", val)?;
        }
        if let Some(ref val) = self.checksum_crc64nvme {
            s.content("ChecksumCRC64NVME", val)?;
        }
        if let Some(ref val) = self.checksum_sha1 {
            s.content("ChecksumSHA1", val)?;
        }
        if let Some(ref val) = self.checksum_sha256 {
            s.content("ChecksumSHA256", val)?;
        }
        if let Some(ref val) = self.checksum_type {
            s.content("ChecksumType", val)?;
        }
        if let Some(ref val) = self.e_tag {
            s.content("ETag", val)?;
        }
        if let Some(ref val) = self.last_modified {
            s.timestamp("LastModified", val, TimestampFormat::DateTime)?;
        }
        Ok(())
    }
}

impl<'xml> DeserializeContent<'xml> for CopyObjectResult {
    fn deserialize_content(d: &mut Deserializer<'xml>) -> DeResult<Self> {
        let mut checksum_crc32: Option<ChecksumCRC32> = None;
        let mut checksum_crc32c: Option<ChecksumCRC32C> = None;
        let mut checksum_crc64nvme: Option<ChecksumCRC64NVME> = None;
        let mut checksum_sha1: Option<ChecksumSHA1> = None;
        let mut checksum_sha256: Option<ChecksumSHA256> = None;
        let mut checksum_type: Option<ChecksumType> = None;
        let mut e_tag: Option<ETag> = None;
        let mut last_modified: Option<LastModified> = None;
        d.for_each_element(|d, x| match x {
            b"ChecksumCRC32" => {
                if checksum_crc32.is_some() {
                    return Err(DeError::DuplicateField);
                }
                checksum_crc32 = Some(d.content()?);
                Ok(())
            }
            b"ChecksumCRC32C" => {
                if checksum_crc32c.is_some() {
                    return Err(DeError::DuplicateField);
                }
                checksum_crc32c = Some(d.content()?);
                Ok(())
            }
            b"ChecksumCRC64NVME" => {
                if checksum_crc64nvme.is_some() {
                    return Err(DeError::DuplicateField);
                }
                checksum_crc64nvme = Some(d.content()?);
                Ok(())
            }
            b"ChecksumSHA1" => {
                if checksum_sha1.is_some() {
                    return Err(DeError::DuplicateField);
                }
                checksum_sha1 = Some(d.content()?);
                Ok(())
            }
            b"ChecksumSHA256" => {
                if checksum_sha256.is_some() {
                    return Err(DeError::DuplicateField);
                }
                checksum_sha256 = Some(d.content()?);
                Ok(())
            }
            b"ChecksumType" => {
                if checksum_type.is_some() {
                    return Err(DeError::DuplicateField);
                }
                checksum_type = Some(d.content()?);
                Ok(())
            }
            b"ETag" => {
                if e_tag.is_some() {
                    return Err(DeError::DuplicateField);
                }
                e_tag = Some(d.content()?);
                Ok(())
            }
            b"LastModified" => {
                if last_modified.is_some() {
                    return Err(DeError::DuplicateField);
                }
                last_modified = Some(d.timestamp(TimestampFormat::DateTime)?);
                Ok(())
            }
            _ => Err(DeError::UnexpectedTagName),
        })?;
        Ok(Self {
            checksum_crc32,
            checksum_crc32c,
            checksum_crc64nvme,
            checksum_sha1,
            checksum_sha256,
            checksum_type,
            e_tag,
            last_modified,
        })
    }
}
impl SerializeContent for CopyPartResult {
    fn serialize_content<W: Write>(&self, s: &mut Serializer<W>) -> SerResult {
        if let Some(ref val) = self.checksum_crc32 {
            s.content("ChecksumCRC32", val)?;
        }
        if let Some(ref val) = self.checksum_crc32c {
            s.content("ChecksumCRC32C", val)?;
        }
        if let Some(ref val) = self.checksum_crc64nvme {
            s.content("ChecksumCRC64NVME", val)?;
        }
        if let Some(ref val) = self.checksum_sha1 {
            s.content("ChecksumSHA1", val)?;
        }
        if let Some(ref val) = self.checksum_sha256 {
            s.content("ChecksumSHA256", val)?;
        }
        if let Some(ref val) = self.e_tag {
            s.content("ETag", val)?;
        }
        if let Some(ref val) = self.last_modified {
            s.timestamp("LastModified", val, TimestampFormat::DateTime)?;
        }
        Ok(())
    }
}

impl<'xml> DeserializeContent<'xml> for CopyPartResult {
    fn deserialize_content(d: &mut Deserializer<'xml>) -> DeResult<Self> {
        let mut checksum_crc32: Option<ChecksumCRC32> = None;
        let mut checksum_crc32c: Option<ChecksumCRC32C> = None;
        let mut checksum_crc64nvme: Option<ChecksumCRC64NVME> = None;
        let mut checksum_sha1: Option<ChecksumSHA1> = None;
        let mut checksum_sha256: Option<ChecksumSHA256> = None;
        let mut e_tag: Option<ETag> = None;
        let mut last_modified: Option<LastModified> = None;
        d.for_each_element(|d, x| match x {
            b"ChecksumCRC32" => {
                if checksum_crc32.is_some() {
                    return Err(DeError::DuplicateField);
                }
                checksum_crc32 = Some(d.content()?);
                Ok(())
            }
            b"ChecksumCRC32C" => {
                if checksum_crc32c.is_some() {
                    return Err(DeError::DuplicateField);
                }
                checksum_crc32c = Some(d.content()?);
                Ok(())
            }
            b"ChecksumCRC64NVME" => {
                if checksum_crc64nvme.is_some() {
                    return Err(DeError::DuplicateField);
                }
                checksum_crc64nvme = Some(d.content()?);
                Ok(())
            }
            b"ChecksumSHA1" => {
                if checksum_sha1.is_some() {
                    return Err(DeError::DuplicateField);
                }
                checksum_sha1 = Some(d.content()?);
                Ok(())
            }
            b"ChecksumSHA256" => {
                if checksum_sha256.is_some() {
                    return Err(DeError::DuplicateField);
                }
                checksum_sha256 = Some(d.content()?);
                Ok(())
            }
            b"ETag" => {
                if e_tag.is_some() {
                    return Err(DeError::DuplicateField);
                }
                e_tag = Some(d.content()?);
                Ok(())
            }
            b"LastModified" => {
                if last_modified.is_some() {
                    return Err(DeError::DuplicateField);
                }
                last_modified = Some(d.timestamp(TimestampFormat::DateTime)?);
                Ok(())
            }
            _ => Err(DeError::UnexpectedTagName),
        })?;
        Ok(Self {
            checksum_crc32,
            checksum_crc32c,
            checksum_crc64nvme,
            checksum_sha1,
            checksum_sha256,
            e_tag,
            last_modified,
        })
    }
}
impl SerializeContent for CreateBucketConfiguration {
    fn serialize_content<W: Write>(&self, s: &mut Serializer<W>) -> SerResult {
        if let Some(ref val) = self.bucket {
            s.content("Bucket", val)?;
        }
        if let Some(ref val) = self.location {
            s.content("Location", val)?;
        }
        if let Some(ref val) = self.location_constraint {
            s.content("LocationConstraint", val)?;
        }
        Ok(())
    }
}

impl<'xml> DeserializeContent<'xml> for CreateBucketConfiguration {
    fn deserialize_content(d: &mut Deserializer<'xml>) -> DeResult<Self> {
        let mut bucket: Option<BucketInfo> = None;
        let mut location: Option<LocationInfo> = None;
        let mut location_constraint: Option<BucketLocationConstraint> = None;
        d.for_each_element(|d, x| match x {
            b"Bucket" => {
                if bucket.is_some() {
                    return Err(DeError::DuplicateField);
                }
                bucket = Some(d.content()?);
                Ok(())
            }
            b"Location" => {
                if location.is_some() {
                    return Err(DeError::DuplicateField);
                }
                location = Some(d.content()?);
                Ok(())
            }
            b"LocationConstraint" => {
                if location_constraint.is_some() {
                    return Err(DeError::DuplicateField);
                }
                location_constraint = Some(d.content()?);
                Ok(())
            }
            _ => Err(DeError::UnexpectedTagName),
        })?;
        Ok(Self {
            bucket,
            location,
            location_constraint,
        })
    }
}
impl SerializeContent for CreateMultipartUploadOutput {
    fn serialize_content<W: Write>(&self, s: &mut Serializer<W>) -> SerResult {
        if let Some(ref val) = self.bucket {
            s.content("Bucket", val)?;
        }
        if let Some(ref val) = self.key {
            s.content("Key", val)?;
        }
        if let Some(ref val) = self.upload_id {
            s.content("UploadId", val)?;
        }
        Ok(())
    }
}

impl SerializeContent for Credentials {
    fn serialize_content<W: Write>(&self, s: &mut Serializer<W>) -> SerResult {
        s.content("AccessKeyId", &self.access_key_id)?;
        s.timestamp("Expiration", &self.expiration, TimestampFormat::DateTime)?;
        s.content("SecretAccessKey", &self.secret_access_key)?;
        s.content("SessionToken", &self.session_token)?;
        Ok(())
    }
}

impl<'xml> DeserializeContent<'xml> for Credentials {
    fn deserialize_content(d: &mut Deserializer<'xml>) -> DeResult<Self> {
        let mut access_key_id: Option<AccessKeyIdType> = None;
        let mut expiration: Option<DateType> = None;
        let mut secret_access_key: Option<AccessKeySecretType> = None;
        let mut session_token: Option<TokenType> = None;
        d.for_each_element(|d, x| match x {
            b"AccessKeyId" => {
                if access_key_id.is_some() {
                    return Err(DeError::DuplicateField);
                }
                access_key_id = Some(d.content()?);
                Ok(())
            }
            b"Expiration" => {
                if expiration.is_some() {
                    return Err(DeError::DuplicateField);
                }
                expiration = Some(d.timestamp(TimestampFormat::DateTime)?);
                Ok(())
            }
            b"SecretAccessKey" => {
                if secret_access_key.is_some() {
                    return Err(DeError::DuplicateField);
                }
                secret_access_key = Some(d.content()?);
                Ok(())
            }
            b"SessionToken" => {
                if session_token.is_some() {
                    return Err(DeError::DuplicateField);
                }
                session_token = Some(d.content()?);
                Ok(())
            }
            _ => Err(DeError::UnexpectedTagName),
        })?;
        Ok(Self {
            access_key_id: access_key_id.ok_or(DeError::MissingField)?,
            expiration: expiration.ok_or(DeError::MissingField)?,
            secret_access_key: secret_access_key.ok_or(DeError::MissingField)?,
            session_token: session_token.ok_or(DeError::MissingField)?,
        })
    }
}
impl SerializeContent for DataRedundancy {
    fn serialize_content<W: Write>(&self, s: &mut Serializer<W>) -> SerResult {
        self.as_str().serialize_content(s)
    }
}
impl<'xml> DeserializeContent<'xml> for DataRedundancy {
    fn deserialize_content(d: &mut Deserializer<'xml>) -> DeResult<Self> {
        d.text(|t| {
            let b: &[u8] = &t;
            match b {
                b"SingleAvailabilityZone" => Ok(Self::from_static(DataRedundancy::SINGLE_AVAILABILITY_ZONE)),
                b"SingleLocalZone" => Ok(Self::from_static(DataRedundancy::SINGLE_LOCAL_ZONE)),
                _ => Ok(Self::from(t.unescape().map_err(DeError::InvalidXml)?.into_owned())),
            }
        })
    }
}
impl SerializeContent for DefaultRetention {
    fn serialize_content<W: Write>(&self, s: &mut Serializer<W>) -> SerResult {
        if let Some(ref val) = self.days {
            s.content("Days", val)?;
        }
        if let Some(ref val) = self.mode {
            s.content("Mode", val)?;
        }
        if let Some(ref val) = self.years {
            s.content("Years", val)?;
        }
        Ok(())
    }
}

impl<'xml> DeserializeContent<'xml> for DefaultRetention {
    fn deserialize_content(d: &mut Deserializer<'xml>) -> DeResult<Self> {
        let mut days: Option<Days> = None;
        let mut mode: Option<ObjectLockRetentionMode> = None;
        let mut years: Option<Years> = None;
        d.for_each_element(|d, x| match x {
            b"Days" => {
                if days.is_some() {
                    return Err(DeError::DuplicateField);
                }
                days = Some(d.content()?);
                Ok(())
            }
            b"Mode" => {
                if mode.is_some() {
                    return Err(DeError::DuplicateField);
                }
                mode = Some(d.content()?);
                Ok(())
            }
            b"Years" => {
                if years.is_some() {
                    return Err(DeError::DuplicateField);
                }
                years = Some(d.content()?);
                Ok(())
            }
            _ => Err(DeError::UnexpectedTagName),
        })?;
        Ok(Self { days, mode, years })
    }
}
impl SerializeContent for Delete {
    fn serialize_content<W: Write>(&self, s: &mut Serializer<W>) -> SerResult {
        {
            let iter = &self.objects;
            s.flattened_list("Object", iter)?;
        }
        if let Some(ref val) = self.quiet {
            s.content("Quiet", val)?;
        }
        Ok(())
    }
}

impl<'xml> DeserializeContent<'xml> for Delete {
    fn deserialize_content(d: &mut Deserializer<'xml>) -> DeResult<Self> {
        let mut objects: Option<ObjectIdentifierList> = None;
        let mut quiet: Option<Quiet> = None;
        d.for_each_element(|d, x| match x {
            b"Object" => {
                let ans: ObjectIdentifier = d.content()?;
                objects.get_or_insert_with(List::new).push(ans);
                Ok(())
            }
            b"Quiet" => {
                if quiet.is_some() {
                    return Err(DeError::DuplicateField);
                }
                quiet = Some(d.content()?);
                Ok(())
            }
            _ => Err(DeError::UnexpectedTagName),
        })?;
        Ok(Self {
            objects: objects.ok_or(DeError::MissingField)?,
            quiet,
        })
    }
}
impl SerializeContent for DeleteMarkerEntry {
    fn serialize_content<W: Write>(&self, s: &mut Serializer<W>) -> SerResult {
        if let Some(ref val) = self.is_latest {
            s.content("IsLatest", val)?;
        }
        if let Some(ref val) = self.key {
            s.content("Key", val)?;
        }
        if let Some(ref val) = self.last_modified {
            s.timestamp("LastModified", val, TimestampFormat::DateTime)?;
        }
        if let Some(ref val) = self.owner {
            s.content("Owner", val)?;
        }
        if let Some(ref val) = self.version_id {
            s.content("VersionId", val)?;
        }
        Ok(())
    }
}

impl<'xml> DeserializeContent<'xml> for DeleteMarkerEntry {
    fn deserialize_content(d: &mut Deserializer<'xml>) -> DeResult<Self> {
        let mut is_latest: Option<IsLatest> = None;
        let mut key: Option<ObjectKey> = None;
        let mut last_modified: Option<LastModified> = None;
        let mut owner: Option<Owner> = None;
        let mut version_id: Option<ObjectVersionId> = None;
        d.for_each_element(|d, x| match x {
            b"IsLatest" => {
                if is_latest.is_some() {
                    return Err(DeError::DuplicateField);
                }
                is_latest = Some(d.content()?);
                Ok(())
            }
            b"Key" => {
                if key.is_some() {
                    return Err(DeError::DuplicateField);
                }
                key = Some(d.content()?);
                Ok(())
            }
            b"LastModified" => {
                if last_modified.is_some() {
                    return Err(DeError::DuplicateField);
                }
                last_modified = Some(d.timestamp(TimestampFormat::DateTime)?);
                Ok(())
            }
            b"Owner" => {
                if owner.is_some() {
                    return Err(DeError::DuplicateField);
                }
                owner = Some(d.content()?);
                Ok(())
            }
            b"VersionId" => {
                if version_id.is_some() {
                    return Err(DeError::DuplicateField);
                }
                version_id = Some(d.content()?);
                Ok(())
            }
            _ => Err(DeError::UnexpectedTagName),
        })?;
        Ok(Self {
            is_latest,
            key,
            last_modified,
            owner,
            version_id,
        })
    }
}
impl SerializeContent for DeleteMarkerReplication {
    fn serialize_content<W: Write>(&self, s: &mut Serializer<W>) -> SerResult {
        if let Some(ref val) = self.status {
            s.content("Status", val)?;
        }
        Ok(())
    }
}

impl<'xml> DeserializeContent<'xml> for DeleteMarkerReplication {
    fn deserialize_content(d: &mut Deserializer<'xml>) -> DeResult<Self> {
        let mut status: Option<DeleteMarkerReplicationStatus> = None;
        d.for_each_element(|d, x| match x {
            b"Status" => {
                if status.is_some() {
                    return Err(DeError::DuplicateField);
                }
                status = Some(d.content()?);
                Ok(())
            }
            _ => Err(DeError::UnexpectedTagName),
        })?;
        Ok(Self { status })
    }
}
impl SerializeContent for DeleteMarkerReplicationStatus {
    fn serialize_content<W: Write>(&self, s: &mut Serializer<W>) -> SerResult {
        self.as_str().serialize_content(s)
    }
}
impl<'xml> DeserializeContent<'xml> for DeleteMarkerReplicationStatus {
    fn deserialize_content(d: &mut Deserializer<'xml>) -> DeResult<Self> {
        d.text(|t| {
            let b: &[u8] = &t;
            match b {
                b"Disabled" => Ok(Self::from_static(DeleteMarkerReplicationStatus::DISABLED)),
                b"Enabled" => Ok(Self::from_static(DeleteMarkerReplicationStatus::ENABLED)),
                _ => Ok(Self::from(t.unescape().map_err(DeError::InvalidXml)?.into_owned())),
            }
        })
    }
}
impl SerializeContent for DeleteObjectsOutput {
    fn serialize_content<W: Write>(&self, s: &mut Serializer<W>) -> SerResult {
        if let Some(iter) = &self.deleted {
            s.flattened_list("Deleted", iter)?;
        }
        if let Some(iter) = &self.errors {
            s.flattened_list("Error", iter)?;
        }
        Ok(())
    }
}

impl SerializeContent for DeleteReplication {
    fn serialize_content<W: Write>(&self, s: &mut Serializer<W>) -> SerResult {
        s.content("Status", &self.status)?;
        Ok(())
    }
}

impl<'xml> DeserializeContent<'xml> for DeleteReplication {
    fn deserialize_content(d: &mut Deserializer<'xml>) -> DeResult<Self> {
        let mut status: Option<DeleteReplicationStatus> = None;
        d.for_each_element(|d, x| match x {
            b"Status" => {
                if status.is_some() {
                    return Err(DeError::DuplicateField);
                }
                status = Some(d.content()?);
                Ok(())
            }
            _ => Err(DeError::UnexpectedTagName),
        })?;
        Ok(Self {
            status: status.ok_or(DeError::MissingField)?,
        })
    }
}
impl SerializeContent for DeleteReplicationStatus {
    fn serialize_content<W: Write>(&self, s: &mut Serializer<W>) -> SerResult {
        self.as_str().serialize_content(s)
    }
}
impl<'xml> DeserializeContent<'xml> for DeleteReplicationStatus {
    fn deserialize_content(d: &mut Deserializer<'xml>) -> DeResult<Self> {
        d.text(|t| {
            let b: &[u8] = &t;
            match b {
                b"Disabled" => Ok(Self::from_static(DeleteReplicationStatus::DISABLED)),
                b"Enabled" => Ok(Self::from_static(DeleteReplicationStatus::ENABLED)),
                _ => Ok(Self::from(t.unescape().map_err(DeError::InvalidXml)?.into_owned())),
            }
        })
    }
}
impl SerializeContent for DeletedObject {
    fn serialize_content<W: Write>(&self, s: &mut Serializer<W>) -> SerResult {
        if let Some(ref val) = self.delete_marker {
            s.content("DeleteMarker", val)?;
        }
        if let Some(ref val) = self.delete_marker_version_id {
            s.content("DeleteMarkerVersionId", val)?;
        }
        if let Some(ref val) = self.key {
            s.content("Key", val)?;
        }
        if let Some(ref val) = self.version_id {
            s.content("VersionId", val)?;
        }
        Ok(())
    }
}

impl<'xml> DeserializeContent<'xml> for DeletedObject {
    fn deserialize_content(d: &mut Deserializer<'xml>) -> DeResult<Self> {
        let mut delete_marker: Option<DeleteMarker> = None;
        let mut delete_marker_version_id: Option<DeleteMarkerVersionId> = None;
        let mut key: Option<ObjectKey> = None;
        let mut version_id: Option<ObjectVersionId> = None;
        d.for_each_element(|d, x| match x {
            b"DeleteMarker" => {
                if delete_marker.is_some() {
                    return Err(DeError::DuplicateField);
                }
                delete_marker = Some(d.content()?);
                Ok(())
            }
            b"DeleteMarkerVersionId" => {
                if delete_marker_version_id.is_some() {
                    return Err(DeError::DuplicateField);
                }
                delete_marker_version_id = Some(d.content()?);
                Ok(())
            }
            b"Key" => {
                if key.is_some() {
                    return Err(DeError::DuplicateField);
                }
                key = Some(d.content()?);
                Ok(())
            }
            b"VersionId" => {
                if version_id.is_some() {
                    return Err(DeError::DuplicateField);
                }
                version_id = Some(d.content()?);
                Ok(())
            }
            _ => Err(DeError::UnexpectedTagName),
        })?;
        Ok(Self {
            delete_marker,
            delete_marker_version_id,
            key,
            version_id,
        })
    }
}
impl SerializeContent for Destination {
    fn serialize_content<W: Write>(&self, s: &mut Serializer<W>) -> SerResult {
        if let Some(ref val) = self.access_control_translation {
            s.content("AccessControlTranslation", val)?;
        }
        if let Some(ref val) = self.account {
            s.content("Account", val)?;
        }
        s.content("Bucket", &self.bucket)?;
        if let Some(ref val) = self.encryption_configuration {
            s.content("EncryptionConfiguration", val)?;
        }
        if let Some(ref val) = self.metrics {
            s.content("Metrics", val)?;
        }
        if let Some(ref val) = self.replication_time {
            s.content("ReplicationTime", val)?;
        }
        if let Some(ref val) = self.storage_class {
            s.content("StorageClass", val)?;
        }
        Ok(())
    }
}

impl<'xml> DeserializeContent<'xml> for Destination {
    fn deserialize_content(d: &mut Deserializer<'xml>) -> DeResult<Self> {
        let mut access_control_translation: Option<AccessControlTranslation> = None;
        let mut account: Option<AccountId> = None;
        let mut bucket: Option<BucketName> = None;
        let mut encryption_configuration: Option<EncryptionConfiguration> = None;
        let mut metrics: Option<Metrics> = None;
        let mut replication_time: Option<ReplicationTime> = None;
        let mut storage_class: Option<StorageClass> = None;
        d.for_each_element(|d, x| match x {
            b"AccessControlTranslation" => {
                if access_control_translation.is_some() {
                    return Err(DeError::DuplicateField);
                }
                access_control_translation = Some(d.content()?);
                Ok(())
            }
            b"Account" => {
                if account.is_some() {
                    return Err(DeError::DuplicateField);
                }
                account = Some(d.content()?);
                Ok(())
            }
            b"Bucket" => {
                if bucket.is_some() {
                    return Err(DeError::DuplicateField);
                }
                bucket = Some(d.content()?);
                Ok(())
            }
            b"EncryptionConfiguration" => {
                if encryption_configuration.is_some() {
                    return Err(DeError::DuplicateField);
                }
                encryption_configuration = Some(d.content()?);
                Ok(())
            }
            b"Metrics" => {
                if metrics.is_some() {
                    return Err(DeError::DuplicateField);
                }
                metrics = Some(d.content()?);
                Ok(())
            }
            b"ReplicationTime" => {
                if replication_time.is_some() {
                    return Err(DeError::DuplicateField);
                }
                replication_time = Some(d.content()?);
                Ok(())
            }
            b"StorageClass" => {
                if storage_class.is_some() {
                    return Err(DeError::DuplicateField);
                }
                storage_class = Some(d.content()?);
                Ok(())
            }
            _ => Err(DeError::UnexpectedTagName),
        })?;
        Ok(Self {
            access_control_translation,
            account,
            bucket: bucket.ok_or(DeError::MissingField)?,
            encryption_configuration,
            metrics,
            replication_time,
            storage_class,
        })
    }
}
impl SerializeContent for EncodingType {
    fn serialize_content<W: Write>(&self, s: &mut Serializer<W>) -> SerResult {
        self.as_str().serialize_content(s)
    }
}
impl<'xml> DeserializeContent<'xml> for EncodingType {
    fn deserialize_content(d: &mut Deserializer<'xml>) -> DeResult<Self> {
        d.text(|t| {
            let b: &[u8] = &t;
            match b {
                b"url" => Ok(Self::from_static(EncodingType::URL)),
                _ => Ok(Self::from(t.unescape().map_err(DeError::InvalidXml)?.into_owned())),
            }
        })
    }
}
impl SerializeContent for Encryption {
    fn serialize_content<W: Write>(&self, s: &mut Serializer<W>) -> SerResult {
        s.content("EncryptionType", &self.encryption_type)?;
        if let Some(ref val) = self.kms_context {
            s.content("KMSContext", val)?;
        }
        if let Some(ref val) = self.kms_key_id {
            s.content("KMSKeyId", val)?;
        }
        Ok(())
    }
}

impl<'xml> DeserializeContent<'xml> for Encryption {
    fn deserialize_content(d: &mut Deserializer<'xml>) -> DeResult<Self> {
        let mut encryption_type: Option<ServerSideEncryption> = None;
        let mut kms_context: Option<KMSContext> = None;
        let mut kms_key_id: Option<SSEKMSKeyId> = None;
        d.for_each_element(|d, x| match x {
            b"EncryptionType" => {
                if encryption_type.is_some() {
                    return Err(DeError::DuplicateField);
                }
                encryption_type = Some(d.content()?);
                Ok(())
            }
            b"KMSContext" => {
                if kms_context.is_some() {
                    return Err(DeError::DuplicateField);
                }
                kms_context = Some(d.content()?);
                Ok(())
            }
            b"KMSKeyId" => {
                if kms_key_id.is_some() {
                    return Err(DeError::DuplicateField);
                }
                kms_key_id = Some(d.content()?);
                Ok(())
            }
            _ => Err(DeError::UnexpectedTagName),
        })?;
        Ok(Self {
            encryption_type: encryption_type.ok_or(DeError::MissingField)?,
            kms_context,
            kms_key_id,
        })
    }
}
impl SerializeContent for EncryptionConfiguration {
    fn serialize_content<W: Write>(&self, s: &mut Serializer<W>) -> SerResult {
        if let Some(ref val) = self.replica_kms_key_id {
            s.content("ReplicaKmsKeyID", val)?;
        }
        Ok(())
    }
}

impl<'xml> DeserializeContent<'xml> for EncryptionConfiguration {
    fn deserialize_content(d: &mut Deserializer<'xml>) -> DeResult<Self> {
        let mut replica_kms_key_id: Option<ReplicaKmsKeyID> = None;
        d.for_each_element(|d, x| match x {
            b"ReplicaKmsKeyID" => {
                if replica_kms_key_id.is_some() {
                    return Err(DeError::DuplicateField);
                }
                replica_kms_key_id = Some(d.content()?);
                Ok(())
            }
            _ => Err(DeError::UnexpectedTagName),
        })?;
        Ok(Self { replica_kms_key_id })
    }
}
impl SerializeContent for Error {
    fn serialize_content<W: Write>(&self, s: &mut Serializer<W>) -> SerResult {
        if let Some(ref val) = self.code {
            s.content("Code", val)?;
        }
        if let Some(ref val) = self.key {
            s.content("Key", val)?;
        }
        if let Some(ref val) = self.message {
            s.content("Message", val)?;
        }
        if let Some(ref val) = self.version_id {
            s.content("VersionId", val)?;
        }
        Ok(())
    }
}

impl<'xml> DeserializeContent<'xml> for Error {
    fn deserialize_content(d: &mut Deserializer<'xml>) -> DeResult<Self> {
        let mut code: Option<Code> = None;
        let mut key: Option<ObjectKey> = None;
        let mut message: Option<Message> = None;
        let mut version_id: Option<ObjectVersionId> = None;
        d.for_each_element(|d, x| match x {
            b"Code" => {
                if code.is_some() {
                    return Err(DeError::DuplicateField);
                }
                code = Some(d.content()?);
                Ok(())
            }
            b"Key" => {
                if key.is_some() {
                    return Err(DeError::DuplicateField);
                }
                key = Some(d.content()?);
                Ok(())
            }
            b"Message" => {
                if message.is_some() {
                    return Err(DeError::DuplicateField);
                }
                message = Some(d.content()?);
                Ok(())
            }
            b"VersionId" => {
                if version_id.is_some() {
                    return Err(DeError::DuplicateField);
                }
                version_id = Some(d.content()?);
                Ok(())
            }
            _ => Err(DeError::UnexpectedTagName),
        })?;
        Ok(Self {
            code,
            key,
            message,
            version_id,
        })
    }
}
impl SerializeContent for ErrorDetails {
    fn serialize_content<W: Write>(&self, s: &mut Serializer<W>) -> SerResult {
        if let Some(ref val) = self.error_code {
            s.content("ErrorCode", val)?;
        }
        if let Some(ref val) = self.error_message {
            s.content("ErrorMessage", val)?;
        }
        Ok(())
    }
}

impl<'xml> DeserializeContent<'xml> for ErrorDetails {
    fn deserialize_content(d: &mut Deserializer<'xml>) -> DeResult<Self> {
        let mut error_code: Option<ErrorCode> = None;
        let mut error_message: Option<ErrorMessage> = None;
        d.for_each_element(|d, x| match x {
            b"ErrorCode" => {
                if error_code.is_some() {
                    return Err(DeError::DuplicateField);
                }
                error_code = Some(d.content()?);
                Ok(())
            }
            b"ErrorMessage" => {
                if error_message.is_some() {
                    return Err(DeError::DuplicateField);
                }
                error_message = Some(d.content()?);
                Ok(())
            }
            _ => Err(DeError::UnexpectedTagName),
        })?;
        Ok(Self {
            error_code,
            error_message,
        })
    }
}
impl SerializeContent for ErrorDocument {
    fn serialize_content<W: Write>(&self, s: &mut Serializer<W>) -> SerResult {
        s.content("Key", &self.key)?;
        Ok(())
    }
}

impl<'xml> DeserializeContent<'xml> for ErrorDocument {
    fn deserialize_content(d: &mut Deserializer<'xml>) -> DeResult<Self> {
        let mut key: Option<ObjectKey> = None;
        d.for_each_element(|d, x| match x {
            b"Key" => {
                if key.is_some() {
                    return Err(DeError::DuplicateField);
                }
                key = Some(d.content()?);
                Ok(())
            }
            _ => Err(DeError::UnexpectedTagName),
        })?;
        Ok(Self {
            key: key.ok_or(DeError::MissingField)?,
        })
    }
}
impl SerializeContent for EventBridgeConfiguration {
    fn serialize_content<W: Write>(&self, _: &mut Serializer<W>) -> SerResult {
        Ok(())
    }
}

impl<'xml> DeserializeContent<'xml> for EventBridgeConfiguration {
    fn deserialize_content(_: &mut Deserializer<'xml>) -> DeResult<Self> {
        Ok(Self {})
    }
}
impl SerializeContent for ExcludedPrefix {
    fn serialize_content<W: Write>(&self, s: &mut Serializer<W>) -> SerResult {
        if let Some(ref val) = self.prefix {
            s.content("Prefix", val)?;
        }
        Ok(())
    }
}

impl<'xml> DeserializeContent<'xml> for ExcludedPrefix {
    fn deserialize_content(d: &mut Deserializer<'xml>) -> DeResult<Self> {
        let mut prefix: Option<Prefix> = None;
        d.for_each_element(|d, x| match x {
            b"Prefix" => {
                if prefix.is_some() {
                    return Err(DeError::DuplicateField);
                }
                prefix = Some(d.content()?);
                Ok(())
            }
            _ => Err(DeError::UnexpectedTagName),
        })?;
        Ok(Self { prefix })
    }
}
impl SerializeContent for ExistingObjectReplication {
    fn serialize_content<W: Write>(&self, s: &mut Serializer<W>) -> SerResult {
        s.content("Status", &self.status)?;
        Ok(())
    }
}

impl<'xml> DeserializeContent<'xml> for ExistingObjectReplication {
    fn deserialize_content(d: &mut Deserializer<'xml>) -> DeResult<Self> {
        let mut status: Option<ExistingObjectReplicationStatus> = None;
        d.for_each_element(|d, x| match x {
            b"Status" => {
                if status.is_some() {
                    return Err(DeError::DuplicateField);
                }
                status = Some(d.content()?);
                Ok(())
            }
            _ => Err(DeError::UnexpectedTagName),
        })?;
        Ok(Self {
            status: status.ok_or(DeError::MissingField)?,
        })
    }
}
impl SerializeContent for ExistingObjectReplicationStatus {
    fn serialize_content<W: Write>(&self, s: &mut Serializer<W>) -> SerResult {
        self.as_str().serialize_content(s)
    }
}
impl<'xml> DeserializeContent<'xml> for ExistingObjectReplicationStatus {
    fn deserialize_content(d: &mut Deserializer<'xml>) -> DeResult<Self> {
        d.text(|t| {
            let b: &[u8] = &t;
            match b {
                b"Disabled" => Ok(Self::from_static(ExistingObjectReplicationStatus::DISABLED)),
                b"Enabled" => Ok(Self::from_static(ExistingObjectReplicationStatus::ENABLED)),
                _ => Ok(Self::from(t.unescape().map_err(DeError::InvalidXml)?.into_owned())),
            }
        })
    }
}
impl SerializeContent for ExpirationStatus {
    fn serialize_content<W: Write>(&self, s: &mut Serializer<W>) -> SerResult {
        self.as_str().serialize_content(s)
    }
}
impl<'xml> DeserializeContent<'xml> for ExpirationStatus {
    fn deserialize_content(d: &mut Deserializer<'xml>) -> DeResult<Self> {
        d.text(|t| {
            let b: &[u8] = &t;
            match b {
                b"Disabled" => Ok(Self::from_static(ExpirationStatus::DISABLED)),
                b"Enabled" => Ok(Self::from_static(ExpirationStatus::ENABLED)),
                _ => Ok(Self::from(t.unescape().map_err(DeError::InvalidXml)?.into_owned())),
            }
        })
    }
}
impl SerializeContent for ExpressionType {
    fn serialize_content<W: Write>(&self, s: &mut Serializer<W>) -> SerResult {
        self.as_str().serialize_content(s)
    }
}
impl<'xml> DeserializeContent<'xml> for ExpressionType {
    fn deserialize_content(d: &mut Deserializer<'xml>) -> DeResult<Self> {
        d.text(|t| {
            let b: &[u8] = &t;
            match b {
                b"SQL" => Ok(Self::from_static(ExpressionType::SQL)),
                _ => Ok(Self::from(t.unescape().map_err(DeError::InvalidXml)?.into_owned())),
            }
        })
    }
}
impl SerializeContent for FileHeaderInfo {
    fn serialize_content<W: Write>(&self, s: &mut Serializer<W>) -> SerResult {
        self.as_str().serialize_content(s)
    }
}
impl<'xml> DeserializeContent<'xml> for FileHeaderInfo {
    fn deserialize_content(d: &mut Deserializer<'xml>) -> DeResult<Self> {
        d.text(|t| {
            let b: &[u8] = &t;
            match b {
                b"IGNORE" => Ok(Self::from_static(FileHeaderInfo::IGNORE)),
                b"NONE" => Ok(Self::from_static(FileHeaderInfo::NONE)),
                b"USE" => Ok(Self::from_static(FileHeaderInfo::USE)),
                _ => Ok(Self::from(t.unescape().map_err(DeError::InvalidXml)?.into_owned())),
            }
        })
    }
}
impl SerializeContent for FilterRule {
    fn serialize_content<W: Write>(&self, s: &mut Serializer<W>) -> SerResult {
        if let Some(ref val) = self.name {
            s.content("Name", val)?;
        }
        if let Some(ref val) = self.value {
            s.content("Value", val)?;
        }
        Ok(())
    }
}

impl<'xml> DeserializeContent<'xml> for FilterRule {
    fn deserialize_content(d: &mut Deserializer<'xml>) -> DeResult<Self> {
        let mut name: Option<FilterRuleName> = None;
        let mut value: Option<FilterRuleValue> = None;
        d.for_each_element(|d, x| match x {
            b"Name" => {
                if name.is_some() {
                    return Err(DeError::DuplicateField);
                }
                name = Some(d.content()?);
                Ok(())
            }
            b"Value" => {
                if value.is_some() {
                    return Err(DeError::DuplicateField);
                }
                value = Some(d.content()?);
                Ok(())
            }
            _ => Err(DeError::UnexpectedTagName),
        })?;
        Ok(Self { name, value })
    }
}
impl SerializeContent for FilterRuleName {
    fn serialize_content<W: Write>(&self, s: &mut Serializer<W>) -> SerResult {
        self.as_str().serialize_content(s)
    }
}
impl<'xml> DeserializeContent<'xml> for FilterRuleName {
    fn deserialize_content(d: &mut Deserializer<'xml>) -> DeResult<Self> {
        d.text(|t| {
            let b: &[u8] = &t;
            match b {
                b"prefix" => Ok(Self::from_static(FilterRuleName::PREFIX)),
                b"suffix" => Ok(Self::from_static(FilterRuleName::SUFFIX)),
                _ => Ok(Self::from(t.unescape().map_err(DeError::InvalidXml)?.into_owned())),
            }
        })
    }
}
impl SerializeContent for GetBucketAccelerateConfigurationOutput {
    fn serialize_content<W: Write>(&self, s: &mut Serializer<W>) -> SerResult {
        if let Some(ref val) = self.status {
            s.content("Status", val)?;
        }
        Ok(())
    }
}

impl SerializeContent for GetBucketAclOutput {
    fn serialize_content<W: Write>(&self, s: &mut Serializer<W>) -> SerResult {
        if let Some(iter) = &self.grants {
            s.list("AccessControlList", "Grant", iter)?;
        }
        if let Some(ref val) = self.owner {
            s.content("Owner", val)?;
        }
        Ok(())
    }
}

impl<'xml> DeserializeContent<'xml> for GetBucketAclOutput {
    fn deserialize_content(d: &mut Deserializer<'xml>) -> DeResult<Self> {
        let mut grants: Option<Grants> = None;
        let mut owner: Option<Owner> = None;
        d.for_each_element(|d, x| match x {
            b"AccessControlList" => {
                if grants.is_some() {
                    return Err(DeError::DuplicateField);
                }
                grants = Some(d.list_content("Grant")?);
                Ok(())
            }
            b"Owner" => {
                if owner.is_some() {
                    return Err(DeError::DuplicateField);
                }
                owner = Some(d.content()?);
                Ok(())
            }
            _ => Err(DeError::UnexpectedTagName),
        })?;
        Ok(Self { grants, owner })
    }
}
impl SerializeContent for GetBucketCorsOutput {
    fn serialize_content<W: Write>(&self, s: &mut Serializer<W>) -> SerResult {
        if let Some(iter) = &self.cors_rules {
            s.flattened_list("CORSRule", iter)?;
        }
        Ok(())
    }
}

impl<'xml> DeserializeContent<'xml> for GetBucketCorsOutput {
    fn deserialize_content(d: &mut Deserializer<'xml>) -> DeResult<Self> {
        let mut cors_rules: Option<CORSRules> = None;
        d.for_each_element(|d, x| match x {
            b"CORSRule" => {
                let ans: CORSRule = d.content()?;
                cors_rules.get_or_insert_with(List::new).push(ans);
                Ok(())
            }
            _ => Err(DeError::UnexpectedTagName),
        })?;
        Ok(Self { cors_rules })
    }
}
impl SerializeContent for GetBucketLifecycleConfigurationOutput {
    fn serialize_content<W: Write>(&self, s: &mut Serializer<W>) -> SerResult {
        if let Some(iter) = &self.rules {
            s.flattened_list("Rule", iter)?;
        }
        Ok(())
    }
}

impl SerializeContent for GetBucketLocationOutput {
    fn serialize_content<W: Write>(&self, s: &mut Serializer<W>) -> SerResult {
        if let Some(ref val) = self.location_constraint {
            s.content("LocationConstraint", val)?;
        }
        Ok(())
    }
}

impl<'xml> DeserializeContent<'xml> for GetBucketLocationOutput {
    fn deserialize_content(d: &mut Deserializer<'xml>) -> DeResult<Self> {
        let mut location_constraint: Option<BucketLocationConstraint> = None;
        d.for_each_element(|d, x| match x {
            b"LocationConstraint" => {
                if location_constraint.is_some() {
                    return Err(DeError::DuplicateField);
                }
                location_constraint = Some(d.content()?);
                Ok(())
            }
            _ => Err(DeError::UnexpectedTagName),
        })?;
        Ok(Self { location_constraint })
    }
}
impl SerializeContent for GetBucketLoggingOutput {
    fn serialize_content<W: Write>(&self, s: &mut Serializer<W>) -> SerResult {
        if let Some(ref val) = self.logging_enabled {
            s.content("LoggingEnabled", val)?;
        }
        Ok(())
    }
}

impl<'xml> DeserializeContent<'xml> for GetBucketLoggingOutput {
    fn deserialize_content(d: &mut Deserializer<'xml>) -> DeResult<Self> {
        let mut logging_enabled: Option<LoggingEnabled> = None;
        d.for_each_element(|d, x| match x {
            b"LoggingEnabled" => {
                if logging_enabled.is_some() {
                    return Err(DeError::DuplicateField);
                }
                logging_enabled = Some(d.content()?);
                Ok(())
            }
            _ => Err(DeError::UnexpectedTagName),
        })?;
        Ok(Self { logging_enabled })
    }
}
impl SerializeContent for GetBucketMetadataTableConfigurationResult {
    fn serialize_content<W: Write>(&self, s: &mut Serializer<W>) -> SerResult {
        if let Some(ref val) = self.error {
            s.content("Error", val)?;
        }
        s.content("MetadataTableConfigurationResult", &self.metadata_table_configuration_result)?;
        s.content("Status", &self.status)?;
        Ok(())
    }
}

impl<'xml> DeserializeContent<'xml> for GetBucketMetadataTableConfigurationResult {
    fn deserialize_content(d: &mut Deserializer<'xml>) -> DeResult<Self> {
        let mut error: Option<ErrorDetails> = None;
        let mut metadata_table_configuration_result: Option<MetadataTableConfigurationResult> = None;
        let mut status: Option<MetadataTableStatus> = None;
        d.for_each_element(|d, x| match x {
            b"Error" => {
                if error.is_some() {
                    return Err(DeError::DuplicateField);
                }
                error = Some(d.content()?);
                Ok(())
            }
            b"MetadataTableConfigurationResult" => {
                if metadata_table_configuration_result.is_some() {
                    return Err(DeError::DuplicateField);
                }
                metadata_table_configuration_result = Some(d.content()?);
                Ok(())
            }
            b"Status" => {
                if status.is_some() {
                    return Err(DeError::DuplicateField);
                }
                status = Some(d.content()?);
                Ok(())
            }
            _ => Err(DeError::UnexpectedTagName),
        })?;
        Ok(Self {
            error,
            metadata_table_configuration_result: metadata_table_configuration_result.ok_or(DeError::MissingField)?,
            status: status.ok_or(DeError::MissingField)?,
        })
    }
}
impl SerializeContent for GetBucketNotificationConfigurationOutput {
    fn serialize_content<W: Write>(&self, s: &mut Serializer<W>) -> SerResult {
        if let Some(ref val) = self.event_bridge_configuration {
            s.content("EventBridgeConfiguration", val)?;
        }
        if let Some(iter) = &self.lambda_function_configurations {
            s.flattened_list("CloudFunctionConfiguration", iter)?;
        }
        if let Some(iter) = &self.queue_configurations {
            s.flattened_list("QueueConfiguration", iter)?;
        }
        if let Some(iter) = &self.topic_configurations {
            s.flattened_list("TopicConfiguration", iter)?;
        }
        Ok(())
    }
}

impl<'xml> DeserializeContent<'xml> for GetBucketNotificationConfigurationOutput {
    fn deserialize_content(d: &mut Deserializer<'xml>) -> DeResult<Self> {
        let mut event_bridge_configuration: Option<EventBridgeConfiguration> = None;
        let mut lambda_function_configurations: Option<LambdaFunctionConfigurationList> = None;
        let mut queue_configurations: Option<QueueConfigurationList> = None;
        let mut topic_configurations: Option<TopicConfigurationList> = None;
        d.for_each_element(|d, x| match x {
            b"EventBridgeConfiguration" => {
                if event_bridge_configuration.is_some() {
                    return Err(DeError::DuplicateField);
                }
                event_bridge_configuration = Some(d.content()?);
                Ok(())
            }
            b"CloudFunctionConfiguration" => {
                let ans: LambdaFunctionConfiguration = d.content()?;
                lambda_function_configurations.get_or_insert_with(List::new).push(ans);
                Ok(())
            }
            b"QueueConfiguration" => {
                let ans: QueueConfiguration = d.content()?;
                queue_configurations.get_or_insert_with(List::new).push(ans);
                Ok(())
            }
            b"TopicConfiguration" => {
                let ans: TopicConfiguration = d.content()?;
                topic_configurations.get_or_insert_with(List::new).push(ans);
                Ok(())
            }
            _ => Err(DeError::UnexpectedTagName),
        })?;
        Ok(Self {
            event_bridge_configuration,
            lambda_function_configurations,
            queue_configurations,
            topic_configurations,
        })
    }
}
impl SerializeContent for GetBucketRequestPaymentOutput {
    fn serialize_content<W: Write>(&self, s: &mut Serializer<W>) -> SerResult {
        if let Some(ref val) = self.payer {
            s.content("Payer", val)?;
        }
        Ok(())
    }
}

impl<'xml> DeserializeContent<'xml> for GetBucketRequestPaymentOutput {
    fn deserialize_content(d: &mut Deserializer<'xml>) -> DeResult<Self> {
        let mut payer: Option<Payer> = None;
        d.for_each_element(|d, x| match x {
            b"Payer" => {
                if payer.is_some() {
                    return Err(DeError::DuplicateField);
                }
                payer = Some(d.content()?);
                Ok(())
            }
            _ => Err(DeError::UnexpectedTagName),
        })?;
        Ok(Self { payer })
    }
}
impl SerializeContent for GetBucketTaggingOutput {
    fn serialize_content<W: Write>(&self, s: &mut Serializer<W>) -> SerResult {
        {
            let iter = &self.tag_set;
            s.list("TagSet", "Tag", iter)?;
        }
        Ok(())
    }
}

impl<'xml> DeserializeContent<'xml> for GetBucketTaggingOutput {
    fn deserialize_content(d: &mut Deserializer<'xml>) -> DeResult<Self> {
        let mut tag_set: Option<TagSet> = None;
        d.for_each_element(|d, x| match x {
            b"TagSet" => {
                if tag_set.is_some() {
                    return Err(DeError::DuplicateField);
                }
                tag_set = Some(d.list_content("Tag")?);
                Ok(())
            }
            _ => Err(DeError::UnexpectedTagName),
        })?;
        Ok(Self {
            tag_set: tag_set.ok_or(DeError::MissingField)?,
        })
    }
}
impl SerializeContent for GetBucketVersioningOutput {
    fn serialize_content<W: Write>(&self, s: &mut Serializer<W>) -> SerResult {
        if let Some(ref val) = self.mfa_delete {
            s.content("MfaDelete", val)?;
        }
        if let Some(ref val) = self.status {
            s.content("Status", val)?;
        }
        Ok(())
    }
}

impl<'xml> DeserializeContent<'xml> for GetBucketVersioningOutput {
    fn deserialize_content(d: &mut Deserializer<'xml>) -> DeResult<Self> {
        let mut mfa_delete: Option<MFADeleteStatus> = None;
        let mut status: Option<BucketVersioningStatus> = None;
        d.for_each_element(|d, x| match x {
            b"MfaDelete" => {
                if mfa_delete.is_some() {
                    return Err(DeError::DuplicateField);
                }
                mfa_delete = Some(d.content()?);
                Ok(())
            }
            b"Status" => {
                if status.is_some() {
                    return Err(DeError::DuplicateField);
                }
                status = Some(d.content()?);
                Ok(())
            }
            _ => Err(DeError::UnexpectedTagName),
        })?;
        Ok(Self { mfa_delete, status })
    }
}
impl SerializeContent for GetBucketWebsiteOutput {
    fn serialize_content<W: Write>(&self, s: &mut Serializer<W>) -> SerResult {
        if let Some(ref val) = self.error_document {
            s.content("ErrorDocument", val)?;
        }
        if let Some(ref val) = self.index_document {
            s.content("IndexDocument", val)?;
        }
        if let Some(ref val) = self.redirect_all_requests_to {
            s.content("RedirectAllRequestsTo", val)?;
        }
        if let Some(iter) = &self.routing_rules {
            s.list("RoutingRules", "RoutingRule", iter)?;
        }
        Ok(())
    }
}

impl<'xml> DeserializeContent<'xml> for GetBucketWebsiteOutput {
    fn deserialize_content(d: &mut Deserializer<'xml>) -> DeResult<Self> {
        let mut error_document: Option<ErrorDocument> = None;
        let mut index_document: Option<IndexDocument> = None;
        let mut redirect_all_requests_to: Option<RedirectAllRequestsTo> = None;
        let mut routing_rules: Option<RoutingRules> = None;
        d.for_each_element(|d, x| match x {
            b"ErrorDocument" => {
                if error_document.is_some() {
                    return Err(DeError::DuplicateField);
                }
                error_document = Some(d.content()?);
                Ok(())
            }
            b"IndexDocument" => {
                if index_document.is_some() {
                    return Err(DeError::DuplicateField);
                }
                index_document = Some(d.content()?);
                Ok(())
            }
            b"RedirectAllRequestsTo" => {
                if redirect_all_requests_to.is_some() {
                    return Err(DeError::DuplicateField);
                }
                redirect_all_requests_to = Some(d.content()?);
                Ok(())
            }
            b"RoutingRules" => {
                if routing_rules.is_some() {
                    return Err(DeError::DuplicateField);
                }
                routing_rules = Some(d.list_content("RoutingRule")?);
                Ok(())
            }
            _ => Err(DeError::UnexpectedTagName),
        })?;
        Ok(Self {
            error_document,
            index_document,
            redirect_all_requests_to,
            routing_rules,
        })
    }
}
impl SerializeContent for GetObjectAclOutput {
    fn serialize_content<W: Write>(&self, s: &mut Serializer<W>) -> SerResult {
        if let Some(iter) = &self.grants {
            s.list("AccessControlList", "Grant", iter)?;
        }
        if let Some(ref val) = self.owner {
            s.content("Owner", val)?;
        }
        Ok(())
    }
}

impl SerializeContent for GetObjectAttributesOutput {
    fn serialize_content<W: Write>(&self, s: &mut Serializer<W>) -> SerResult {
        if let Some(ref val) = self.checksum {
            s.content("Checksum", val)?;
        }
        if let Some(ref val) = self.e_tag {
            s.content("ETag", val)?;
        }
        if let Some(ref val) = self.object_parts {
            s.content("ObjectParts", val)?;
        }
        if let Some(ref val) = self.object_size {
            s.content("ObjectSize", val)?;
        }
        if let Some(ref val) = self.storage_class {
            s.content("StorageClass", val)?;
        }
        Ok(())
    }
}

impl SerializeContent for GetObjectAttributesParts {
    fn serialize_content<W: Write>(&self, s: &mut Serializer<W>) -> SerResult {
        if let Some(ref val) = self.is_truncated {
            s.content("IsTruncated", val)?;
        }
        if let Some(ref val) = self.max_parts {
            s.content("MaxParts", val)?;
        }
        if let Some(ref val) = self.next_part_number_marker {
            s.content("NextPartNumberMarker", val)?;
        }
        if let Some(ref val) = self.part_number_marker {
            s.content("PartNumberMarker", val)?;
        }
        if let Some(iter) = &self.parts {
            s.flattened_list("Part", iter)?;
        }
        if let Some(ref val) = self.total_parts_count {
            s.content("PartsCount", val)?;
        }
        Ok(())
    }
}

impl<'xml> DeserializeContent<'xml> for GetObjectAttributesParts {
    fn deserialize_content(d: &mut Deserializer<'xml>) -> DeResult<Self> {
        let mut is_truncated: Option<IsTruncated> = None;
        let mut max_parts: Option<MaxParts> = None;
        let mut next_part_number_marker: Option<NextPartNumberMarker> = None;
        let mut part_number_marker: Option<PartNumberMarker> = None;
        let mut parts: Option<PartsList> = None;
        let mut total_parts_count: Option<PartsCount> = None;
        d.for_each_element(|d, x| match x {
            b"IsTruncated" => {
                if is_truncated.is_some() {
                    return Err(DeError::DuplicateField);
                }
                is_truncated = Some(d.content()?);
                Ok(())
            }
            b"MaxParts" => {
                if max_parts.is_some() {
                    return Err(DeError::DuplicateField);
                }
                max_parts = Some(d.content()?);
                Ok(())
            }
            b"NextPartNumberMarker" => {
                if next_part_number_marker.is_some() {
                    return Err(DeError::DuplicateField);
                }
                next_part_number_marker = Some(d.content()?);
                Ok(())
            }
            b"PartNumberMarker" => {
                if part_number_marker.is_some() {
                    return Err(DeError::DuplicateField);
                }
                part_number_marker = Some(d.content()?);
                Ok(())
            }
            b"Part" => {
                let ans: ObjectPart = d.content()?;
                parts.get_or_insert_with(List::new).push(ans);
                Ok(())
            }
            b"PartsCount" => {
                if total_parts_count.is_some() {
                    return Err(DeError::DuplicateField);
                }
                total_parts_count = Some(d.content()?);
                Ok(())
            }
            _ => Err(DeError::UnexpectedTagName),
        })?;
        Ok(Self {
            is_truncated,
            max_parts,
            next_part_number_marker,
            part_number_marker,
            parts,
            total_parts_count,
        })
    }
}
impl SerializeContent for GetObjectTaggingOutput {
    fn serialize_content<W: Write>(&self, s: &mut Serializer<W>) -> SerResult {
        {
            let iter = &self.tag_set;
            s.list("TagSet", "Tag", iter)?;
        }
        Ok(())
    }
}

impl SerializeContent for GlacierJobParameters {
    fn serialize_content<W: Write>(&self, s: &mut Serializer<W>) -> SerResult {
        s.content("Tier", &self.tier)?;
        Ok(())
    }
}

impl<'xml> DeserializeContent<'xml> for GlacierJobParameters {
    fn deserialize_content(d: &mut Deserializer<'xml>) -> DeResult<Self> {
        let mut tier: Option<Tier> = None;
        d.for_each_element(|d, x| match x {
            b"Tier" => {
                if tier.is_some() {
                    return Err(DeError::DuplicateField);
                }
                tier = Some(d.content()?);
                Ok(())
            }
            _ => Err(DeError::UnexpectedTagName),
        })?;
        Ok(Self {
            tier: tier.ok_or(DeError::MissingField)?,
        })
    }
}
impl SerializeContent for Grant {
    fn serialize_content<W: Write>(&self, s: &mut Serializer<W>) -> SerResult {
        if let Some(ref val) = self.grantee {
            let attrs = [
                ("xmlns:xsi", "http://www.w3.org/2001/XMLSchema-instance"),
                ("xsi:type", val.type_.as_str()),
            ];
            s.content_with_attrs("Grantee", &attrs, val)?;
        }
        if let Some(ref val) = self.permission {
            s.content("Permission", val)?;
        }
        Ok(())
    }
}

impl<'xml> DeserializeContent<'xml> for Grant {
    fn deserialize_content(d: &mut Deserializer<'xml>) -> DeResult<Self> {
        let mut grantee: Option<Grantee> = None;
        let mut permission: Option<Permission> = None;
        d.for_each_element_with_start(|d, x, start| match x {
            b"Grantee" => {
                if grantee.is_some() {
                    return Err(DeError::DuplicateField);
                }
                let mut type_: Option<Type> = None;
                for attr in start.attributes() {
                    let Ok(attr) = attr else { return Err(DeError::InvalidAttribute) };
                    if attr.key.as_ref() == b"xsi:type" {
                        type_ = Some(attr.unescape_value().map_err(DeError::InvalidXml)?.into_owned().into());
                    }
                }
                let mut display_name: Option<DisplayName> = None;
                let mut email_address: Option<EmailAddress> = None;
                let mut id: Option<ID> = None;
                let mut uri: Option<URI> = None;
                d.for_each_element(|d, x| match x {
                    b"DisplayName" => {
                        if display_name.is_some() {
                            return Err(DeError::DuplicateField);
                        }
                        display_name = Some(d.content()?);
                        Ok(())
                    }
                    b"EmailAddress" => {
                        if email_address.is_some() {
                            return Err(DeError::DuplicateField);
                        }
                        email_address = Some(d.content()?);
                        Ok(())
                    }
                    b"ID" => {
                        if id.is_some() {
                            return Err(DeError::DuplicateField);
                        }
                        id = Some(d.content()?);
                        Ok(())
                    }
                    b"URI" => {
                        if uri.is_some() {
                            return Err(DeError::DuplicateField);
                        }
                        uri = Some(d.content()?);
                        Ok(())
                    }
                    _ => Err(DeError::UnexpectedTagName),
                })?;
                grantee = Some(Grantee {
                    display_name,
                    email_address,
                    id,
                    type_: type_.ok_or(DeError::MissingField)?,
                    uri,
                });
                Ok(())
            }
            b"Permission" => {
                if permission.is_some() {
                    return Err(DeError::DuplicateField);
                }
                permission = Some(d.content()?);
                Ok(())
            }
            _ => Err(DeError::UnexpectedTagName),
        })?;
        Ok(Self { grantee, permission })
    }
}
impl SerializeContent for Grantee {
    fn serialize_content<W: Write>(&self, s: &mut Serializer<W>) -> SerResult {
        if let Some(ref val) = self.display_name {
            s.content("DisplayName", val)?;
        }
        if let Some(ref val) = self.email_address {
            s.content("EmailAddress", val)?;
        }
        if let Some(ref val) = self.id {
            s.content("ID", val)?;
        }
        if let Some(ref val) = self.uri {
            s.content("URI", val)?;
        }
        Ok(())
    }
}

impl SerializeContent for IndexDocument {
    fn serialize_content<W: Write>(&self, s: &mut Serializer<W>) -> SerResult {
        s.content("Suffix", &self.suffix)?;
        Ok(())
    }
}

impl<'xml> DeserializeContent<'xml> for IndexDocument {
    fn deserialize_content(d: &mut Deserializer<'xml>) -> DeResult<Self> {
        let mut suffix: Option<Suffix> = None;
        d.for_each_element(|d, x| match x {
            b"Suffix" => {
                if suffix.is_some() {
                    return Err(DeError::DuplicateField);
                }
                suffix = Some(d.content()?);
                Ok(())
            }
            _ => Err(DeError::UnexpectedTagName),
        })?;
        Ok(Self {
            suffix: suffix.ok_or(DeError::MissingField)?,
        })
    }
}
impl SerializeContent for Initiator {
    fn serialize_content<W: Write>(&self, s: &mut Serializer<W>) -> SerResult {
        if let Some(ref val) = self.display_name {
            s.content("DisplayName", val)?;
        }
        if let Some(ref val) = self.id {
            s.content("ID", val)?;
        }
        Ok(())
    }
}

impl<'xml> DeserializeContent<'xml> for Initiator {
    fn deserialize_content(d: &mut Deserializer<'xml>) -> DeResult<Self> {
        let mut display_name: Option<DisplayName> = None;
        let mut id: Option<ID> = None;
        d.for_each_element(|d, x| match x {
            b"DisplayName" => {
                if display_name.is_some() {
                    return Err(DeError::DuplicateField);
                }
                display_name = Some(d.content()?);
                Ok(())
            }
            b"ID" => {
                if id.is_some() {
                    return Err(DeError::DuplicateField);
                }
                id = Some(d.content()?);
                Ok(())
            }
            _ => Err(DeError::UnexpectedTagName),
        })?;
        Ok(Self { display_name, id })
    }
}
impl SerializeContent for InputSerialization {
    fn serialize_content<W: Write>(&self, s: &mut Serializer<W>) -> SerResult {
        if let Some(ref val) = self.csv {
            s.content("CSV", val)?;
        }
        if let Some(ref val) = self.compression_type {
            s.content("CompressionType", val)?;
        }
        if let Some(ref val) = self.json {
            s.content("JSON", val)?;
        }
        if let Some(ref val) = self.parquet {
            s.content("Parquet", val)?;
        }
        Ok(())
    }
}

impl<'xml> DeserializeContent<'xml> for InputSerialization {
    fn deserialize_content(d: &mut Deserializer<'xml>) -> DeResult<Self> {
        let mut csv: Option<CSVInput> = None;
        let mut compression_type: Option<CompressionType> = None;
        let mut json: Option<JSONInput> = None;
        let mut parquet: Option<ParquetInput> = None;
        d.for_each_element(|d, x| match x {
            b"CSV" => {
                if csv.is_some() {
                    return Err(DeError::DuplicateField);
                }
                csv = Some(d.content()?);
                Ok(())
            }
            b"CompressionType" => {
                if compression_type.is_some() {
                    return Err(DeError::DuplicateField);
                }
                compression_type = Some(d.content()?);
                Ok(())
            }
            b"JSON" => {
                if json.is_some() {
                    return Err(DeError::DuplicateField);
                }
                json = Some(d.content()?);
                Ok(())
            }
            b"Parquet" => {
                if parquet.is_some() {
                    return Err(DeError::DuplicateField);
                }
                parquet = Some(d.content()?);
                Ok(())
            }
            _ => Err(DeError::UnexpectedTagName),
        })?;
        Ok(Self {
            csv,
            compression_type,
            json,
            parquet,
        })
    }
}
impl SerializeContent for IntelligentTieringAccessTier {
    fn serialize_content<W: Write>(&self, s: &mut Serializer<W>) -> SerResult {
        self.as_str().serialize_content(s)
    }
}
impl<'xml> DeserializeContent<'xml> for IntelligentTieringAccessTier {
    fn deserialize_content(d: &mut Deserializer<'xml>) -> DeResult<Self> {
        d.text(|t| {
            let b: &[u8] = &t;
            match b {
                b"ARCHIVE_ACCESS" => Ok(Self::from_static(IntelligentTieringAccessTier::ARCHIVE_ACCESS)),
                b"DEEP_ARCHIVE_ACCESS" => Ok(Self::from_static(IntelligentTieringAccessTier::DEEP_ARCHIVE_ACCESS)),
                _ => Ok(Self::from(t.unescape().map_err(DeError::InvalidXml)?.into_owned())),
            }
        })
    }
}
impl SerializeContent for IntelligentTieringAndOperator {
    fn serialize_content<W: Write>(&self, s: &mut Serializer<W>) -> SerResult {
        if let Some(ref val) = self.prefix {
            s.content("Prefix", val)?;
        }
        if let Some(iter) = &self.tags {
            s.flattened_list("Tag", iter)?;
        }
        Ok(())
    }
}

impl<'xml> DeserializeContent<'xml> for IntelligentTieringAndOperator {
    fn deserialize_content(d: &mut Deserializer<'xml>) -> DeResult<Self> {
        let mut prefix: Option<Prefix> = None;
        let mut tags: Option<TagSet> = None;
        d.for_each_element(|d, x| match x {
            b"Prefix" => {
                if prefix.is_some() {
                    return Err(DeError::DuplicateField);
                }
                prefix = Some(d.content()?);
                Ok(())
            }
            b"Tag" => {
                let ans: Tag = d.content()?;
                tags.get_or_insert_with(List::new).push(ans);
                Ok(())
            }
            _ => Err(DeError::UnexpectedTagName),
        })?;
        Ok(Self { prefix, tags })
    }
}
impl SerializeContent for IntelligentTieringConfiguration {
    fn serialize_content<W: Write>(&self, s: &mut Serializer<W>) -> SerResult {
        if let Some(ref val) = self.filter {
            s.content("Filter", val)?;
        }
        s.content("Id", &self.id)?;
        s.content("Status", &self.status)?;
        {
            let iter = &self.tierings;
            s.flattened_list("Tiering", iter)?;
        }
        Ok(())
    }
}

impl<'xml> DeserializeContent<'xml> for IntelligentTieringConfiguration {
    fn deserialize_content(d: &mut Deserializer<'xml>) -> DeResult<Self> {
        let mut filter: Option<IntelligentTieringFilter> = None;
        let mut id: Option<IntelligentTieringId> = None;
        let mut status: Option<IntelligentTieringStatus> = None;
        let mut tierings: Option<TieringList> = None;
        d.for_each_element(|d, x| match x {
            b"Filter" => {
                if filter.is_some() {
                    return Err(DeError::DuplicateField);
                }
                filter = Some(d.content()?);
                Ok(())
            }
            b"Id" => {
                if id.is_some() {
                    return Err(DeError::DuplicateField);
                }
                id = Some(d.content()?);
                Ok(())
            }
            b"Status" => {
                if status.is_some() {
                    return Err(DeError::DuplicateField);
                }
                status = Some(d.content()?);
                Ok(())
            }
            b"Tiering" => {
                let ans: Tiering = d.content()?;
                tierings.get_or_insert_with(List::new).push(ans);
                Ok(())
            }
            _ => Err(DeError::UnexpectedTagName),
        })?;
        Ok(Self {
            filter,
            id: id.ok_or(DeError::MissingField)?,
            status: status.ok_or(DeError::MissingField)?,
            tierings: tierings.ok_or(DeError::MissingField)?,
        })
    }
}
impl SerializeContent for IntelligentTieringFilter {
    fn serialize_content<W: Write>(&self, s: &mut Serializer<W>) -> SerResult {
        if let Some(ref val) = self.and {
            s.content("And", val)?;
        }
        if let Some(ref val) = self.prefix {
            s.content("Prefix", val)?;
        }
        if let Some(ref val) = self.tag {
            s.content("Tag", val)?;
        }
        Ok(())
    }
}

impl<'xml> DeserializeContent<'xml> for IntelligentTieringFilter {
    fn deserialize_content(d: &mut Deserializer<'xml>) -> DeResult<Self> {
        let mut and: Option<IntelligentTieringAndOperator> = None;
        let mut prefix: Option<Prefix> = None;
        let mut tag: Option<Tag> = None;
        d.for_each_element(|d, x| match x {
            b"And" => {
                if and.is_some() {
                    return Err(DeError::DuplicateField);
                }
                and = Some(d.content()?);
                Ok(())
            }
            b"Prefix" => {
                if prefix.is_some() {
                    return Err(DeError::DuplicateField);
                }
                prefix = Some(d.content()?);
                Ok(())
            }
            b"Tag" => {
                if tag.is_some() {
                    return Err(DeError::DuplicateField);
                }
                tag = Some(d.content()?);
                Ok(())
            }
            _ => Err(DeError::UnexpectedTagName),
        })?;
        Ok(Self { and, prefix, tag })
    }
}
impl SerializeContent for IntelligentTieringStatus {
    fn serialize_content<W: Write>(&self, s: &mut Serializer<W>) -> SerResult {
        self.as_str().serialize_content(s)
    }
}
impl<'xml> DeserializeContent<'xml> for IntelligentTieringStatus {
    fn deserialize_content(d: &mut Deserializer<'xml>) -> DeResult<Self> {
        d.text(|t| {
            let b: &[u8] = &t;
            match b {
                b"Disabled" => Ok(Self::from_static(IntelligentTieringStatus::DISABLED)),
                b"Enabled" => Ok(Self::from_static(IntelligentTieringStatus::ENABLED)),
                _ => Ok(Self::from(t.unescape().map_err(DeError::InvalidXml)?.into_owned())),
            }
        })
    }
}
impl SerializeContent for InventoryConfiguration {
    fn serialize_content<W: Write>(&self, s: &mut Serializer<W>) -> SerResult {
        s.content("Destination", &self.destination)?;
        if let Some(ref val) = self.filter {
            s.content("Filter", val)?;
        }
        s.content("Id", &self.id)?;
        s.content("IncludedObjectVersions", &self.included_object_versions)?;
        s.content("IsEnabled", &self.is_enabled)?;
        if let Some(iter) = &self.optional_fields {
            s.list("OptionalFields", "Field", iter)?;
        }
        s.content("Schedule", &self.schedule)?;
        Ok(())
    }
}

impl<'xml> DeserializeContent<'xml> for InventoryConfiguration {
    fn deserialize_content(d: &mut Deserializer<'xml>) -> DeResult<Self> {
        let mut destination: Option<InventoryDestination> = None;
        let mut filter: Option<InventoryFilter> = None;
        let mut id: Option<InventoryId> = None;
        let mut included_object_versions: Option<InventoryIncludedObjectVersions> = None;
        let mut is_enabled: Option<IsEnabled> = None;
        let mut optional_fields: Option<InventoryOptionalFields> = None;
        let mut schedule: Option<InventorySchedule> = None;
        d.for_each_element(|d, x| match x {
            b"Destination" => {
                if destination.is_some() {
                    return Err(DeError::DuplicateField);
                }
                destination = Some(d.content()?);
                Ok(())
            }
            b"Filter" => {
                if filter.is_some() {
                    return Err(DeError::DuplicateField);
                }
                filter = Some(d.content()?);
                Ok(())
            }
            b"Id" => {
                if id.is_some() {
                    return Err(DeError::DuplicateField);
                }
                id = Some(d.content()?);
                Ok(())
            }
            b"IncludedObjectVersions" => {
                if included_object_versions.is_some() {
                    return Err(DeError::DuplicateField);
                }
                included_object_versions = Some(d.content()?);
                Ok(())
            }
            b"IsEnabled" => {
                if is_enabled.is_some() {
                    return Err(DeError::DuplicateField);
                }
                is_enabled = Some(d.content()?);
                Ok(())
            }
            b"OptionalFields" => {
                if optional_fields.is_some() {
                    return Err(DeError::DuplicateField);
                }
                optional_fields = Some(d.list_content("Field")?);
                Ok(())
            }
            b"Schedule" => {
                if schedule.is_some() {
                    return Err(DeError::DuplicateField);
                }
                schedule = Some(d.content()?);
                Ok(())
            }
            _ => Err(DeError::UnexpectedTagName),
        })?;
        Ok(Self {
            destination: destination.ok_or(DeError::MissingField)?,
            filter,
            id: id.ok_or(DeError::MissingField)?,
            included_object_versions: included_object_versions.ok_or(DeError::MissingField)?,
            is_enabled: is_enabled.ok_or(DeError::MissingField)?,
            optional_fields,
            schedule: schedule.ok_or(DeError::MissingField)?,
        })
    }
}
impl SerializeContent for InventoryDestination {
    fn serialize_content<W: Write>(&self, s: &mut Serializer<W>) -> SerResult {
        s.content("S3BucketDestination", &self.s3_bucket_destination)?;
        Ok(())
    }
}

impl<'xml> DeserializeContent<'xml> for InventoryDestination {
    fn deserialize_content(d: &mut Deserializer<'xml>) -> DeResult<Self> {
        let mut s3_bucket_destination: Option<InventoryS3BucketDestination> = None;
        d.for_each_element(|d, x| match x {
            b"S3BucketDestination" => {
                if s3_bucket_destination.is_some() {
                    return Err(DeError::DuplicateField);
                }
                s3_bucket_destination = Some(d.content()?);
                Ok(())
            }
            _ => Err(DeError::UnexpectedTagName),
        })?;
        Ok(Self {
            s3_bucket_destination: s3_bucket_destination.ok_or(DeError::MissingField)?,
        })
    }
}
impl SerializeContent for InventoryEncryption {
    fn serialize_content<W: Write>(&self, s: &mut Serializer<W>) -> SerResult {
        if let Some(ref val) = self.ssekms {
            s.content("SSE-KMS", val)?;
        }
        if let Some(ref val) = self.sses3 {
            s.content("SSE-S3", val)?;
        }
        Ok(())
    }
}

impl<'xml> DeserializeContent<'xml> for InventoryEncryption {
    fn deserialize_content(d: &mut Deserializer<'xml>) -> DeResult<Self> {
        let mut ssekms: Option<SSEKMS> = None;
        let mut sses3: Option<SSES3> = None;
        d.for_each_element(|d, x| match x {
            b"SSE-KMS" => {
                if ssekms.is_some() {
                    return Err(DeError::DuplicateField);
                }
                ssekms = Some(d.content()?);
                Ok(())
            }
            b"SSE-S3" => {
                if sses3.is_some() {
                    return Err(DeError::DuplicateField);
                }
                sses3 = Some(d.content()?);
                Ok(())
            }
            _ => Err(DeError::UnexpectedTagName),
        })?;
        Ok(Self { ssekms, sses3 })
    }
}
impl SerializeContent for InventoryFilter {
    fn serialize_content<W: Write>(&self, s: &mut Serializer<W>) -> SerResult {
        s.content("Prefix", &self.prefix)?;
        Ok(())
    }
}

impl<'xml> DeserializeContent<'xml> for InventoryFilter {
    fn deserialize_content(d: &mut Deserializer<'xml>) -> DeResult<Self> {
        let mut prefix: Option<Prefix> = None;
        d.for_each_element(|d, x| match x {
            b"Prefix" => {
                if prefix.is_some() {
                    return Err(DeError::DuplicateField);
                }
                prefix = Some(d.content()?);
                Ok(())
            }
            _ => Err(DeError::UnexpectedTagName),
        })?;
        Ok(Self {
            prefix: prefix.ok_or(DeError::MissingField)?,
        })
    }
}
impl SerializeContent for InventoryFormat {
    fn serialize_content<W: Write>(&self, s: &mut Serializer<W>) -> SerResult {
        self.as_str().serialize_content(s)
    }
}
impl<'xml> DeserializeContent<'xml> for InventoryFormat {
    fn deserialize_content(d: &mut Deserializer<'xml>) -> DeResult<Self> {
        d.text(|t| {
            let b: &[u8] = &t;
            match b {
                b"CSV" => Ok(Self::from_static(InventoryFormat::CSV)),
                b"ORC" => Ok(Self::from_static(InventoryFormat::ORC)),
                b"Parquet" => Ok(Self::from_static(InventoryFormat::PARQUET)),
                _ => Ok(Self::from(t.unescape().map_err(DeError::InvalidXml)?.into_owned())),
            }
        })
    }
}
impl SerializeContent for InventoryFrequency {
    fn serialize_content<W: Write>(&self, s: &mut Serializer<W>) -> SerResult {
        self.as_str().serialize_content(s)
    }
}
impl<'xml> DeserializeContent<'xml> for InventoryFrequency {
    fn deserialize_content(d: &mut Deserializer<'xml>) -> DeResult<Self> {
        d.text(|t| {
            let b: &[u8] = &t;
            match b {
                b"Daily" => Ok(Self::from_static(InventoryFrequency::DAILY)),
                b"Weekly" => Ok(Self::from_static(InventoryFrequency::WEEKLY)),
                _ => Ok(Self::from(t.unescape().map_err(DeError::InvalidXml)?.into_owned())),
            }
        })
    }
}
impl SerializeContent for InventoryIncludedObjectVersions {
    fn serialize_content<W: Write>(&self, s: &mut Serializer<W>) -> SerResult {
        self.as_str().serialize_content(s)
    }
}
impl<'xml> DeserializeContent<'xml> for InventoryIncludedObjectVersions {
    fn deserialize_content(d: &mut Deserializer<'xml>) -> DeResult<Self> {
        d.text(|t| {
            let b: &[u8] = &t;
            match b {
                b"All" => Ok(Self::from_static(InventoryIncludedObjectVersions::ALL)),
                b"Current" => Ok(Self::from_static(InventoryIncludedObjectVersions::CURRENT)),
                _ => Ok(Self::from(t.unescape().map_err(DeError::InvalidXml)?.into_owned())),
            }
        })
    }
}
impl SerializeContent for InventoryOptionalField {
    fn serialize_content<W: Write>(&self, s: &mut Serializer<W>) -> SerResult {
        self.as_str().serialize_content(s)
    }
}
impl<'xml> DeserializeContent<'xml> for InventoryOptionalField {
    fn deserialize_content(d: &mut Deserializer<'xml>) -> DeResult<Self> {
        d.text(|t| {
            let b: &[u8] = &t;
            match b {
                b"BucketKeyStatus" => Ok(Self::from_static(InventoryOptionalField::BUCKET_KEY_STATUS)),
                b"ChecksumAlgorithm" => Ok(Self::from_static(InventoryOptionalField::CHECKSUM_ALGORITHM)),
                b"ETag" => Ok(Self::from_static(InventoryOptionalField::E_TAG)),
                b"EncryptionStatus" => Ok(Self::from_static(InventoryOptionalField::ENCRYPTION_STATUS)),
                b"IntelligentTieringAccessTier" => Ok(Self::from_static(InventoryOptionalField::INTELLIGENT_TIERING_ACCESS_TIER)),
                b"IsMultipartUploaded" => Ok(Self::from_static(InventoryOptionalField::IS_MULTIPART_UPLOADED)),
                b"LastModifiedDate" => Ok(Self::from_static(InventoryOptionalField::LAST_MODIFIED_DATE)),
                b"ObjectAccessControlList" => Ok(Self::from_static(InventoryOptionalField::OBJECT_ACCESS_CONTROL_LIST)),
                b"ObjectLockLegalHoldStatus" => Ok(Self::from_static(InventoryOptionalField::OBJECT_LOCK_LEGAL_HOLD_STATUS)),
                b"ObjectLockMode" => Ok(Self::from_static(InventoryOptionalField::OBJECT_LOCK_MODE)),
                b"ObjectLockRetainUntilDate" => Ok(Self::from_static(InventoryOptionalField::OBJECT_LOCK_RETAIN_UNTIL_DATE)),
                b"ObjectOwner" => Ok(Self::from_static(InventoryOptionalField::OBJECT_OWNER)),
                b"ReplicationStatus" => Ok(Self::from_static(InventoryOptionalField::REPLICATION_STATUS)),
                b"Size" => Ok(Self::from_static(InventoryOptionalField::SIZE)),
                b"StorageClass" => Ok(Self::from_static(InventoryOptionalField::STORAGE_CLASS)),
                _ => Ok(Self::from(t.unescape().map_err(DeError::InvalidXml)?.into_owned())),
            }
        })
    }
}
impl SerializeContent for InventoryS3BucketDestination {
    fn serialize_content<W: Write>(&self, s: &mut Serializer<W>) -> SerResult {
        if let Some(ref val) = self.account_id {
            s.content("AccountId", val)?;
        }
        s.content("Bucket", &self.bucket)?;
        if let Some(ref val) = self.encryption {
            s.content("Encryption", val)?;
        }
        s.content("Format", &self.format)?;
        if let Some(ref val) = self.prefix {
            s.content("Prefix", val)?;
        }
        Ok(())
    }
}

impl<'xml> DeserializeContent<'xml> for InventoryS3BucketDestination {
    fn deserialize_content(d: &mut Deserializer<'xml>) -> DeResult<Self> {
        let mut account_id: Option<AccountId> = None;
        let mut bucket: Option<BucketName> = None;
        let mut encryption: Option<InventoryEncryption> = None;
        let mut format: Option<InventoryFormat> = None;
        let mut prefix: Option<Prefix> = None;
        d.for_each_element(|d, x| match x {
            b"AccountId" => {
                if account_id.is_some() {
                    return Err(DeError::DuplicateField);
                }
                account_id = Some(d.content()?);
                Ok(())
            }
            b"Bucket" => {
                if bucket.is_some() {
                    return Err(DeError::DuplicateField);
                }
                bucket = Some(d.content()?);
                Ok(())
            }
            b"Encryption" => {
                if encryption.is_some() {
                    return Err(DeError::DuplicateField);
                }
                encryption = Some(d.content()?);
                Ok(())
            }
            b"Format" => {
                if format.is_some() {
                    return Err(DeError::DuplicateField);
                }
                format = Some(d.content()?);
                Ok(())
            }
            b"Prefix" => {
                if prefix.is_some() {
                    return Err(DeError::DuplicateField);
                }
                prefix = Some(d.content()?);
                Ok(())
            }
            _ => Err(DeError::UnexpectedTagName),
        })?;
        Ok(Self {
            account_id,
            bucket: bucket.ok_or(DeError::MissingField)?,
            encryption,
            format: format.ok_or(DeError::MissingField)?,
            prefix,
        })
    }
}
impl SerializeContent for InventorySchedule {
    fn serialize_content<W: Write>(&self, s: &mut Serializer<W>) -> SerResult {
        s.content("Frequency", &self.frequency)?;
        Ok(())
    }
}

impl<'xml> DeserializeContent<'xml> for InventorySchedule {
    fn deserialize_content(d: &mut Deserializer<'xml>) -> DeResult<Self> {
        let mut frequency: Option<InventoryFrequency> = None;
        d.for_each_element(|d, x| match x {
            b"Frequency" => {
                if frequency.is_some() {
                    return Err(DeError::DuplicateField);
                }
                frequency = Some(d.content()?);
                Ok(())
            }
            _ => Err(DeError::UnexpectedTagName),
        })?;
        Ok(Self {
            frequency: frequency.ok_or(DeError::MissingField)?,
        })
    }
}
impl SerializeContent for JSONInput {
    fn serialize_content<W: Write>(&self, s: &mut Serializer<W>) -> SerResult {
        if let Some(ref val) = self.type_ {
            s.content("Type", val)?;
        }
        Ok(())
    }
}

impl<'xml> DeserializeContent<'xml> for JSONInput {
    fn deserialize_content(d: &mut Deserializer<'xml>) -> DeResult<Self> {
        let mut type_: Option<JSONType> = None;
        d.for_each_element(|d, x| match x {
            b"Type" => {
                if type_.is_some() {
                    return Err(DeError::DuplicateField);
                }
                type_ = Some(d.content()?);
                Ok(())
            }
            _ => Err(DeError::UnexpectedTagName),
        })?;
        Ok(Self { type_ })
    }
}
impl SerializeContent for JSONOutput {
    fn serialize_content<W: Write>(&self, s: &mut Serializer<W>) -> SerResult {
        if let Some(ref val) = self.record_delimiter {
            s.content("RecordDelimiter", val)?;
        }
        Ok(())
    }
}

impl<'xml> DeserializeContent<'xml> for JSONOutput {
    fn deserialize_content(d: &mut Deserializer<'xml>) -> DeResult<Self> {
        let mut record_delimiter: Option<RecordDelimiter> = None;
        d.for_each_element(|d, x| match x {
            b"RecordDelimiter" => {
                if record_delimiter.is_some() {
                    return Err(DeError::DuplicateField);
                }
                record_delimiter = Some(d.content()?);
                Ok(())
            }
            _ => Err(DeError::UnexpectedTagName),
        })?;
        Ok(Self { record_delimiter })
    }
}
impl SerializeContent for JSONType {
    fn serialize_content<W: Write>(&self, s: &mut Serializer<W>) -> SerResult {
        self.as_str().serialize_content(s)
    }
}
impl<'xml> DeserializeContent<'xml> for JSONType {
    fn deserialize_content(d: &mut Deserializer<'xml>) -> DeResult<Self> {
        d.text(|t| {
            let b: &[u8] = &t;
            match b {
                b"DOCUMENT" => Ok(Self::from_static(JSONType::DOCUMENT)),
                b"LINES" => Ok(Self::from_static(JSONType::LINES)),
                _ => Ok(Self::from(t.unescape().map_err(DeError::InvalidXml)?.into_owned())),
            }
        })
    }
}
impl SerializeContent for LambdaFunctionConfiguration {
    fn serialize_content<W: Write>(&self, s: &mut Serializer<W>) -> SerResult {
        {
            let iter = &self.events;
            s.flattened_list("Event", iter)?;
        }
        if let Some(ref val) = self.filter {
            s.content("Filter", val)?;
        }
        if let Some(ref val) = self.id {
            s.content("Id", val)?;
        }
        s.content("CloudFunction", &self.lambda_function_arn)?;
        Ok(())
    }
}

impl<'xml> DeserializeContent<'xml> for LambdaFunctionConfiguration {
    fn deserialize_content(d: &mut Deserializer<'xml>) -> DeResult<Self> {
        let mut events: Option<EventList> = None;
        let mut filter: Option<NotificationConfigurationFilter> = None;
        let mut id: Option<NotificationId> = None;
        let mut lambda_function_arn: Option<LambdaFunctionArn> = None;
        d.for_each_element(|d, x| match x {
            b"Event" => {
                let ans: Event = d.content()?;
                events.get_or_insert_with(List::new).push(ans);
                Ok(())
            }
            b"Filter" => {
                if filter.is_some() {
                    return Err(DeError::DuplicateField);
                }
                filter = Some(d.content()?);
                Ok(())
            }
            b"Id" => {
                if id.is_some() {
                    return Err(DeError::DuplicateField);
                }
                id = Some(d.content()?);
                Ok(())
            }
            b"CloudFunction" => {
                if lambda_function_arn.is_some() {
                    return Err(DeError::DuplicateField);
                }
                lambda_function_arn = Some(d.content()?);
                Ok(())
            }
            _ => Err(DeError::UnexpectedTagName),
        })?;
        Ok(Self {
            events: events.ok_or(DeError::MissingField)?,
            filter,
            id,
            lambda_function_arn: lambda_function_arn.ok_or(DeError::MissingField)?,
        })
    }
}
impl SerializeContent for LifecycleExpiration {
    fn serialize_content<W: Write>(&self, s: &mut Serializer<W>) -> SerResult {
        if let Some(ref val) = self.date {
            s.timestamp("Date", val, TimestampFormat::DateTime)?;
        }
        if let Some(ref val) = self.days {
            s.content("Days", val)?;
        }
        if let Some(ref val) = self.expired_object_delete_marker {
            s.content("ExpiredObjectDeleteMarker", val)?;
        }
        Ok(())
    }
}

impl<'xml> DeserializeContent<'xml> for LifecycleExpiration {
    fn deserialize_content(d: &mut Deserializer<'xml>) -> DeResult<Self> {
        let mut date: Option<Date> = None;
        let mut days: Option<Days> = None;
        let mut expired_object_delete_marker: Option<ExpiredObjectDeleteMarker> = None;
        d.for_each_element(|d, x| match x {
            b"Date" => {
                if date.is_some() {
                    return Err(DeError::DuplicateField);
                }
                date = Some(d.timestamp(TimestampFormat::DateTime)?);
                Ok(())
            }
            b"Days" => {
                if days.is_some() {
                    return Err(DeError::DuplicateField);
                }
                days = Some(d.content()?);
                Ok(())
            }
            b"ExpiredObjectDeleteMarker" => {
                if expired_object_delete_marker.is_some() {
                    return Err(DeError::DuplicateField);
                }
                expired_object_delete_marker = Some(d.content()?);
                Ok(())
            }
            _ => Err(DeError::UnexpectedTagName),
        })?;
        Ok(Self {
            date,
            days,
            expired_object_delete_marker,
        })
    }
}
impl SerializeContent for LifecycleRule {
    fn serialize_content<W: Write>(&self, s: &mut Serializer<W>) -> SerResult {
        if let Some(ref val) = self.abort_incomplete_multipart_upload {
            s.content("AbortIncompleteMultipartUpload", val)?;
        }
        if let Some(ref val) = self.expiration {
            s.content("Expiration", val)?;
        }
        if let Some(ref val) = self.filter {
            s.content("Filter", val)?;
        }
        if let Some(ref val) = self.id {
            s.content("ID", val)?;
        }
        if let Some(ref val) = self.noncurrent_version_expiration {
            s.content("NoncurrentVersionExpiration", val)?;
        }
        if let Some(iter) = &self.noncurrent_version_transitions {
            s.flattened_list("NoncurrentVersionTransition", iter)?;
        }
        if let Some(ref val) = self.prefix {
            s.content("Prefix", val)?;
        }
        s.content("Status", &self.status)?;
        if let Some(iter) = &self.transitions {
            s.flattened_list("Transition", iter)?;
        }
        Ok(())
    }
}

impl<'xml> DeserializeContent<'xml> for LifecycleRule {
    fn deserialize_content(d: &mut Deserializer<'xml>) -> DeResult<Self> {
        let mut abort_incomplete_multipart_upload: Option<AbortIncompleteMultipartUpload> = None;
        let mut expiration: Option<LifecycleExpiration> = None;
        let mut filter: Option<LifecycleRuleFilter> = None;
        let mut id: Option<ID> = None;
        let mut noncurrent_version_expiration: Option<NoncurrentVersionExpiration> = None;
        let mut noncurrent_version_transitions: Option<NoncurrentVersionTransitionList> = None;
        let mut prefix: Option<Prefix> = None;
        let mut status: Option<ExpirationStatus> = None;
        let mut transitions: Option<TransitionList> = None;
        d.for_each_element(|d, x| match x {
            b"AbortIncompleteMultipartUpload" => {
                if abort_incomplete_multipart_upload.is_some() {
                    return Err(DeError::DuplicateField);
                }
                abort_incomplete_multipart_upload = Some(d.content()?);
                Ok(())
            }
            b"Expiration" => {
                if expiration.is_some() {
                    return Err(DeError::DuplicateField);
                }
                expiration = Some(d.content()?);
                Ok(())
            }
            b"Filter" => {
                if filter.is_some() {
                    return Err(DeError::DuplicateField);
                }
                filter = Some(d.content()?);
                Ok(())
            }
            b"ID" => {
                if id.is_some() {
                    return Err(DeError::DuplicateField);
                }
                id = Some(d.content()?);
                Ok(())
            }
            b"NoncurrentVersionExpiration" => {
                if noncurrent_version_expiration.is_some() {
                    return Err(DeError::DuplicateField);
                }
                noncurrent_version_expiration = Some(d.content()?);
                Ok(())
            }
            b"NoncurrentVersionTransition" => {
                let ans: NoncurrentVersionTransition = d.content()?;
                noncurrent_version_transitions.get_or_insert_with(List::new).push(ans);
                Ok(())
            }
            b"Prefix" => {
                if prefix.is_some() {
                    return Err(DeError::DuplicateField);
                }
                prefix = Some(d.content()?);
                Ok(())
            }
            b"Status" => {
                if status.is_some() {
                    return Err(DeError::DuplicateField);
                }
                status = Some(d.content()?);
                Ok(())
            }
            b"Transition" => {
                let ans: Transition = d.content()?;
                transitions.get_or_insert_with(List::new).push(ans);
                Ok(())
            }
            _ => Err(DeError::UnexpectedTagName),
        })?;
        Ok(Self {
            abort_incomplete_multipart_upload,
            expiration,
            filter,
            id,
            noncurrent_version_expiration,
            noncurrent_version_transitions,
            prefix,
            status: status.ok_or(DeError::MissingField)?,
            transitions,
        })
    }
}
impl SerializeContent for LifecycleRuleAndOperator {
    fn serialize_content<W: Write>(&self, s: &mut Serializer<W>) -> SerResult {
        if let Some(ref val) = self.object_size_greater_than {
            s.content("ObjectSizeGreaterThan", val)?;
        }
        if let Some(ref val) = self.object_size_less_than {
            s.content("ObjectSizeLessThan", val)?;
        }
        if let Some(ref val) = self.prefix {
            s.content("Prefix", val)?;
        }
        if let Some(iter) = &self.tags {
            s.flattened_list("Tag", iter)?;
        }
        Ok(())
    }
}

impl<'xml> DeserializeContent<'xml> for LifecycleRuleAndOperator {
    fn deserialize_content(d: &mut Deserializer<'xml>) -> DeResult<Self> {
        let mut object_size_greater_than: Option<ObjectSizeGreaterThanBytes> = None;
        let mut object_size_less_than: Option<ObjectSizeLessThanBytes> = None;
        let mut prefix: Option<Prefix> = None;
        let mut tags: Option<TagSet> = None;
        d.for_each_element(|d, x| match x {
            b"ObjectSizeGreaterThan" => {
                if object_size_greater_than.is_some() {
                    return Err(DeError::DuplicateField);
                }
                object_size_greater_than = Some(d.content()?);
                Ok(())
            }
            b"ObjectSizeLessThan" => {
                if object_size_less_than.is_some() {
                    return Err(DeError::DuplicateField);
                }
                object_size_less_than = Some(d.content()?);
                Ok(())
            }
            b"Prefix" => {
                if prefix.is_some() {
                    return Err(DeError::DuplicateField);
                }
                prefix = Some(d.content()?);
                Ok(())
            }
            b"Tag" => {
                let ans: Tag = d.content()?;
                tags.get_or_insert_with(List::new).push(ans);
                Ok(())
            }
            _ => Err(DeError::UnexpectedTagName),
        })?;
        Ok(Self {
            object_size_greater_than,
            object_size_less_than,
            prefix,
            tags,
        })
    }
}
impl SerializeContent for LifecycleRuleFilter {
    fn serialize_content<W: Write>(&self, s: &mut Serializer<W>) -> SerResult {
        if let Some(ref val) = self.and {
            s.content("And", val)?;
        }
        if let Some(ref val) = self.object_size_greater_than {
            s.content("ObjectSizeGreaterThan", val)?;
        }
        if let Some(ref val) = self.object_size_less_than {
            s.content("ObjectSizeLessThan", val)?;
        }
        if let Some(ref val) = self.prefix {
            s.content("Prefix", val)?;
        }
        if let Some(ref val) = self.tag {
            s.content("Tag", val)?;
        }
        Ok(())
    }
}

impl<'xml> DeserializeContent<'xml> for LifecycleRuleFilter {
    fn deserialize_content(d: &mut Deserializer<'xml>) -> DeResult<Self> {
        let mut and: Option<LifecycleRuleAndOperator> = None;
        let mut object_size_greater_than: Option<ObjectSizeGreaterThanBytes> = None;
        let mut object_size_less_than: Option<ObjectSizeLessThanBytes> = None;
        let mut prefix: Option<Prefix> = None;
        let mut tag: Option<Tag> = None;
        d.for_each_element(|d, x| match x {
            b"And" => {
                if and.is_some() {
                    return Err(DeError::DuplicateField);
                }
                and = Some(d.content()?);
                Ok(())
            }
            b"ObjectSizeGreaterThan" => {
                if object_size_greater_than.is_some() {
                    return Err(DeError::DuplicateField);
                }
                object_size_greater_than = Some(d.content()?);
                Ok(())
            }
            b"ObjectSizeLessThan" => {
                if object_size_less_than.is_some() {
                    return Err(DeError::DuplicateField);
                }
                object_size_less_than = Some(d.content()?);
                Ok(())
            }
            b"Prefix" => {
                if prefix.is_some() {
                    return Err(DeError::DuplicateField);
                }
                prefix = Some(d.content()?);
                Ok(())
            }
            b"Tag" => {
                if tag.is_some() {
                    return Err(DeError::DuplicateField);
                }
                tag = Some(d.content()?);
                Ok(())
            }
            _ => Err(DeError::UnexpectedTagName),
        })?;
        Ok(Self {
            and,
            cached_tags: CachedTags::default(),
            object_size_greater_than,
            object_size_less_than,
            prefix,
            tag,
        })
    }
}
impl SerializeContent for ListBucketAnalyticsConfigurationsOutput {
    fn serialize_content<W: Write>(&self, s: &mut Serializer<W>) -> SerResult {
        if let Some(iter) = &self.analytics_configuration_list {
            s.flattened_list("AnalyticsConfiguration", iter)?;
        }
        if let Some(ref val) = self.continuation_token {
            s.content("ContinuationToken", val)?;
        }
        if let Some(ref val) = self.is_truncated {
            s.content("IsTruncated", val)?;
        }
        if let Some(ref val) = self.next_continuation_token {
            s.content("NextContinuationToken", val)?;
        }
        Ok(())
    }
}

impl<'xml> DeserializeContent<'xml> for ListBucketAnalyticsConfigurationsOutput {
    fn deserialize_content(d: &mut Deserializer<'xml>) -> DeResult<Self> {
        let mut analytics_configuration_list: Option<AnalyticsConfigurationList> = None;
        let mut continuation_token: Option<Token> = None;
        let mut is_truncated: Option<IsTruncated> = None;
        let mut next_continuation_token: Option<NextToken> = None;
        d.for_each_element(|d, x| match x {
            b"AnalyticsConfiguration" => {
                let ans: AnalyticsConfiguration = d.content()?;
                analytics_configuration_list.get_or_insert_with(List::new).push(ans);
                Ok(())
            }
            b"ContinuationToken" => {
                if continuation_token.is_some() {
                    return Err(DeError::DuplicateField);
                }
                continuation_token = Some(d.content()?);
                Ok(())
            }
            b"IsTruncated" => {
                if is_truncated.is_some() {
                    return Err(DeError::DuplicateField);
                }
                is_truncated = Some(d.content()?);
                Ok(())
            }
            b"NextContinuationToken" => {
                if next_continuation_token.is_some() {
                    return Err(DeError::DuplicateField);
                }
                next_continuation_token = Some(d.content()?);
                Ok(())
            }
            _ => Err(DeError::UnexpectedTagName),
        })?;
        Ok(Self {
            analytics_configuration_list,
            continuation_token,
            is_truncated,
            next_continuation_token,
        })
    }
}
impl SerializeContent for ListBucketIntelligentTieringConfigurationsOutput {
    fn serialize_content<W: Write>(&self, s: &mut Serializer<W>) -> SerResult {
        if let Some(ref val) = self.continuation_token {
            s.content("ContinuationToken", val)?;
        }
        if let Some(iter) = &self.intelligent_tiering_configuration_list {
            s.flattened_list("IntelligentTieringConfiguration", iter)?;
        }
        if let Some(ref val) = self.is_truncated {
            s.content("IsTruncated", val)?;
        }
        if let Some(ref val) = self.next_continuation_token {
            s.content("NextContinuationToken", val)?;
        }
        Ok(())
    }
}

impl<'xml> DeserializeContent<'xml> for ListBucketIntelligentTieringConfigurationsOutput {
    fn deserialize_content(d: &mut Deserializer<'xml>) -> DeResult<Self> {
        let mut continuation_token: Option<Token> = None;
        let mut intelligent_tiering_configuration_list: Option<IntelligentTieringConfigurationList> = None;
        let mut is_truncated: Option<IsTruncated> = None;
        let mut next_continuation_token: Option<NextToken> = None;
        d.for_each_element(|d, x| match x {
            b"ContinuationToken" => {
                if continuation_token.is_some() {
                    return Err(DeError::DuplicateField);
                }
                continuation_token = Some(d.content()?);
                Ok(())
            }
            b"IntelligentTieringConfiguration" => {
                let ans: IntelligentTieringConfiguration = d.content()?;
                intelligent_tiering_configuration_list.get_or_insert_with(List::new).push(ans);
                Ok(())
            }
            b"IsTruncated" => {
                if is_truncated.is_some() {
                    return Err(DeError::DuplicateField);
                }
                is_truncated = Some(d.content()?);
                Ok(())
            }
            b"NextContinuationToken" => {
                if next_continuation_token.is_some() {
                    return Err(DeError::DuplicateField);
                }
                next_continuation_token = Some(d.content()?);
                Ok(())
            }
            _ => Err(DeError::UnexpectedTagName),
        })?;
        Ok(Self {
            continuation_token,
            intelligent_tiering_configuration_list,
            is_truncated,
            next_continuation_token,
        })
    }
}
impl SerializeContent for ListBucketInventoryConfigurationsOutput {
    fn serialize_content<W: Write>(&self, s: &mut Serializer<W>) -> SerResult {
        if let Some(ref val) = self.continuation_token {
            s.content("ContinuationToken", val)?;
        }
        if let Some(iter) = &self.inventory_configuration_list {
            s.flattened_list("InventoryConfiguration", iter)?;
        }
        if let Some(ref val) = self.is_truncated {
            s.content("IsTruncated", val)?;
        }
        if let Some(ref val) = self.next_continuation_token {
            s.content("NextContinuationToken", val)?;
        }
        Ok(())
    }
}

impl<'xml> DeserializeContent<'xml> for ListBucketInventoryConfigurationsOutput {
    fn deserialize_content(d: &mut Deserializer<'xml>) -> DeResult<Self> {
        let mut continuation_token: Option<Token> = None;
        let mut inventory_configuration_list: Option<InventoryConfigurationList> = None;
        let mut is_truncated: Option<IsTruncated> = None;
        let mut next_continuation_token: Option<NextToken> = None;
        d.for_each_element(|d, x| match x {
            b"ContinuationToken" => {
                if continuation_token.is_some() {
                    return Err(DeError::DuplicateField);
                }
                continuation_token = Some(d.content()?);
                Ok(())
            }
            b"InventoryConfiguration" => {
                let ans: InventoryConfiguration = d.content()?;
                inventory_configuration_list.get_or_insert_with(List::new).push(ans);
                Ok(())
            }
            b"IsTruncated" => {
                if is_truncated.is_some() {
                    return Err(DeError::DuplicateField);
                }
                is_truncated = Some(d.content()?);
                Ok(())
            }
            b"NextContinuationToken" => {
                if next_continuation_token.is_some() {
                    return Err(DeError::DuplicateField);
                }
                next_continuation_token = Some(d.content()?);
                Ok(())
            }
            _ => Err(DeError::UnexpectedTagName),
        })?;
        Ok(Self {
            continuation_token,
            inventory_configuration_list,
            is_truncated,
            next_continuation_token,
        })
    }
}
impl SerializeContent for ListBucketMetricsConfigurationsOutput {
    fn serialize_content<W: Write>(&self, s: &mut Serializer<W>) -> SerResult {
        if let Some(ref val) = self.continuation_token {
            s.content("ContinuationToken", val)?;
        }
        if let Some(ref val) = self.is_truncated {
            s.content("IsTruncated", val)?;
        }
        if let Some(iter) = &self.metrics_configuration_list {
            s.flattened_list("MetricsConfiguration", iter)?;
        }
        if let Some(ref val) = self.next_continuation_token {
            s.content("NextContinuationToken", val)?;
        }
        Ok(())
    }
}

impl<'xml> DeserializeContent<'xml> for ListBucketMetricsConfigurationsOutput {
    fn deserialize_content(d: &mut Deserializer<'xml>) -> DeResult<Self> {
        let mut continuation_token: Option<Token> = None;
        let mut is_truncated: Option<IsTruncated> = None;
        let mut metrics_configuration_list: Option<MetricsConfigurationList> = None;
        let mut next_continuation_token: Option<NextToken> = None;
        d.for_each_element(|d, x| match x {
            b"ContinuationToken" => {
                if continuation_token.is_some() {
                    return Err(DeError::DuplicateField);
                }
                continuation_token = Some(d.content()?);
                Ok(())
            }
            b"IsTruncated" => {
                if is_truncated.is_some() {
                    return Err(DeError::DuplicateField);
                }
                is_truncated = Some(d.content()?);
                Ok(())
            }
            b"MetricsConfiguration" => {
                let ans: MetricsConfiguration = d.content()?;
                metrics_configuration_list.get_or_insert_with(List::new).push(ans);
                Ok(())
            }
            b"NextContinuationToken" => {
                if next_continuation_token.is_some() {
                    return Err(DeError::DuplicateField);
                }
                next_continuation_token = Some(d.content()?);
                Ok(())
            }
            _ => Err(DeError::UnexpectedTagName),
        })?;
        Ok(Self {
            continuation_token,
            is_truncated,
            metrics_configuration_list,
            next_continuation_token,
        })
    }
}
impl SerializeContent for ListBucketsOutput {
    fn serialize_content<W: Write>(&self, s: &mut Serializer<W>) -> SerResult {
        if let Some(iter) = &self.buckets {
            s.list("Buckets", "Bucket", iter)?;
        }
        if let Some(ref val) = self.continuation_token {
            s.content("ContinuationToken", val)?;
        }
        if let Some(ref val) = self.owner {
            s.content("Owner", val)?;
        }
        if let Some(ref val) = self.prefix {
            s.content("Prefix", val)?;
        }
        Ok(())
    }
}

impl<'xml> DeserializeContent<'xml> for ListBucketsOutput {
    fn deserialize_content(d: &mut Deserializer<'xml>) -> DeResult<Self> {
        let mut buckets: Option<Buckets> = None;
        let mut continuation_token: Option<NextToken> = None;
        let mut owner: Option<Owner> = None;
        let mut prefix: Option<Prefix> = None;
        d.for_each_element(|d, x| match x {
            b"Buckets" => {
                if buckets.is_some() {
                    return Err(DeError::DuplicateField);
                }
                buckets = Some(d.list_content("Bucket")?);
                Ok(())
            }
            b"ContinuationToken" => {
                if continuation_token.is_some() {
                    return Err(DeError::DuplicateField);
                }
                continuation_token = Some(d.content()?);
                Ok(())
            }
            b"Owner" => {
                if owner.is_some() {
                    return Err(DeError::DuplicateField);
                }
                owner = Some(d.content()?);
                Ok(())
            }
            b"Prefix" => {
                if prefix.is_some() {
                    return Err(DeError::DuplicateField);
                }
                prefix = Some(d.content()?);
                Ok(())
            }
            _ => Err(DeError::UnexpectedTagName),
        })?;
        Ok(Self {
            buckets,
            continuation_token,
            owner,
            prefix,
        })
    }
}
impl SerializeContent for ListMultipartUploadsOutput {
    fn serialize_content<W: Write>(&self, s: &mut Serializer<W>) -> SerResult {
        if let Some(ref val) = self.bucket {
            s.content("Bucket", val)?;
        }
        if let Some(iter) = &self.common_prefixes {
            s.flattened_list("CommonPrefixes", iter)?;
        }
        if let Some(ref val) = self.delimiter {
            s.content("Delimiter", val)?;
        }
        if let Some(ref val) = self.encoding_type {
            s.content("EncodingType", val)?;
        }
        if let Some(ref val) = self.is_truncated {
            s.content("IsTruncated", val)?;
        }
        if let Some(ref val) = self.key_marker {
            s.content("KeyMarker", val)?;
        }
        if let Some(ref val) = self.max_uploads {
            s.content("MaxUploads", val)?;
        }
        if let Some(ref val) = self.next_key_marker {
            s.content("NextKeyMarker", val)?;
        }
        if let Some(ref val) = self.next_upload_id_marker {
            s.content("NextUploadIdMarker", val)?;
        }
        if let Some(ref val) = self.prefix {
            s.content("Prefix", val)?;
        }
        if let Some(ref val) = self.upload_id_marker {
            s.content("UploadIdMarker", val)?;
        }
        if let Some(iter) = &self.uploads {
            s.flattened_list("Upload", iter)?;
        }
        Ok(())
    }
}

impl SerializeContent for ListObjectVersionsOutput {
    fn serialize_content<W: Write>(&self, s: &mut Serializer<W>) -> SerResult {
        if let Some(iter) = &self.common_prefixes {
            s.flattened_list("CommonPrefixes", iter)?;
        }
        if let Some(iter) = &self.delete_markers {
            s.flattened_list("DeleteMarker", iter)?;
        }
        if let Some(ref val) = self.delimiter {
            s.content("Delimiter", val)?;
        }
        if let Some(ref val) = self.encoding_type {
            s.content("EncodingType", val)?;
        }
        if let Some(ref val) = self.is_truncated {
            s.content("IsTruncated", val)?;
        }
        if let Some(ref val) = self.key_marker {
            s.content("KeyMarker", val)?;
        }
        if let Some(ref val) = self.max_keys {
            s.content("MaxKeys", val)?;
        }
        if let Some(ref val) = self.name {
            s.content("Name", val)?;
        }
        if let Some(ref val) = self.next_key_marker {
            s.content("NextKeyMarker", val)?;
        }
        if let Some(ref val) = self.next_version_id_marker {
            s.content("NextVersionIdMarker", val)?;
        }
        if let Some(ref val) = self.prefix {
            s.content("Prefix", val)?;
        }
        if let Some(ref val) = self.version_id_marker {
            s.content("VersionIdMarker", val)?;
        }
        if let Some(iter) = &self.versions {
            s.flattened_list("Version", iter)?;
        }
        Ok(())
    }
}

impl SerializeContent for ListObjectsOutput {
    fn serialize_content<W: Write>(&self, s: &mut Serializer<W>) -> SerResult {
        if let Some(iter) = &self.common_prefixes {
            s.flattened_list("CommonPrefixes", iter)?;
        }
        if let Some(iter) = &self.contents {
            s.flattened_list("Contents", iter)?;
        }
        if let Some(ref val) = self.delimiter {
            s.content("Delimiter", val)?;
        }
        if let Some(ref val) = self.encoding_type {
            s.content("EncodingType", val)?;
        }
        if let Some(ref val) = self.is_truncated {
            s.content("IsTruncated", val)?;
        }
        if let Some(ref val) = self.marker {
            s.content("Marker", val)?;
        }
        if let Some(ref val) = self.max_keys {
            s.content("MaxKeys", val)?;
        }
        if let Some(ref val) = self.name {
            s.content("Name", val)?;
        }
        if let Some(ref val) = self.next_marker {
            s.content("NextMarker", val)?;
        }
        if let Some(ref val) = self.prefix {
            s.content("Prefix", val)?;
        }
        Ok(())
    }
}

impl SerializeContent for ListObjectsV2Output {
    fn serialize_content<W: Write>(&self, s: &mut Serializer<W>) -> SerResult {
        if let Some(iter) = &self.common_prefixes {
            s.flattened_list("CommonPrefixes", iter)?;
        }
        if let Some(iter) = &self.contents {
            s.flattened_list("Contents", iter)?;
        }
        if let Some(ref val) = self.continuation_token {
            s.content("ContinuationToken", val)?;
        }
        if let Some(ref val) = self.delimiter {
            s.content("Delimiter", val)?;
        }
        if let Some(ref val) = self.encoding_type {
            s.content("EncodingType", val)?;
        }
        if let Some(ref val) = self.is_truncated {
            s.content("IsTruncated", val)?;
        }
        if let Some(ref val) = self.key_count {
            s.content("KeyCount", val)?;
        }
        if let Some(ref val) = self.max_keys {
            s.content("MaxKeys", val)?;
        }
        if let Some(ref val) = self.name {
            s.content("Name", val)?;
        }
        if let Some(ref val) = self.next_continuation_token {
            s.content("NextContinuationToken", val)?;
        }
        if let Some(ref val) = self.prefix {
            s.content("Prefix", val)?;
        }
        if let Some(ref val) = self.start_after {
            s.content("StartAfter", val)?;
        }
        Ok(())
    }
}

impl SerializeContent for ListPartsOutput {
    fn serialize_content<W: Write>(&self, s: &mut Serializer<W>) -> SerResult {
        if let Some(ref val) = self.bucket {
            s.content("Bucket", val)?;
        }
        if let Some(ref val) = self.checksum_algorithm {
            s.content("ChecksumAlgorithm", val)?;
        }
        if let Some(ref val) = self.checksum_type {
            s.content("ChecksumType", val)?;
        }
        if let Some(ref val) = self.initiator {
            s.content("Initiator", val)?;
        }
        if let Some(ref val) = self.is_truncated {
            s.content("IsTruncated", val)?;
        }
        if let Some(ref val) = self.key {
            s.content("Key", val)?;
        }
        if let Some(ref val) = self.max_parts {
            s.content("MaxParts", val)?;
        }
        if let Some(ref val) = self.next_part_number_marker {
            s.content("NextPartNumberMarker", val)?;
        }
        if let Some(ref val) = self.owner {
            s.content("Owner", val)?;
        }
        if let Some(ref val) = self.part_number_marker {
            s.content("PartNumberMarker", val)?;
        }
        if let Some(iter) = &self.parts {
            s.flattened_list("Part", iter)?;
        }
        if let Some(ref val) = self.storage_class {
            s.content("StorageClass", val)?;
        }
        if let Some(ref val) = self.upload_id {
            s.content("UploadId", val)?;
        }
        Ok(())
    }
}

impl SerializeContent for LocationInfo {
    fn serialize_content<W: Write>(&self, s: &mut Serializer<W>) -> SerResult {
        if let Some(ref val) = self.name {
            s.content("Name", val)?;
        }
        if let Some(ref val) = self.type_ {
            s.content("Type", val)?;
        }
        Ok(())
    }
}

impl<'xml> DeserializeContent<'xml> for LocationInfo {
    fn deserialize_content(d: &mut Deserializer<'xml>) -> DeResult<Self> {
        let mut name: Option<LocationNameAsString> = None;
        let mut type_: Option<LocationType> = None;
        d.for_each_element(|d, x| match x {
            b"Name" => {
                if name.is_some() {
                    return Err(DeError::DuplicateField);
                }
                name = Some(d.content()?);
                Ok(())
            }
            b"Type" => {
                if type_.is_some() {
                    return Err(DeError::DuplicateField);
                }
                type_ = Some(d.content()?);
                Ok(())
            }
            _ => Err(DeError::UnexpectedTagName),
        })?;
        Ok(Self { name, type_ })
    }
}
impl SerializeContent for LocationType {
    fn serialize_content<W: Write>(&self, s: &mut Serializer<W>) -> SerResult {
        self.as_str().serialize_content(s)
    }
}
impl<'xml> DeserializeContent<'xml> for LocationType {
    fn deserialize_content(d: &mut Deserializer<'xml>) -> DeResult<Self> {
        d.text(|t| {
            let b: &[u8] = &t;
            match b {
                b"AvailabilityZone" => Ok(Self::from_static(LocationType::AVAILABILITY_ZONE)),
                b"LocalZone" => Ok(Self::from_static(LocationType::LOCAL_ZONE)),
                _ => Ok(Self::from(t.unescape().map_err(DeError::InvalidXml)?.into_owned())),
            }
        })
    }
}
impl SerializeContent for LoggingEnabled {
    fn serialize_content<W: Write>(&self, s: &mut Serializer<W>) -> SerResult {
        s.content("TargetBucket", &self.target_bucket)?;
        if let Some(iter) = &self.target_grants {
            s.list("TargetGrants", "Grant", iter)?;
        }
        if let Some(ref val) = self.target_object_key_format {
            s.content("TargetObjectKeyFormat", val)?;
        }
        s.content("TargetPrefix", &self.target_prefix)?;
        Ok(())
    }
}

impl<'xml> DeserializeContent<'xml> for LoggingEnabled {
    fn deserialize_content(d: &mut Deserializer<'xml>) -> DeResult<Self> {
        let mut target_bucket: Option<TargetBucket> = None;
        let mut target_grants: Option<TargetGrants> = None;
        let mut target_object_key_format: Option<TargetObjectKeyFormat> = None;
        let mut target_prefix: Option<TargetPrefix> = None;
        d.for_each_element(|d, x| match x {
            b"TargetBucket" => {
                if target_bucket.is_some() {
                    return Err(DeError::DuplicateField);
                }
                target_bucket = Some(d.content()?);
                Ok(())
            }
            b"TargetGrants" => {
                if target_grants.is_some() {
                    return Err(DeError::DuplicateField);
                }
                target_grants = Some(d.list_content("Grant")?);
                Ok(())
            }
            b"TargetObjectKeyFormat" => {
                if target_object_key_format.is_some() {
                    return Err(DeError::DuplicateField);
                }
                target_object_key_format = Some(d.content()?);
                Ok(())
            }
            b"TargetPrefix" => {
                if target_prefix.is_some() {
                    return Err(DeError::DuplicateField);
                }
                target_prefix = Some(d.content()?);
                Ok(())
            }
            _ => Err(DeError::UnexpectedTagName),
        })?;
        Ok(Self {
            target_bucket: target_bucket.ok_or(DeError::MissingField)?,
            target_grants,
            target_object_key_format,
            target_prefix: target_prefix.ok_or(DeError::MissingField)?,
        })
    }
}
impl SerializeContent for MFADelete {
    fn serialize_content<W: Write>(&self, s: &mut Serializer<W>) -> SerResult {
        self.as_str().serialize_content(s)
    }
}
impl<'xml> DeserializeContent<'xml> for MFADelete {
    fn deserialize_content(d: &mut Deserializer<'xml>) -> DeResult<Self> {
        d.text(|t| {
            let b: &[u8] = &t;
            match b {
                b"Disabled" => Ok(Self::from_static(MFADelete::DISABLED)),
                b"Enabled" => Ok(Self::from_static(MFADelete::ENABLED)),
                _ => Ok(Self::from(t.unescape().map_err(DeError::InvalidXml)?.into_owned())),
            }
        })
    }
}
impl SerializeContent for MFADeleteStatus {
    fn serialize_content<W: Write>(&self, s: &mut Serializer<W>) -> SerResult {
        self.as_str().serialize_content(s)
    }
}
impl<'xml> DeserializeContent<'xml> for MFADeleteStatus {
    fn deserialize_content(d: &mut Deserializer<'xml>) -> DeResult<Self> {
        d.text(|t| {
            let b: &[u8] = &t;
            match b {
                b"Disabled" => Ok(Self::from_static(MFADeleteStatus::DISABLED)),
                b"Enabled" => Ok(Self::from_static(MFADeleteStatus::ENABLED)),
                _ => Ok(Self::from(t.unescape().map_err(DeError::InvalidXml)?.into_owned())),
            }
        })
    }
}
impl SerializeContent for MetadataEntry {
    fn serialize_content<W: Write>(&self, s: &mut Serializer<W>) -> SerResult {
        if let Some(ref val) = self.name {
            s.content("Name", val)?;
        }
        if let Some(ref val) = self.value {
            s.content("Value", val)?;
        }
        Ok(())
    }
}

impl<'xml> DeserializeContent<'xml> for MetadataEntry {
    fn deserialize_content(d: &mut Deserializer<'xml>) -> DeResult<Self> {
        let mut name: Option<MetadataKey> = None;
        let mut value: Option<MetadataValue> = None;
        d.for_each_element(|d, x| match x {
            b"Name" => {
                if name.is_some() {
                    return Err(DeError::DuplicateField);
                }
                name = Some(d.content()?);
                Ok(())
            }
            b"Value" => {
                if value.is_some() {
                    return Err(DeError::DuplicateField);
                }
                value = Some(d.content()?);
                Ok(())
            }
            _ => Err(DeError::UnexpectedTagName),
        })?;
        Ok(Self { name, value })
    }
}
impl SerializeContent for MetadataTableConfiguration {
    fn serialize_content<W: Write>(&self, s: &mut Serializer<W>) -> SerResult {
        s.content("S3TablesDestination", &self.s3_tables_destination)?;
        Ok(())
    }
}

impl<'xml> DeserializeContent<'xml> for MetadataTableConfiguration {
    fn deserialize_content(d: &mut Deserializer<'xml>) -> DeResult<Self> {
        let mut s3_tables_destination: Option<S3TablesDestination> = None;
        d.for_each_element(|d, x| match x {
            b"S3TablesDestination" => {
                if s3_tables_destination.is_some() {
                    return Err(DeError::DuplicateField);
                }
                s3_tables_destination = Some(d.content()?);
                Ok(())
            }
            _ => Err(DeError::UnexpectedTagName),
        })?;
        Ok(Self {
            s3_tables_destination: s3_tables_destination.ok_or(DeError::MissingField)?,
        })
    }
}
impl SerializeContent for MetadataTableConfigurationResult {
    fn serialize_content<W: Write>(&self, s: &mut Serializer<W>) -> SerResult {
        s.content("S3TablesDestinationResult", &self.s3_tables_destination_result)?;
        Ok(())
    }
}

impl<'xml> DeserializeContent<'xml> for MetadataTableConfigurationResult {
    fn deserialize_content(d: &mut Deserializer<'xml>) -> DeResult<Self> {
        let mut s3_tables_destination_result: Option<S3TablesDestinationResult> = None;
        d.for_each_element(|d, x| match x {
            b"S3TablesDestinationResult" => {
                if s3_tables_destination_result.is_some() {
                    return Err(DeError::DuplicateField);
                }
                s3_tables_destination_result = Some(d.content()?);
                Ok(())
            }
            _ => Err(DeError::UnexpectedTagName),
        })?;
        Ok(Self {
            s3_tables_destination_result: s3_tables_destination_result.ok_or(DeError::MissingField)?,
        })
    }
}
impl SerializeContent for Metrics {
    fn serialize_content<W: Write>(&self, s: &mut Serializer<W>) -> SerResult {
        if let Some(ref val) = self.event_threshold {
            s.content("EventThreshold", val)?;
        }
        s.content("Status", &self.status)?;
        Ok(())
    }
}

impl<'xml> DeserializeContent<'xml> for Metrics {
    fn deserialize_content(d: &mut Deserializer<'xml>) -> DeResult<Self> {
        let mut event_threshold: Option<ReplicationTimeValue> = None;
        let mut status: Option<MetricsStatus> = None;
        d.for_each_element(|d, x| match x {
            b"EventThreshold" => {
                if event_threshold.is_some() {
                    return Err(DeError::DuplicateField);
                }
                event_threshold = Some(d.content()?);
                Ok(())
            }
            b"Status" => {
                if status.is_some() {
                    return Err(DeError::DuplicateField);
                }
                status = Some(d.content()?);
                Ok(())
            }
            _ => Err(DeError::UnexpectedTagName),
        })?;
        Ok(Self {
            event_threshold,
            status: status.ok_or(DeError::MissingField)?,
        })
    }
}
impl SerializeContent for MetricsAndOperator {
    fn serialize_content<W: Write>(&self, s: &mut Serializer<W>) -> SerResult {
        if let Some(ref val) = self.access_point_arn {
            s.content("AccessPointArn", val)?;
        }
        if let Some(ref val) = self.prefix {
            s.content("Prefix", val)?;
        }
        if let Some(iter) = &self.tags {
            s.flattened_list("Tag", iter)?;
        }
        Ok(())
    }
}

impl<'xml> DeserializeContent<'xml> for MetricsAndOperator {
    fn deserialize_content(d: &mut Deserializer<'xml>) -> DeResult<Self> {
        let mut access_point_arn: Option<AccessPointArn> = None;
        let mut prefix: Option<Prefix> = None;
        let mut tags: Option<TagSet> = None;
        d.for_each_element(|d, x| match x {
            b"AccessPointArn" => {
                if access_point_arn.is_some() {
                    return Err(DeError::DuplicateField);
                }
                access_point_arn = Some(d.content()?);
                Ok(())
            }
            b"Prefix" => {
                if prefix.is_some() {
                    return Err(DeError::DuplicateField);
                }
                prefix = Some(d.content()?);
                Ok(())
            }
            b"Tag" => {
                let ans: Tag = d.content()?;
                tags.get_or_insert_with(List::new).push(ans);
                Ok(())
            }
            _ => Err(DeError::UnexpectedTagName),
        })?;
        Ok(Self {
            access_point_arn,
            prefix,
            tags,
        })
    }
}
impl SerializeContent for MetricsConfiguration {
    fn serialize_content<W: Write>(&self, s: &mut Serializer<W>) -> SerResult {
        if let Some(ref val) = self.filter {
            s.content("Filter", val)?;
        }
        s.content("Id", &self.id)?;
        Ok(())
    }
}

impl<'xml> DeserializeContent<'xml> for MetricsConfiguration {
    fn deserialize_content(d: &mut Deserializer<'xml>) -> DeResult<Self> {
        let mut filter: Option<MetricsFilter> = None;
        let mut id: Option<MetricsId> = None;
        d.for_each_element(|d, x| match x {
            b"Filter" => {
                if filter.is_some() {
                    return Err(DeError::DuplicateField);
                }
                filter = Some(d.content()?);
                Ok(())
            }
            b"Id" => {
                if id.is_some() {
                    return Err(DeError::DuplicateField);
                }
                id = Some(d.content()?);
                Ok(())
            }
            _ => Err(DeError::UnexpectedTagName),
        })?;
        Ok(Self {
            filter,
            id: id.ok_or(DeError::MissingField)?,
        })
    }
}
impl SerializeContent for MetricsFilter {
    fn serialize_content<W: Write>(&self, s: &mut Serializer<W>) -> SerResult {
        match self {
            Self::AccessPointArn(x) => s.content("AccessPointArn", x),
            Self::And(x) => s.content("And", x),
            Self::Prefix(x) => s.content("Prefix", x),
            Self::Tag(x) => s.content("Tag", x),
        }
    }
}
impl<'xml> DeserializeContent<'xml> for MetricsFilter {
    fn deserialize_content(d: &mut Deserializer<'xml>) -> DeResult<Self> {
        d.element(|d, x| match x {
            b"AccessPointArn" => Ok(Self::AccessPointArn(d.content()?)),
            b"And" => Ok(Self::And(d.content()?)),
            b"Prefix" => Ok(Self::Prefix(d.content()?)),
            b"Tag" => Ok(Self::Tag(d.content()?)),
            _ => Err(DeError::UnexpectedTagName),
        })
    }
}
impl SerializeContent for MetricsStatus {
    fn serialize_content<W: Write>(&self, s: &mut Serializer<W>) -> SerResult {
        self.as_str().serialize_content(s)
    }
}
impl<'xml> DeserializeContent<'xml> for MetricsStatus {
    fn deserialize_content(d: &mut Deserializer<'xml>) -> DeResult<Self> {
        d.text(|t| {
            let b: &[u8] = &t;
            match b {
                b"Disabled" => Ok(Self::from_static(MetricsStatus::DISABLED)),
                b"Enabled" => Ok(Self::from_static(MetricsStatus::ENABLED)),
                _ => Ok(Self::from(t.unescape().map_err(DeError::InvalidXml)?.into_owned())),
            }
        })
    }
}
impl SerializeContent for MultipartUpload {
    fn serialize_content<W: Write>(&self, s: &mut Serializer<W>) -> SerResult {
        if let Some(ref val) = self.checksum_algorithm {
            s.content("ChecksumAlgorithm", val)?;
        }
        if let Some(ref val) = self.checksum_type {
            s.content("ChecksumType", val)?;
        }
        if let Some(ref val) = self.initiated {
            s.timestamp("Initiated", val, TimestampFormat::DateTime)?;
        }
        if let Some(ref val) = self.initiator {
            s.content("Initiator", val)?;
        }
        if let Some(ref val) = self.key {
            s.content("Key", val)?;
        }
        if let Some(ref val) = self.owner {
            s.content("Owner", val)?;
        }
        if let Some(ref val) = self.storage_class {
            s.content("StorageClass", val)?;
        }
        if let Some(ref val) = self.upload_id {
            s.content("UploadId", val)?;
        }
        Ok(())
    }
}

impl<'xml> DeserializeContent<'xml> for MultipartUpload {
    fn deserialize_content(d: &mut Deserializer<'xml>) -> DeResult<Self> {
        let mut checksum_algorithm: Option<ChecksumAlgorithm> = None;
        let mut checksum_type: Option<ChecksumType> = None;
        let mut initiated: Option<Initiated> = None;
        let mut initiator: Option<Initiator> = None;
        let mut key: Option<ObjectKey> = None;
        let mut owner: Option<Owner> = None;
        let mut storage_class: Option<StorageClass> = None;
        let mut upload_id: Option<MultipartUploadId> = None;
        d.for_each_element(|d, x| match x {
            b"ChecksumAlgorithm" => {
                if checksum_algorithm.is_some() {
                    return Err(DeError::DuplicateField);
                }
                checksum_algorithm = Some(d.content()?);
                Ok(())
            }
            b"ChecksumType" => {
                if checksum_type.is_some() {
                    return Err(DeError::DuplicateField);
                }
                checksum_type = Some(d.content()?);
                Ok(())
            }
            b"Initiated" => {
                if initiated.is_some() {
                    return Err(DeError::DuplicateField);
                }
                initiated = Some(d.timestamp(TimestampFormat::DateTime)?);
                Ok(())
            }
            b"Initiator" => {
                if initiator.is_some() {
                    return Err(DeError::DuplicateField);
                }
                initiator = Some(d.content()?);
                Ok(())
            }
            b"Key" => {
                if key.is_some() {
                    return Err(DeError::DuplicateField);
                }
                key = Some(d.content()?);
                Ok(())
            }
            b"Owner" => {
                if owner.is_some() {
                    return Err(DeError::DuplicateField);
                }
                owner = Some(d.content()?);
                Ok(())
            }
            b"StorageClass" => {
                if storage_class.is_some() {
                    return Err(DeError::DuplicateField);
                }
                storage_class = Some(d.content()?);
                Ok(())
            }
            b"UploadId" => {
                if upload_id.is_some() {
                    return Err(DeError::DuplicateField);
                }
                upload_id = Some(d.content()?);
                Ok(())
            }
            _ => Err(DeError::UnexpectedTagName),
        })?;
        Ok(Self {
            checksum_algorithm,
            checksum_type,
            initiated,
            initiator,
            key,
            owner,
            storage_class,
            upload_id,
        })
    }
}
impl SerializeContent for NoncurrentVersionExpiration {
    fn serialize_content<W: Write>(&self, s: &mut Serializer<W>) -> SerResult {
        if let Some(ref val) = self.newer_noncurrent_versions {
            s.content("NewerNoncurrentVersions", val)?;
        }
        if let Some(ref val) = self.noncurrent_days {
            s.content("NoncurrentDays", val)?;
        }
        Ok(())
    }
}

impl<'xml> DeserializeContent<'xml> for NoncurrentVersionExpiration {
    fn deserialize_content(d: &mut Deserializer<'xml>) -> DeResult<Self> {
        let mut newer_noncurrent_versions: Option<VersionCount> = None;
        let mut noncurrent_days: Option<Days> = None;
        d.for_each_element(|d, x| match x {
            b"NewerNoncurrentVersions" => {
                if newer_noncurrent_versions.is_some() {
                    return Err(DeError::DuplicateField);
                }
                newer_noncurrent_versions = Some(d.content()?);
                Ok(())
            }
            b"NoncurrentDays" => {
                if noncurrent_days.is_some() {
                    return Err(DeError::DuplicateField);
                }
                noncurrent_days = Some(d.content()?);
                Ok(())
            }
            _ => Err(DeError::UnexpectedTagName),
        })?;
        Ok(Self {
            newer_noncurrent_versions,
            noncurrent_days,
        })
    }
}
impl SerializeContent for NoncurrentVersionTransition {
    fn serialize_content<W: Write>(&self, s: &mut Serializer<W>) -> SerResult {
        if let Some(ref val) = self.newer_noncurrent_versions {
            s.content("NewerNoncurrentVersions", val)?;
        }
        if let Some(ref val) = self.noncurrent_days {
            s.content("NoncurrentDays", val)?;
        }
        if let Some(ref val) = self.storage_class {
            s.content("StorageClass", val)?;
        }
        Ok(())
    }
}

impl<'xml> DeserializeContent<'xml> for NoncurrentVersionTransition {
    fn deserialize_content(d: &mut Deserializer<'xml>) -> DeResult<Self> {
        let mut newer_noncurrent_versions: Option<VersionCount> = None;
        let mut noncurrent_days: Option<Days> = None;
        let mut storage_class: Option<TransitionStorageClass> = None;
        d.for_each_element(|d, x| match x {
            b"NewerNoncurrentVersions" => {
                if newer_noncurrent_versions.is_some() {
                    return Err(DeError::DuplicateField);
                }
                newer_noncurrent_versions = Some(d.content()?);
                Ok(())
            }
            b"NoncurrentDays" => {
                if noncurrent_days.is_some() {
                    return Err(DeError::DuplicateField);
                }
                noncurrent_days = Some(d.content()?);
                Ok(())
            }
            b"StorageClass" => {
                if storage_class.is_some() {
                    return Err(DeError::DuplicateField);
                }
                storage_class = Some(d.content()?);
                Ok(())
            }
            _ => Err(DeError::UnexpectedTagName),
        })?;
        Ok(Self {
            newer_noncurrent_versions,
            noncurrent_days,
            storage_class,
        })
    }
}
impl SerializeContent for NotificationConfiguration {
    fn serialize_content<W: Write>(&self, s: &mut Serializer<W>) -> SerResult {
        if let Some(ref val) = self.event_bridge_configuration {
            s.content("EventBridgeConfiguration", val)?;
        }
        if let Some(iter) = &self.lambda_function_configurations {
            s.flattened_list("CloudFunctionConfiguration", iter)?;
        }
        if let Some(iter) = &self.queue_configurations {
            s.flattened_list("QueueConfiguration", iter)?;
        }
        if let Some(iter) = &self.topic_configurations {
            s.flattened_list("TopicConfiguration", iter)?;
        }
        Ok(())
    }
}

impl<'xml> DeserializeContent<'xml> for NotificationConfiguration {
    fn deserialize_content(d: &mut Deserializer<'xml>) -> DeResult<Self> {
        let mut event_bridge_configuration: Option<EventBridgeConfiguration> = None;
        let mut lambda_function_configurations: Option<LambdaFunctionConfigurationList> = None;
        let mut queue_configurations: Option<QueueConfigurationList> = None;
        let mut topic_configurations: Option<TopicConfigurationList> = None;
        d.for_each_element(|d, x| match x {
            b"EventBridgeConfiguration" => {
                if event_bridge_configuration.is_some() {
                    return Err(DeError::DuplicateField);
                }
                event_bridge_configuration = Some(d.content()?);
                Ok(())
            }
            b"CloudFunctionConfiguration" => {
                let ans: LambdaFunctionConfiguration = d.content()?;
                lambda_function_configurations.get_or_insert_with(List::new).push(ans);
                Ok(())
            }
            b"QueueConfiguration" => {
                let ans: QueueConfiguration = d.content()?;
                queue_configurations.get_or_insert_with(List::new).push(ans);
                Ok(())
            }
            b"TopicConfiguration" => {
                let ans: TopicConfiguration = d.content()?;
                topic_configurations.get_or_insert_with(List::new).push(ans);
                Ok(())
            }
            _ => Err(DeError::UnexpectedTagName),
        })?;
        Ok(Self {
            event_bridge_configuration,
            lambda_function_configurations,
            queue_configurations,
            topic_configurations,
        })
    }
}
impl SerializeContent for NotificationConfigurationFilter {
    fn serialize_content<W: Write>(&self, s: &mut Serializer<W>) -> SerResult {
        if let Some(ref val) = self.key {
            s.content("S3Key", val)?;
        }
        Ok(())
    }
}

impl<'xml> DeserializeContent<'xml> for NotificationConfigurationFilter {
    fn deserialize_content(d: &mut Deserializer<'xml>) -> DeResult<Self> {
        let mut key: Option<S3KeyFilter> = None;
        d.for_each_element(|d, x| match x {
            b"S3Key" => {
                if key.is_some() {
                    return Err(DeError::DuplicateField);
                }
                key = Some(d.content()?);
                Ok(())
            }
            _ => Err(DeError::UnexpectedTagName),
        })?;
        Ok(Self { key })
    }
}
impl SerializeContent for Object {
    fn serialize_content<W: Write>(&self, s: &mut Serializer<W>) -> SerResult {
        if let Some(iter) = &self.checksum_algorithm {
            s.flattened_list("ChecksumAlgorithm", iter)?;
        }
        if let Some(ref val) = self.checksum_type {
            s.content("ChecksumType", val)?;
        }
        if let Some(ref val) = self.e_tag {
            s.content("ETag", val)?;
        }
        if let Some(ref val) = self.key {
            s.content("Key", val)?;
        }
        if let Some(ref val) = self.last_modified {
            s.timestamp("LastModified", val, TimestampFormat::DateTime)?;
        }
        if let Some(ref val) = self.owner {
            s.content("Owner", val)?;
        }
        if let Some(ref val) = self.restore_status {
            s.content("RestoreStatus", val)?;
        }
        if let Some(ref val) = self.size {
            s.content("Size", val)?;
        }
        if let Some(ref val) = self.storage_class {
            s.content("StorageClass", val)?;
        }
        Ok(())
    }
}

impl<'xml> DeserializeContent<'xml> for Object {
    fn deserialize_content(d: &mut Deserializer<'xml>) -> DeResult<Self> {
        let mut checksum_algorithm: Option<ChecksumAlgorithmList> = None;
        let mut checksum_type: Option<ChecksumType> = None;
        let mut e_tag: Option<ETag> = None;
        let mut key: Option<ObjectKey> = None;
        let mut last_modified: Option<LastModified> = None;
        let mut owner: Option<Owner> = None;
        let mut restore_status: Option<RestoreStatus> = None;
        let mut size: Option<Size> = None;
        let mut storage_class: Option<ObjectStorageClass> = None;
        d.for_each_element(|d, x| match x {
            b"ChecksumAlgorithm" => {
                let ans: ChecksumAlgorithm = d.content()?;
                checksum_algorithm.get_or_insert_with(List::new).push(ans);
                Ok(())
            }
            b"ChecksumType" => {
                if checksum_type.is_some() {
                    return Err(DeError::DuplicateField);
                }
                checksum_type = Some(d.content()?);
                Ok(())
            }
            b"ETag" => {
                if e_tag.is_some() {
                    return Err(DeError::DuplicateField);
                }
                e_tag = Some(d.content()?);
                Ok(())
            }
            b"Key" => {
                if key.is_some() {
                    return Err(DeError::DuplicateField);
                }
                key = Some(d.content()?);
                Ok(())
            }
            b"LastModified" => {
                if last_modified.is_some() {
                    return Err(DeError::DuplicateField);
                }
                last_modified = Some(d.timestamp(TimestampFormat::DateTime)?);
                Ok(())
            }
            b"Owner" => {
                if owner.is_some() {
                    return Err(DeError::DuplicateField);
                }
                owner = Some(d.content()?);
                Ok(())
            }
            b"RestoreStatus" => {
                if restore_status.is_some() {
                    return Err(DeError::DuplicateField);
                }
                restore_status = Some(d.content()?);
                Ok(())
            }
            b"Size" => {
                if size.is_some() {
                    return Err(DeError::DuplicateField);
                }
                size = Some(d.content()?);
                Ok(())
            }
            b"StorageClass" => {
                if storage_class.is_some() {
                    return Err(DeError::DuplicateField);
                }
                storage_class = Some(d.content()?);
                Ok(())
            }
            _ => Err(DeError::UnexpectedTagName),
        })?;
        Ok(Self {
            checksum_algorithm,
            checksum_type,
            e_tag,
            key,
            last_modified,
            owner,
            restore_status,
            size,
            storage_class,
        })
    }
}
impl SerializeContent for ObjectCannedACL {
    fn serialize_content<W: Write>(&self, s: &mut Serializer<W>) -> SerResult {
        self.as_str().serialize_content(s)
    }
}
impl<'xml> DeserializeContent<'xml> for ObjectCannedACL {
    fn deserialize_content(d: &mut Deserializer<'xml>) -> DeResult<Self> {
        d.text(|t| {
            let b: &[u8] = &t;
            match b {
                b"authenticated-read" => Ok(Self::from_static(ObjectCannedACL::AUTHENTICATED_READ)),
                b"aws-exec-read" => Ok(Self::from_static(ObjectCannedACL::AWS_EXEC_READ)),
                b"bucket-owner-full-control" => Ok(Self::from_static(ObjectCannedACL::BUCKET_OWNER_FULL_CONTROL)),
                b"bucket-owner-read" => Ok(Self::from_static(ObjectCannedACL::BUCKET_OWNER_READ)),
                b"private" => Ok(Self::from_static(ObjectCannedACL::PRIVATE)),
                b"public-read" => Ok(Self::from_static(ObjectCannedACL::PUBLIC_READ)),
                b"public-read-write" => Ok(Self::from_static(ObjectCannedACL::PUBLIC_READ_WRITE)),
                _ => Ok(Self::from(t.unescape().map_err(DeError::InvalidXml)?.into_owned())),
            }
        })
    }
}
impl SerializeContent for ObjectIdentifier {
    fn serialize_content<W: Write>(&self, s: &mut Serializer<W>) -> SerResult {
        if let Some(ref val) = self.e_tag {
            s.content("ETag", val)?;
        }
        s.content("Key", &self.key)?;
        if let Some(ref val) = self.last_modified_time {
            s.timestamp("LastModifiedTime", val, TimestampFormat::HttpDate)?;
        }
        if let Some(ref val) = self.size {
            s.content("Size", val)?;
        }
        if let Some(ref val) = self.version_id {
            s.content("VersionId", val)?;
        }
        Ok(())
    }
}

impl<'xml> DeserializeContent<'xml> for ObjectIdentifier {
    fn deserialize_content(d: &mut Deserializer<'xml>) -> DeResult<Self> {
        let mut e_tag: Option<ETag> = None;
        let mut key: Option<ObjectKey> = None;
        let mut last_modified_time: Option<LastModifiedTime> = None;
        let mut size: Option<Size> = None;
        let mut version_id: Option<ObjectVersionId> = None;
        d.for_each_element(|d, x| match x {
            b"ETag" => {
                if e_tag.is_some() {
                    return Err(DeError::DuplicateField);
                }
                e_tag = Some(d.content()?);
                Ok(())
            }
            b"Key" => {
                if key.is_some() {
                    return Err(DeError::DuplicateField);
                }
                key = Some(d.content()?);
                Ok(())
            }
            b"LastModifiedTime" => {
                if last_modified_time.is_some() {
                    return Err(DeError::DuplicateField);
                }
                last_modified_time = Some(d.timestamp(TimestampFormat::HttpDate)?);
                Ok(())
            }
            b"Size" => {
                if size.is_some() {
                    return Err(DeError::DuplicateField);
                }
                size = Some(d.content()?);
                Ok(())
            }
            b"VersionId" => {
                if version_id.is_some() {
                    return Err(DeError::DuplicateField);
                }
                version_id = Some(d.content()?);
                Ok(())
            }
            _ => Err(DeError::UnexpectedTagName),
        })?;
        Ok(Self {
            e_tag,
            key: key.ok_or(DeError::MissingField)?,
            last_modified_time,
            size,
            version_id,
        })
    }
}
impl SerializeContent for ObjectLockConfiguration {
    fn serialize_content<W: Write>(&self, s: &mut Serializer<W>) -> SerResult {
        if let Some(ref val) = self.object_lock_enabled {
            s.content("ObjectLockEnabled", val)?;
        }
        if let Some(ref val) = self.rule {
            s.content("Rule", val)?;
        }
        Ok(())
    }
}

impl<'xml> DeserializeContent<'xml> for ObjectLockConfiguration {
    fn deserialize_content(d: &mut Deserializer<'xml>) -> DeResult<Self> {
        let mut object_lock_enabled: Option<ObjectLockEnabled> = None;
        let mut rule: Option<ObjectLockRule> = None;
        d.for_each_element(|d, x| match x {
            b"ObjectLockEnabled" => {
                if object_lock_enabled.is_some() {
                    return Err(DeError::DuplicateField);
                }
                object_lock_enabled = Some(d.content()?);
                Ok(())
            }
            b"Rule" => {
                if rule.is_some() {
                    return Err(DeError::DuplicateField);
                }
                rule = Some(d.content()?);
                Ok(())
            }
            _ => Err(DeError::UnexpectedTagName),
        })?;
        Ok(Self {
            object_lock_enabled,
            rule,
        })
    }
}
impl SerializeContent for ObjectLockEnabled {
    fn serialize_content<W: Write>(&self, s: &mut Serializer<W>) -> SerResult {
        self.as_str().serialize_content(s)
    }
}
impl<'xml> DeserializeContent<'xml> for ObjectLockEnabled {
    fn deserialize_content(d: &mut Deserializer<'xml>) -> DeResult<Self> {
        d.text(|t| {
            let b: &[u8] = &t;
            match b {
                b"Enabled" => Ok(Self::from_static(ObjectLockEnabled::ENABLED)),
                _ => Ok(Self::from(t.unescape().map_err(DeError::InvalidXml)?.into_owned())),
            }
        })
    }
}
impl SerializeContent for ObjectLockLegalHold {
    fn serialize_content<W: Write>(&self, s: &mut Serializer<W>) -> SerResult {
        if let Some(ref val) = self.status {
            s.content("Status", val)?;
        }
        Ok(())
    }
}

impl<'xml> DeserializeContent<'xml> for ObjectLockLegalHold {
    fn deserialize_content(d: &mut Deserializer<'xml>) -> DeResult<Self> {
        let mut status: Option<ObjectLockLegalHoldStatus> = None;
        d.for_each_element(|d, x| match x {
            b"Status" => {
                if status.is_some() {
                    return Err(DeError::DuplicateField);
                }
                status = Some(d.content()?);
                Ok(())
            }
            _ => Err(DeError::UnexpectedTagName),
        })?;
        Ok(Self { status })
    }
}
impl SerializeContent for ObjectLockLegalHoldStatus {
    fn serialize_content<W: Write>(&self, s: &mut Serializer<W>) -> SerResult {
        self.as_str().serialize_content(s)
    }
}
impl<'xml> DeserializeContent<'xml> for ObjectLockLegalHoldStatus {
    fn deserialize_content(d: &mut Deserializer<'xml>) -> DeResult<Self> {
        d.text(|t| {
            let b: &[u8] = &t;
            match b {
                b"OFF" => Ok(Self::from_static(ObjectLockLegalHoldStatus::OFF)),
                b"ON" => Ok(Self::from_static(ObjectLockLegalHoldStatus::ON)),
                _ => Ok(Self::from(t.unescape().map_err(DeError::InvalidXml)?.into_owned())),
            }
        })
    }
}
impl SerializeContent for ObjectLockRetention {
    fn serialize_content<W: Write>(&self, s: &mut Serializer<W>) -> SerResult {
        if let Some(ref val) = self.mode {
            s.content("Mode", val)?;
        }
        if let Some(ref val) = self.retain_until_date {
            s.timestamp("RetainUntilDate", val, TimestampFormat::DateTime)?;
        }
        Ok(())
    }
}

impl<'xml> DeserializeContent<'xml> for ObjectLockRetention {
    fn deserialize_content(d: &mut Deserializer<'xml>) -> DeResult<Self> {
        let mut mode: Option<ObjectLockRetentionMode> = None;
        let mut retain_until_date: Option<Date> = None;
        d.for_each_element(|d, x| match x {
            b"Mode" => {
                if mode.is_some() {
                    return Err(DeError::DuplicateField);
                }
                mode = Some(d.content()?);
                Ok(())
            }
            b"RetainUntilDate" => {
                if retain_until_date.is_some() {
                    return Err(DeError::DuplicateField);
                }
                retain_until_date = Some(d.timestamp(TimestampFormat::DateTime)?);
                Ok(())
            }
            _ => Err(DeError::UnexpectedTagName),
        })?;
        Ok(Self { mode, retain_until_date })
    }
}
impl SerializeContent for ObjectLockRetentionMode {
    fn serialize_content<W: Write>(&self, s: &mut Serializer<W>) -> SerResult {
        self.as_str().serialize_content(s)
    }
}
impl<'xml> DeserializeContent<'xml> for ObjectLockRetentionMode {
    fn deserialize_content(d: &mut Deserializer<'xml>) -> DeResult<Self> {
        d.text(|t| {
            let b: &[u8] = &t;
            match b {
                b"COMPLIANCE" => Ok(Self::from_static(ObjectLockRetentionMode::COMPLIANCE)),
                b"GOVERNANCE" => Ok(Self::from_static(ObjectLockRetentionMode::GOVERNANCE)),
                _ => Ok(Self::from(t.unescape().map_err(DeError::InvalidXml)?.into_owned())),
            }
        })
    }
}
impl SerializeContent for ObjectLockRule {
    fn serialize_content<W: Write>(&self, s: &mut Serializer<W>) -> SerResult {
        if let Some(ref val) = self.default_retention {
            s.content("DefaultRetention", val)?;
        }
        Ok(())
    }
}

impl<'xml> DeserializeContent<'xml> for ObjectLockRule {
    fn deserialize_content(d: &mut Deserializer<'xml>) -> DeResult<Self> {
        let mut default_retention: Option<DefaultRetention> = None;
        d.for_each_element(|d, x| match x {
            b"DefaultRetention" => {
                if default_retention.is_some() {
                    return Err(DeError::DuplicateField);
                }
                default_retention = Some(d.content()?);
                Ok(())
            }
            _ => Err(DeError::UnexpectedTagName),
        })?;
        Ok(Self { default_retention })
    }
}
impl SerializeContent for ObjectOwnership {
    fn serialize_content<W: Write>(&self, s: &mut Serializer<W>) -> SerResult {
        self.as_str().serialize_content(s)
    }
}
impl<'xml> DeserializeContent<'xml> for ObjectOwnership {
    fn deserialize_content(d: &mut Deserializer<'xml>) -> DeResult<Self> {
        d.text(|t| {
            let b: &[u8] = &t;
            match b {
                b"BucketOwnerEnforced" => Ok(Self::from_static(ObjectOwnership::BUCKET_OWNER_ENFORCED)),
                b"BucketOwnerPreferred" => Ok(Self::from_static(ObjectOwnership::BUCKET_OWNER_PREFERRED)),
                b"ObjectWriter" => Ok(Self::from_static(ObjectOwnership::OBJECT_WRITER)),
                _ => Ok(Self::from(t.unescape().map_err(DeError::InvalidXml)?.into_owned())),
            }
        })
    }
}
impl SerializeContent for ObjectPart {
    fn serialize_content<W: Write>(&self, s: &mut Serializer<W>) -> SerResult {
        if let Some(ref val) = self.checksum_crc32 {
            s.content("ChecksumCRC32", val)?;
        }
        if let Some(ref val) = self.checksum_crc32c {
            s.content("ChecksumCRC32C", val)?;
        }
        if let Some(ref val) = self.checksum_crc64nvme {
            s.content("ChecksumCRC64NVME", val)?;
        }
        if let Some(ref val) = self.checksum_sha1 {
            s.content("ChecksumSHA1", val)?;
        }
        if let Some(ref val) = self.checksum_sha256 {
            s.content("ChecksumSHA256", val)?;
        }
        if let Some(ref val) = self.part_number {
            s.content("PartNumber", val)?;
        }
        if let Some(ref val) = self.size {
            s.content("Size", val)?;
        }
        Ok(())
    }
}

impl<'xml> DeserializeContent<'xml> for ObjectPart {
    fn deserialize_content(d: &mut Deserializer<'xml>) -> DeResult<Self> {
        let mut checksum_crc32: Option<ChecksumCRC32> = None;
        let mut checksum_crc32c: Option<ChecksumCRC32C> = None;
        let mut checksum_crc64nvme: Option<ChecksumCRC64NVME> = None;
        let mut checksum_sha1: Option<ChecksumSHA1> = None;
        let mut checksum_sha256: Option<ChecksumSHA256> = None;
        let mut part_number: Option<PartNumber> = None;
        let mut size: Option<Size> = None;
        d.for_each_element(|d, x| match x {
            b"ChecksumCRC32" => {
                if checksum_crc32.is_some() {
                    return Err(DeError::DuplicateField);
                }
                checksum_crc32 = Some(d.content()?);
                Ok(())
            }
            b"ChecksumCRC32C" => {
                if checksum_crc32c.is_some() {
                    return Err(DeError::DuplicateField);
                }
                checksum_crc32c = Some(d.content()?);
                Ok(())
            }
            b"ChecksumCRC64NVME" => {
                if checksum_crc64nvme.is_some() {
                    return Err(DeError::DuplicateField);
                }
                checksum_crc64nvme = Some(d.content()?);
                Ok(())
            }
            b"ChecksumSHA1" => {
                if checksum_sha1.is_some() {
                    return Err(DeError::DuplicateField);
                }
                checksum_sha1 = Some(d.content()?);
                Ok(())
            }
            b"ChecksumSHA256" => {
                if checksum_sha256.is_some() {
                    return Err(DeError::DuplicateField);
                }
                checksum_sha256 = Some(d.content()?);
                Ok(())
            }
            b"PartNumber" => {
                if part_number.is_some() {
                    return Err(DeError::DuplicateField);
                }
                part_number = Some(d.content()?);
                Ok(())
            }
            b"Size" => {
                if size.is_some() {
                    return Err(DeError::DuplicateField);
                }
                size = Some(d.content()?);
                Ok(())
            }
            _ => Err(DeError::UnexpectedTagName),
        })?;
        Ok(Self {
            checksum_crc32,
            checksum_crc32c,
            checksum_crc64nvme,
            checksum_sha1,
            checksum_sha256,
            part_number,
            size,
        })
    }
}
impl SerializeContent for ObjectStorageClass {
    fn serialize_content<W: Write>(&self, s: &mut Serializer<W>) -> SerResult {
        self.as_str().serialize_content(s)
    }
}
impl<'xml> DeserializeContent<'xml> for ObjectStorageClass {
    fn deserialize_content(d: &mut Deserializer<'xml>) -> DeResult<Self> {
        d.text(|t| {
            let b: &[u8] = &t;
            match b {
                b"DEEP_ARCHIVE" => Ok(Self::from_static(ObjectStorageClass::DEEP_ARCHIVE)),
                b"EXPRESS_ONEZONE" => Ok(Self::from_static(ObjectStorageClass::EXPRESS_ONEZONE)),
                b"GLACIER" => Ok(Self::from_static(ObjectStorageClass::GLACIER)),
                b"GLACIER_IR" => Ok(Self::from_static(ObjectStorageClass::GLACIER_IR)),
                b"INTELLIGENT_TIERING" => Ok(Self::from_static(ObjectStorageClass::INTELLIGENT_TIERING)),
                b"ONEZONE_IA" => Ok(Self::from_static(ObjectStorageClass::ONEZONE_IA)),
                b"OUTPOSTS" => Ok(Self::from_static(ObjectStorageClass::OUTPOSTS)),
                b"REDUCED_REDUNDANCY" => Ok(Self::from_static(ObjectStorageClass::REDUCED_REDUNDANCY)),
                b"SNOW" => Ok(Self::from_static(ObjectStorageClass::SNOW)),
                b"STANDARD" => Ok(Self::from_static(ObjectStorageClass::STANDARD)),
                b"STANDARD_IA" => Ok(Self::from_static(ObjectStorageClass::STANDARD_IA)),
                _ => Ok(Self::from(t.unescape().map_err(DeError::InvalidXml)?.into_owned())),
            }
        })
    }
}
impl SerializeContent for ObjectVersion {
    fn serialize_content<W: Write>(&self, s: &mut Serializer<W>) -> SerResult {
        if let Some(iter) = &self.checksum_algorithm {
            s.flattened_list("ChecksumAlgorithm", iter)?;
        }
        if let Some(ref val) = self.checksum_type {
            s.content("ChecksumType", val)?;
        }
        if let Some(ref val) = self.e_tag {
            s.content("ETag", val)?;
        }
        if let Some(ref val) = self.is_latest {
            s.content("IsLatest", val)?;
        }
        if let Some(ref val) = self.key {
            s.content("Key", val)?;
        }
        if let Some(ref val) = self.last_modified {
            s.timestamp("LastModified", val, TimestampFormat::DateTime)?;
        }
        if let Some(ref val) = self.owner {
            s.content("Owner", val)?;
        }
        if let Some(ref val) = self.restore_status {
            s.content("RestoreStatus", val)?;
        }
        if let Some(ref val) = self.size {
            s.content("Size", val)?;
        }
        if let Some(ref val) = self.storage_class {
            s.content("StorageClass", val)?;
        }
        if let Some(ref val) = self.version_id {
            s.content("VersionId", val)?;
        }
        Ok(())
    }
}

impl<'xml> DeserializeContent<'xml> for ObjectVersion {
    fn deserialize_content(d: &mut Deserializer<'xml>) -> DeResult<Self> {
        let mut checksum_algorithm: Option<ChecksumAlgorithmList> = None;
        let mut checksum_type: Option<ChecksumType> = None;
        let mut e_tag: Option<ETag> = None;
        let mut is_latest: Option<IsLatest> = None;
        let mut key: Option<ObjectKey> = None;
        let mut last_modified: Option<LastModified> = None;
        let mut owner: Option<Owner> = None;
        let mut restore_status: Option<RestoreStatus> = None;
        let mut size: Option<Size> = None;
        let mut storage_class: Option<ObjectVersionStorageClass> = None;
        let mut version_id: Option<ObjectVersionId> = None;
        d.for_each_element(|d, x| match x {
            b"ChecksumAlgorithm" => {
                let ans: ChecksumAlgorithm = d.content()?;
                checksum_algorithm.get_or_insert_with(List::new).push(ans);
                Ok(())
            }
            b"ChecksumType" => {
                if checksum_type.is_some() {
                    return Err(DeError::DuplicateField);
                }
                checksum_type = Some(d.content()?);
                Ok(())
            }
            b"ETag" => {
                if e_tag.is_some() {
                    return Err(DeError::DuplicateField);
                }
                e_tag = Some(d.content()?);
                Ok(())
            }
            b"IsLatest" => {
                if is_latest.is_some() {
                    return Err(DeError::DuplicateField);
                }
                is_latest = Some(d.content()?);
                Ok(())
            }
            b"Key" => {
                if key.is_some() {
                    return Err(DeError::DuplicateField);
                }
                key = Some(d.content()?);
                Ok(())
            }
            b"LastModified" => {
                if last_modified.is_some() {
                    return Err(DeError::DuplicateField);
                }
                last_modified = Some(d.timestamp(TimestampFormat::DateTime)?);
                Ok(())
            }
            b"Owner" => {
                if owner.is_some() {
                    return Err(DeError::DuplicateField);
                }
                owner = Some(d.content()?);
                Ok(())
            }
            b"RestoreStatus" => {
                if restore_status.is_some() {
                    return Err(DeError::DuplicateField);
                }
                restore_status = Some(d.content()?);
                Ok(())
            }
            b"Size" => {
                if size.is_some() {
                    return Err(DeError::DuplicateField);
                }
                size = Some(d.content()?);
                Ok(())
            }
            b"StorageClass" => {
                if storage_class.is_some() {
                    return Err(DeError::DuplicateField);
                }
                storage_class = Some(d.content()?);
                Ok(())
            }
            b"VersionId" => {
                if version_id.is_some() {
                    return Err(DeError::DuplicateField);
                }
                version_id = Some(d.content()?);
                Ok(())
            }
            _ => Err(DeError::UnexpectedTagName),
        })?;
        Ok(Self {
            checksum_algorithm,
            checksum_type,
            e_tag,
            is_latest,
            key,
            last_modified,
            owner,
            restore_status,
            size,
            storage_class,
            version_id,
        })
    }
}
impl SerializeContent for ObjectVersionStorageClass {
    fn serialize_content<W: Write>(&self, s: &mut Serializer<W>) -> SerResult {
        self.as_str().serialize_content(s)
    }
}
impl<'xml> DeserializeContent<'xml> for ObjectVersionStorageClass {
    fn deserialize_content(d: &mut Deserializer<'xml>) -> DeResult<Self> {
        d.text(|t| {
            let b: &[u8] = &t;
            match b {
                b"STANDARD" => Ok(Self::from_static(ObjectVersionStorageClass::STANDARD)),
                _ => Ok(Self::from(t.unescape().map_err(DeError::InvalidXml)?.into_owned())),
            }
        })
    }
}
impl SerializeContent for OutputLocation {
    fn serialize_content<W: Write>(&self, s: &mut Serializer<W>) -> SerResult {
        if let Some(ref val) = self.s3 {
            s.content("S3", val)?;
        }
        Ok(())
    }
}

impl<'xml> DeserializeContent<'xml> for OutputLocation {
    fn deserialize_content(d: &mut Deserializer<'xml>) -> DeResult<Self> {
        let mut s3: Option<S3Location> = None;
        d.for_each_element(|d, x| match x {
            b"S3" => {
                if s3.is_some() {
                    return Err(DeError::DuplicateField);
                }
                s3 = Some(d.content()?);
                Ok(())
            }
            _ => Err(DeError::UnexpectedTagName),
        })?;
        Ok(Self { s3 })
    }
}
impl SerializeContent for OutputSerialization {
    fn serialize_content<W: Write>(&self, s: &mut Serializer<W>) -> SerResult {
        if let Some(ref val) = self.csv {
            s.content("CSV", val)?;
        }
        if let Some(ref val) = self.json {
            s.content("JSON", val)?;
        }
        Ok(())
    }
}

impl<'xml> DeserializeContent<'xml> for OutputSerialization {
    fn deserialize_content(d: &mut Deserializer<'xml>) -> DeResult<Self> {
        let mut csv: Option<CSVOutput> = None;
        let mut json: Option<JSONOutput> = None;
        d.for_each_element(|d, x| match x {
            b"CSV" => {
                if csv.is_some() {
                    return Err(DeError::DuplicateField);
                }
                csv = Some(d.content()?);
                Ok(())
            }
            b"JSON" => {
                if json.is_some() {
                    return Err(DeError::DuplicateField);
                }
                json = Some(d.content()?);
                Ok(())
            }
            _ => Err(DeError::UnexpectedTagName),
        })?;
        Ok(Self { csv, json })
    }
}
impl SerializeContent for Owner {
    fn serialize_content<W: Write>(&self, s: &mut Serializer<W>) -> SerResult {
        if let Some(ref val) = self.display_name {
            s.content("DisplayName", val)?;
        }
        if let Some(ref val) = self.id {
            s.content("ID", val)?;
        }
        Ok(())
    }
}

impl<'xml> DeserializeContent<'xml> for Owner {
    fn deserialize_content(d: &mut Deserializer<'xml>) -> DeResult<Self> {
        let mut display_name: Option<DisplayName> = None;
        let mut id: Option<ID> = None;
        d.for_each_element(|d, x| match x {
            b"DisplayName" => {
                if display_name.is_some() {
                    return Err(DeError::DuplicateField);
                }
                display_name = Some(d.content()?);
                Ok(())
            }
            b"ID" => {
                if id.is_some() {
                    return Err(DeError::DuplicateField);
                }
                id = Some(d.content()?);
                Ok(())
            }
            _ => Err(DeError::UnexpectedTagName),
        })?;
        Ok(Self { display_name, id })
    }
}
impl SerializeContent for OwnerOverride {
    fn serialize_content<W: Write>(&self, s: &mut Serializer<W>) -> SerResult {
        self.as_str().serialize_content(s)
    }
}
impl<'xml> DeserializeContent<'xml> for OwnerOverride {
    fn deserialize_content(d: &mut Deserializer<'xml>) -> DeResult<Self> {
        d.text(|t| {
            let b: &[u8] = &t;
            match b {
                b"Destination" => Ok(Self::from_static(OwnerOverride::DESTINATION)),
                _ => Ok(Self::from(t.unescape().map_err(DeError::InvalidXml)?.into_owned())),
            }
        })
    }
}
impl SerializeContent for OwnershipControls {
    fn serialize_content<W: Write>(&self, s: &mut Serializer<W>) -> SerResult {
        {
            let iter = &self.rules;
            s.flattened_list("Rule", iter)?;
        }
        Ok(())
    }
}

impl<'xml> DeserializeContent<'xml> for OwnershipControls {
    fn deserialize_content(d: &mut Deserializer<'xml>) -> DeResult<Self> {
        let mut rules: Option<OwnershipControlsRules> = None;
        d.for_each_element(|d, x| match x {
            b"Rule" => {
                let ans: OwnershipControlsRule = d.content()?;
                rules.get_or_insert_with(List::new).push(ans);
                Ok(())
            }
            _ => Err(DeError::UnexpectedTagName),
        })?;
        Ok(Self {
            rules: rules.ok_or(DeError::MissingField)?,
        })
    }
}
impl SerializeContent for OwnershipControlsRule {
    fn serialize_content<W: Write>(&self, s: &mut Serializer<W>) -> SerResult {
        s.content("ObjectOwnership", &self.object_ownership)?;
        Ok(())
    }
}

impl<'xml> DeserializeContent<'xml> for OwnershipControlsRule {
    fn deserialize_content(d: &mut Deserializer<'xml>) -> DeResult<Self> {
        let mut object_ownership: Option<ObjectOwnership> = None;
        d.for_each_element(|d, x| match x {
            b"ObjectOwnership" => {
                if object_ownership.is_some() {
                    return Err(DeError::DuplicateField);
                }
                object_ownership = Some(d.content()?);
                Ok(())
            }
            _ => Err(DeError::UnexpectedTagName),
        })?;
        Ok(Self {
            object_ownership: object_ownership.ok_or(DeError::MissingField)?,
        })
    }
}
impl SerializeContent for ParquetInput {
    fn serialize_content<W: Write>(&self, _: &mut Serializer<W>) -> SerResult {
        Ok(())
    }
}

impl<'xml> DeserializeContent<'xml> for ParquetInput {
    fn deserialize_content(_: &mut Deserializer<'xml>) -> DeResult<Self> {
        Ok(Self {})
    }
}
impl SerializeContent for Part {
    fn serialize_content<W: Write>(&self, s: &mut Serializer<W>) -> SerResult {
        if let Some(ref val) = self.checksum_crc32 {
            s.content("ChecksumCRC32", val)?;
        }
        if let Some(ref val) = self.checksum_crc32c {
            s.content("ChecksumCRC32C", val)?;
        }
        if let Some(ref val) = self.checksum_crc64nvme {
            s.content("ChecksumCRC64NVME", val)?;
        }
        if let Some(ref val) = self.checksum_sha1 {
            s.content("ChecksumSHA1", val)?;
        }
        if let Some(ref val) = self.checksum_sha256 {
            s.content("ChecksumSHA256", val)?;
        }
        if let Some(ref val) = self.e_tag {
            s.content("ETag", val)?;
        }
        if let Some(ref val) = self.last_modified {
            s.timestamp("LastModified", val, TimestampFormat::DateTime)?;
        }
        if let Some(ref val) = self.part_number {
            s.content("PartNumber", val)?;
        }
        if let Some(ref val) = self.size {
            s.content("Size", val)?;
        }
        Ok(())
    }
}

impl<'xml> DeserializeContent<'xml> for Part {
    fn deserialize_content(d: &mut Deserializer<'xml>) -> DeResult<Self> {
        let mut checksum_crc32: Option<ChecksumCRC32> = None;
        let mut checksum_crc32c: Option<ChecksumCRC32C> = None;
        let mut checksum_crc64nvme: Option<ChecksumCRC64NVME> = None;
        let mut checksum_sha1: Option<ChecksumSHA1> = None;
        let mut checksum_sha256: Option<ChecksumSHA256> = None;
        let mut e_tag: Option<ETag> = None;
        let mut last_modified: Option<LastModified> = None;
        let mut part_number: Option<PartNumber> = None;
        let mut size: Option<Size> = None;
        d.for_each_element(|d, x| match x {
            b"ChecksumCRC32" => {
                if checksum_crc32.is_some() {
                    return Err(DeError::DuplicateField);
                }
                checksum_crc32 = Some(d.content()?);
                Ok(())
            }
            b"ChecksumCRC32C" => {
                if checksum_crc32c.is_some() {
                    return Err(DeError::DuplicateField);
                }
                checksum_crc32c = Some(d.content()?);
                Ok(())
            }
            b"ChecksumCRC64NVME" => {
                if checksum_crc64nvme.is_some() {
                    return Err(DeError::DuplicateField);
                }
                checksum_crc64nvme = Some(d.content()?);
                Ok(())
            }
            b"ChecksumSHA1" => {
                if checksum_sha1.is_some() {
                    return Err(DeError::DuplicateField);
                }
                checksum_sha1 = Some(d.content()?);
                Ok(())
            }
            b"ChecksumSHA256" => {
                if checksum_sha256.is_some() {
                    return Err(DeError::DuplicateField);
                }
                checksum_sha256 = Some(d.content()?);
                Ok(())
            }
            b"ETag" => {
                if e_tag.is_some() {
                    return Err(DeError::DuplicateField);
                }
                e_tag = Some(d.content()?);
                Ok(())
            }
            b"LastModified" => {
                if last_modified.is_some() {
                    return Err(DeError::DuplicateField);
                }
                last_modified = Some(d.timestamp(TimestampFormat::DateTime)?);
                Ok(())
            }
            b"PartNumber" => {
                if part_number.is_some() {
                    return Err(DeError::DuplicateField);
                }
                part_number = Some(d.content()?);
                Ok(())
            }
            b"Size" => {
                if size.is_some() {
                    return Err(DeError::DuplicateField);
                }
                size = Some(d.content()?);
                Ok(())
            }
            _ => Err(DeError::UnexpectedTagName),
        })?;
        Ok(Self {
            checksum_crc32,
            checksum_crc32c,
            checksum_crc64nvme,
            checksum_sha1,
            checksum_sha256,
            e_tag,
            last_modified,
            part_number,
            size,
        })
    }
}
impl SerializeContent for PartitionDateSource {
    fn serialize_content<W: Write>(&self, s: &mut Serializer<W>) -> SerResult {
        self.as_str().serialize_content(s)
    }
}
impl<'xml> DeserializeContent<'xml> for PartitionDateSource {
    fn deserialize_content(d: &mut Deserializer<'xml>) -> DeResult<Self> {
        d.text(|t| {
            let b: &[u8] = &t;
            match b {
                b"DeliveryTime" => Ok(Self::from_static(PartitionDateSource::DELIVERY_TIME)),
                b"EventTime" => Ok(Self::from_static(PartitionDateSource::EVENT_TIME)),
                _ => Ok(Self::from(t.unescape().map_err(DeError::InvalidXml)?.into_owned())),
            }
        })
    }
}
impl SerializeContent for PartitionedPrefix {
    fn serialize_content<W: Write>(&self, s: &mut Serializer<W>) -> SerResult {
        if let Some(ref val) = self.partition_date_source {
            s.content("PartitionDateSource", val)?;
        }
        Ok(())
    }
}

impl<'xml> DeserializeContent<'xml> for PartitionedPrefix {
    fn deserialize_content(d: &mut Deserializer<'xml>) -> DeResult<Self> {
        let mut partition_date_source: Option<PartitionDateSource> = None;
        d.for_each_element(|d, x| match x {
            b"PartitionDateSource" => {
                if partition_date_source.is_some() {
                    return Err(DeError::DuplicateField);
                }
                partition_date_source = Some(d.content()?);
                Ok(())
            }
            _ => Err(DeError::UnexpectedTagName),
        })?;
        Ok(Self { partition_date_source })
    }
}
impl SerializeContent for Payer {
    fn serialize_content<W: Write>(&self, s: &mut Serializer<W>) -> SerResult {
        self.as_str().serialize_content(s)
    }
}
impl<'xml> DeserializeContent<'xml> for Payer {
    fn deserialize_content(d: &mut Deserializer<'xml>) -> DeResult<Self> {
        d.text(|t| {
            let b: &[u8] = &t;
            match b {
                b"BucketOwner" => Ok(Self::from_static(Payer::BUCKET_OWNER)),
                b"Requester" => Ok(Self::from_static(Payer::REQUESTER)),
                _ => Ok(Self::from(t.unescape().map_err(DeError::InvalidXml)?.into_owned())),
            }
        })
    }
}
impl SerializeContent for Permission {
    fn serialize_content<W: Write>(&self, s: &mut Serializer<W>) -> SerResult {
        self.as_str().serialize_content(s)
    }
}
impl<'xml> DeserializeContent<'xml> for Permission {
    fn deserialize_content(d: &mut Deserializer<'xml>) -> DeResult<Self> {
        d.text(|t| {
            let b: &[u8] = &t;
            match b {
                b"FULL_CONTROL" => Ok(Self::from_static(Permission::FULL_CONTROL)),
                b"READ" => Ok(Self::from_static(Permission::READ)),
                b"READ_ACP" => Ok(Self::from_static(Permission::READ_ACP)),
                b"WRITE" => Ok(Self::from_static(Permission::WRITE)),
                b"WRITE_ACP" => Ok(Self::from_static(Permission::WRITE_ACP)),
                _ => Ok(Self::from(t.unescape().map_err(DeError::InvalidXml)?.into_owned())),
            }
        })
    }
}
impl SerializeContent for PolicyStatus {
    fn serialize_content<W: Write>(&self, s: &mut Serializer<W>) -> SerResult {
        if let Some(ref val) = self.is_public {
            s.content("IsPublic", val)?;
        }
        Ok(())
    }
}

impl<'xml> DeserializeContent<'xml> for PolicyStatus {
    fn deserialize_content(d: &mut Deserializer<'xml>) -> DeResult<Self> {
        let mut is_public: Option<IsPublic> = None;
        d.for_each_element(|d, x| match x {
            b"IsPublic" => {
                if is_public.is_some() {
                    return Err(DeError::DuplicateField);
                }
                is_public = Some(d.content()?);
                Ok(())
            }
            _ => Err(DeError::UnexpectedTagName),
        })?;
        Ok(Self { is_public })
    }
}
impl SerializeContent for Progress {
    fn serialize_content<W: Write>(&self, s: &mut Serializer<W>) -> SerResult {
        if let Some(ref val) = self.bytes_processed {
            s.content("BytesProcessed", val)?;
        }
        if let Some(ref val) = self.bytes_returned {
            s.content("BytesReturned", val)?;
        }
        if let Some(ref val) = self.bytes_scanned {
            s.content("BytesScanned", val)?;
        }
        Ok(())
    }
}

impl<'xml> DeserializeContent<'xml> for Progress {
    fn deserialize_content(d: &mut Deserializer<'xml>) -> DeResult<Self> {
        let mut bytes_processed: Option<BytesProcessed> = None;
        let mut bytes_returned: Option<BytesReturned> = None;
        let mut bytes_scanned: Option<BytesScanned> = None;
        d.for_each_element(|d, x| match x {
            b"BytesProcessed" => {
                if bytes_processed.is_some() {
                    return Err(DeError::DuplicateField);
                }
                bytes_processed = Some(d.content()?);
                Ok(())
            }
            b"BytesReturned" => {
                if bytes_returned.is_some() {
                    return Err(DeError::DuplicateField);
                }
                bytes_returned = Some(d.content()?);
                Ok(())
            }
            b"BytesScanned" => {
                if bytes_scanned.is_some() {
                    return Err(DeError::DuplicateField);
                }
                bytes_scanned = Some(d.content()?);
                Ok(())
            }
            _ => Err(DeError::UnexpectedTagName),
        })?;
        Ok(Self {
            bytes_processed,
            bytes_returned,
            bytes_scanned,
        })
    }
}
impl SerializeContent for Protocol {
    fn serialize_content<W: Write>(&self, s: &mut Serializer<W>) -> SerResult {
        self.as_str().serialize_content(s)
    }
}
impl<'xml> DeserializeContent<'xml> for Protocol {
    fn deserialize_content(d: &mut Deserializer<'xml>) -> DeResult<Self> {
        d.text(|t| {
            let b: &[u8] = &t;
            match b {
                b"http" => Ok(Self::from_static(Protocol::HTTP)),
                b"https" => Ok(Self::from_static(Protocol::HTTPS)),
                _ => Ok(Self::from(t.unescape().map_err(DeError::InvalidXml)?.into_owned())),
            }
        })
    }
}
impl SerializeContent for PublicAccessBlockConfiguration {
    fn serialize_content<W: Write>(&self, s: &mut Serializer<W>) -> SerResult {
        if let Some(ref val) = self.block_public_acls {
            s.content("BlockPublicAcls", val)?;
        }
        if let Some(ref val) = self.block_public_policy {
            s.content("BlockPublicPolicy", val)?;
        }
        if let Some(ref val) = self.ignore_public_acls {
            s.content("IgnorePublicAcls", val)?;
        }
        if let Some(ref val) = self.restrict_public_buckets {
            s.content("RestrictPublicBuckets", val)?;
        }
        Ok(())
    }
}

impl<'xml> DeserializeContent<'xml> for PublicAccessBlockConfiguration {
    fn deserialize_content(d: &mut Deserializer<'xml>) -> DeResult<Self> {
        let mut block_public_acls: Option<Setting> = None;
        let mut block_public_policy: Option<Setting> = None;
        let mut ignore_public_acls: Option<Setting> = None;
        let mut restrict_public_buckets: Option<Setting> = None;
        d.for_each_element(|d, x| match x {
            b"BlockPublicAcls" => {
                if block_public_acls.is_some() {
                    return Err(DeError::DuplicateField);
                }
                block_public_acls = Some(d.content()?);
                Ok(())
            }
            b"BlockPublicPolicy" => {
                if block_public_policy.is_some() {
                    return Err(DeError::DuplicateField);
                }
                block_public_policy = Some(d.content()?);
                Ok(())
            }
            b"IgnorePublicAcls" => {
                if ignore_public_acls.is_some() {
                    return Err(DeError::DuplicateField);
                }
                ignore_public_acls = Some(d.content()?);
                Ok(())
            }
            b"RestrictPublicBuckets" => {
                if restrict_public_buckets.is_some() {
                    return Err(DeError::DuplicateField);
                }
                restrict_public_buckets = Some(d.content()?);
                Ok(())
            }
            _ => Err(DeError::UnexpectedTagName),
        })?;
        Ok(Self {
            block_public_acls,
            block_public_policy,
            ignore_public_acls,
            restrict_public_buckets,
        })
    }
}
impl SerializeContent for QueueConfiguration {
    fn serialize_content<W: Write>(&self, s: &mut Serializer<W>) -> SerResult {
        {
            let iter = &self.events;
            s.flattened_list("Event", iter)?;
        }
        if let Some(ref val) = self.filter {
            s.content("Filter", val)?;
        }
        if let Some(ref val) = self.id {
            s.content("Id", val)?;
        }
        s.content("Queue", &self.queue_arn)?;
        Ok(())
    }
}

impl<'xml> DeserializeContent<'xml> for QueueConfiguration {
    fn deserialize_content(d: &mut Deserializer<'xml>) -> DeResult<Self> {
        let mut events: Option<EventList> = None;
        let mut filter: Option<NotificationConfigurationFilter> = None;
        let mut id: Option<NotificationId> = None;
        let mut queue_arn: Option<QueueArn> = None;
        d.for_each_element(|d, x| match x {
            b"Event" => {
                let ans: Event = d.content()?;
                events.get_or_insert_with(List::new).push(ans);
                Ok(())
            }
            b"Filter" => {
                if filter.is_some() {
                    return Err(DeError::DuplicateField);
                }
                filter = Some(d.content()?);
                Ok(())
            }
            b"Id" => {
                if id.is_some() {
                    return Err(DeError::DuplicateField);
                }
                id = Some(d.content()?);
                Ok(())
            }
            b"Queue" => {
                if queue_arn.is_some() {
                    return Err(DeError::DuplicateField);
                }
                queue_arn = Some(d.content()?);
                Ok(())
            }
            _ => Err(DeError::UnexpectedTagName),
        })?;
        Ok(Self {
            events: events.ok_or(DeError::MissingField)?,
            filter,
            id,
            queue_arn: queue_arn.ok_or(DeError::MissingField)?,
        })
    }
}
impl SerializeContent for QuoteFields {
    fn serialize_content<W: Write>(&self, s: &mut Serializer<W>) -> SerResult {
        self.as_str().serialize_content(s)
    }
}
impl<'xml> DeserializeContent<'xml> for QuoteFields {
    fn deserialize_content(d: &mut Deserializer<'xml>) -> DeResult<Self> {
        d.text(|t| {
            let b: &[u8] = &t;
            match b {
                b"ALWAYS" => Ok(Self::from_static(QuoteFields::ALWAYS)),
                b"ASNEEDED" => Ok(Self::from_static(QuoteFields::ASNEEDED)),
                _ => Ok(Self::from(t.unescape().map_err(DeError::InvalidXml)?.into_owned())),
            }
        })
    }
}
impl SerializeContent for Redirect {
    fn serialize_content<W: Write>(&self, s: &mut Serializer<W>) -> SerResult {
        if let Some(ref val) = self.host_name {
            s.content("HostName", val)?;
        }
        if let Some(ref val) = self.http_redirect_code {
            s.content("HttpRedirectCode", val)?;
        }
        if let Some(ref val) = self.protocol {
            s.content("Protocol", val)?;
        }
        if let Some(ref val) = self.replace_key_prefix_with {
            s.content("ReplaceKeyPrefixWith", val)?;
        }
        if let Some(ref val) = self.replace_key_with {
            s.content("ReplaceKeyWith", val)?;
        }
        Ok(())
    }
}

impl<'xml> DeserializeContent<'xml> for Redirect {
    fn deserialize_content(d: &mut Deserializer<'xml>) -> DeResult<Self> {
        let mut host_name: Option<HostName> = None;
        let mut http_redirect_code: Option<HttpRedirectCode> = None;
        let mut protocol: Option<Protocol> = None;
        let mut replace_key_prefix_with: Option<ReplaceKeyPrefixWith> = None;
        let mut replace_key_with: Option<ReplaceKeyWith> = None;
        d.for_each_element(|d, x| match x {
            b"HostName" => {
                if host_name.is_some() {
                    return Err(DeError::DuplicateField);
                }
                host_name = Some(d.content()?);
                Ok(())
            }
            b"HttpRedirectCode" => {
                if http_redirect_code.is_some() {
                    return Err(DeError::DuplicateField);
                }
                http_redirect_code = Some(d.content()?);
                Ok(())
            }
            b"Protocol" => {
                if protocol.is_some() {
                    return Err(DeError::DuplicateField);
                }
                protocol = Some(d.content()?);
                Ok(())
            }
            b"ReplaceKeyPrefixWith" => {
                if replace_key_prefix_with.is_some() {
                    return Err(DeError::DuplicateField);
                }
                replace_key_prefix_with = Some(d.content()?);
                Ok(())
            }
            b"ReplaceKeyWith" => {
                if replace_key_with.is_some() {
                    return Err(DeError::DuplicateField);
                }
                replace_key_with = Some(d.content()?);
                Ok(())
            }
            _ => Err(DeError::UnexpectedTagName),
        })?;
        Ok(Self {
            host_name,
            http_redirect_code,
            protocol,
            replace_key_prefix_with,
            replace_key_with,
        })
    }
}
impl SerializeContent for RedirectAllRequestsTo {
    fn serialize_content<W: Write>(&self, s: &mut Serializer<W>) -> SerResult {
        s.content("HostName", &self.host_name)?;
        if let Some(ref val) = self.protocol {
            s.content("Protocol", val)?;
        }
        Ok(())
    }
}

impl<'xml> DeserializeContent<'xml> for RedirectAllRequestsTo {
    fn deserialize_content(d: &mut Deserializer<'xml>) -> DeResult<Self> {
        let mut host_name: Option<HostName> = None;
        let mut protocol: Option<Protocol> = None;
        d.for_each_element(|d, x| match x {
            b"HostName" => {
                if host_name.is_some() {
                    return Err(DeError::DuplicateField);
                }
                host_name = Some(d.content()?);
                Ok(())
            }
            b"Protocol" => {
                if protocol.is_some() {
                    return Err(DeError::DuplicateField);
                }
                protocol = Some(d.content()?);
                Ok(())
            }
            _ => Err(DeError::UnexpectedTagName),
        })?;
        Ok(Self {
            host_name: host_name.ok_or(DeError::MissingField)?,
            protocol,
        })
    }
}
impl SerializeContent for ReplicaModifications {
    fn serialize_content<W: Write>(&self, s: &mut Serializer<W>) -> SerResult {
        s.content("Status", &self.status)?;
        Ok(())
    }
}

impl<'xml> DeserializeContent<'xml> for ReplicaModifications {
    fn deserialize_content(d: &mut Deserializer<'xml>) -> DeResult<Self> {
        let mut status: Option<ReplicaModificationsStatus> = None;
        d.for_each_element(|d, x| match x {
            b"Status" => {
                if status.is_some() {
                    return Err(DeError::DuplicateField);
                }
                status = Some(d.content()?);
                Ok(())
            }
            _ => Err(DeError::UnexpectedTagName),
        })?;
        Ok(Self {
            status: status.ok_or(DeError::MissingField)?,
        })
    }
}
impl SerializeContent for ReplicaModificationsStatus {
    fn serialize_content<W: Write>(&self, s: &mut Serializer<W>) -> SerResult {
        self.as_str().serialize_content(s)
    }
}
impl<'xml> DeserializeContent<'xml> for ReplicaModificationsStatus {
    fn deserialize_content(d: &mut Deserializer<'xml>) -> DeResult<Self> {
        d.text(|t| {
            let b: &[u8] = &t;
            match b {
                b"Disabled" => Ok(Self::from_static(ReplicaModificationsStatus::DISABLED)),
                b"Enabled" => Ok(Self::from_static(ReplicaModificationsStatus::ENABLED)),
                _ => Ok(Self::from(t.unescape().map_err(DeError::InvalidXml)?.into_owned())),
            }
        })
    }
}
impl SerializeContent for ReplicationConfiguration {
    fn serialize_content<W: Write>(&self, s: &mut Serializer<W>) -> SerResult {
        s.content("Role", &self.role)?;
        {
            let iter = &self.rules;
            s.flattened_list("Rule", iter)?;
        }
        Ok(())
    }
}

impl<'xml> DeserializeContent<'xml> for ReplicationConfiguration {
    fn deserialize_content(d: &mut Deserializer<'xml>) -> DeResult<Self> {
        let mut role: Option<Role> = None;
        let mut rules: Option<ReplicationRules> = None;
        d.for_each_element(|d, x| match x {
            b"Role" => {
                if role.is_some() {
                    return Err(DeError::DuplicateField);
                }
                role = Some(d.content()?);
                Ok(())
            }
            b"Rule" => {
                let ans: ReplicationRule = d.content()?;
                rules.get_or_insert_with(List::new).push(ans);
                Ok(())
            }
            _ => Err(DeError::UnexpectedTagName),
        })?;
        Ok(Self {
            role: role.ok_or(DeError::MissingField)?,
            rules: rules.ok_or(DeError::MissingField)?,
        })
    }
}
impl SerializeContent for ReplicationRule {
    fn serialize_content<W: Write>(&self, s: &mut Serializer<W>) -> SerResult {
        if let Some(ref val) = self.delete_marker_replication {
            s.content("DeleteMarkerReplication", val)?;
        }
        if let Some(ref val) = self.delete_replication {
            s.content("DeleteReplication", val)?;
        }
        s.content("Destination", &self.destination)?;
        if let Some(ref val) = self.existing_object_replication {
            s.content("ExistingObjectReplication", val)?;
        }
        if let Some(ref val) = self.filter {
            s.content("Filter", val)?;
        }
        if let Some(ref val) = self.id {
            s.content("ID", val)?;
        }
        if let Some(ref val) = self.prefix {
            s.content("Prefix", val)?;
        }
        if let Some(ref val) = self.priority {
            s.content("Priority", val)?;
        }
        if let Some(ref val) = self.source_selection_criteria {
            s.content("SourceSelectionCriteria", val)?;
        }
        s.content("Status", &self.status)?;
        Ok(())
    }
}

impl<'xml> DeserializeContent<'xml> for ReplicationRule {
    fn deserialize_content(d: &mut Deserializer<'xml>) -> DeResult<Self> {
        let mut delete_marker_replication: Option<DeleteMarkerReplication> = None;
        let mut delete_replication: Option<DeleteReplication> = None;
        let mut destination: Option<Destination> = None;
        let mut existing_object_replication: Option<ExistingObjectReplication> = None;
        let mut filter: Option<ReplicationRuleFilter> = None;
        let mut id: Option<ID> = None;
        let mut prefix: Option<Prefix> = None;
        let mut priority: Option<Priority> = None;
        let mut source_selection_criteria: Option<SourceSelectionCriteria> = None;
        let mut status: Option<ReplicationRuleStatus> = None;
        d.for_each_element(|d, x| match x {
            b"DeleteMarkerReplication" => {
                if delete_marker_replication.is_some() {
                    return Err(DeError::DuplicateField);
                }
                delete_marker_replication = Some(d.content()?);
                Ok(())
            }
            b"DeleteReplication" => {
                if delete_replication.is_some() {
                    return Err(DeError::DuplicateField);
                }
                delete_replication = Some(d.content()?);
                Ok(())
            }
            b"Destination" => {
                if destination.is_some() {
                    return Err(DeError::DuplicateField);
                }
                destination = Some(d.content()?);
                Ok(())
            }
            b"ExistingObjectReplication" => {
                if existing_object_replication.is_some() {
                    return Err(DeError::DuplicateField);
                }
                existing_object_replication = Some(d.content()?);
                Ok(())
            }
            b"Filter" => {
                if filter.is_some() {
                    return Err(DeError::DuplicateField);
                }
                filter = Some(d.content()?);
                Ok(())
            }
            b"ID" => {
                if id.is_some() {
                    return Err(DeError::DuplicateField);
                }
                id = Some(d.content()?);
                Ok(())
            }
            b"Prefix" => {
                if prefix.is_some() {
                    return Err(DeError::DuplicateField);
                }
                prefix = Some(d.content()?);
                Ok(())
            }
            b"Priority" => {
                if priority.is_some() {
                    return Err(DeError::DuplicateField);
                }
                priority = Some(d.content()?);
                Ok(())
            }
            b"SourceSelectionCriteria" => {
                if source_selection_criteria.is_some() {
                    return Err(DeError::DuplicateField);
                }
                source_selection_criteria = Some(d.content()?);
                Ok(())
            }
            b"Status" => {
                if status.is_some() {
                    return Err(DeError::DuplicateField);
                }
                status = Some(d.content()?);
                Ok(())
            }
            _ => Err(DeError::UnexpectedTagName),
        })?;
        Ok(Self {
            delete_marker_replication,
            delete_replication,
            destination: destination.ok_or(DeError::MissingField)?,
            existing_object_replication,
            filter,
            id,
            prefix,
            priority,
            source_selection_criteria,
            status: status.ok_or(DeError::MissingField)?,
        })
    }
}
impl SerializeContent for ReplicationRuleAndOperator {
    fn serialize_content<W: Write>(&self, s: &mut Serializer<W>) -> SerResult {
        if let Some(ref val) = self.prefix {
            s.content("Prefix", val)?;
        }
        if let Some(iter) = &self.tags {
            s.flattened_list("Tag", iter)?;
        }
        Ok(())
    }
}

impl<'xml> DeserializeContent<'xml> for ReplicationRuleAndOperator {
    fn deserialize_content(d: &mut Deserializer<'xml>) -> DeResult<Self> {
        let mut prefix: Option<Prefix> = None;
        let mut tags: Option<TagSet> = None;
        d.for_each_element(|d, x| match x {
            b"Prefix" => {
                if prefix.is_some() {
                    return Err(DeError::DuplicateField);
                }
                prefix = Some(d.content()?);
                Ok(())
            }
            b"Tag" => {
                let ans: Tag = d.content()?;
                tags.get_or_insert_with(List::new).push(ans);
                Ok(())
            }
            _ => Err(DeError::UnexpectedTagName),
        })?;
        Ok(Self { prefix, tags })
    }
}
impl SerializeContent for ReplicationRuleFilter {
    fn serialize_content<W: Write>(&self, s: &mut Serializer<W>) -> SerResult {
        if let Some(ref val) = self.and {
            s.content("And", val)?;
        }
        if let Some(ref val) = self.prefix {
            s.content("Prefix", val)?;
        }
        if let Some(ref val) = self.tag {
            s.content("Tag", val)?;
        }
        Ok(())
    }
}

impl<'xml> DeserializeContent<'xml> for ReplicationRuleFilter {
    fn deserialize_content(d: &mut Deserializer<'xml>) -> DeResult<Self> {
        let mut and: Option<ReplicationRuleAndOperator> = None;
        let mut prefix: Option<Prefix> = None;
        let mut tag: Option<Tag> = None;
        d.for_each_element(|d, x| match x {
            b"And" => {
                if and.is_some() {
                    return Err(DeError::DuplicateField);
                }
                and = Some(d.content()?);
                Ok(())
            }
            b"Prefix" => {
                if prefix.is_some() {
                    return Err(DeError::DuplicateField);
                }
                prefix = Some(d.content()?);
                Ok(())
            }
            b"Tag" => {
                if tag.is_some() {
                    return Err(DeError::DuplicateField);
                }
                tag = Some(d.content()?);
                Ok(())
            }
            _ => Err(DeError::UnexpectedTagName),
        })?;
        Ok(Self {
            and,
            cached_tags: CachedTags::default(),
            prefix,
            tag,
        })
    }
}
impl SerializeContent for ReplicationRuleStatus {
    fn serialize_content<W: Write>(&self, s: &mut Serializer<W>) -> SerResult {
        self.as_str().serialize_content(s)
    }
}
impl<'xml> DeserializeContent<'xml> for ReplicationRuleStatus {
    fn deserialize_content(d: &mut Deserializer<'xml>) -> DeResult<Self> {
        d.text(|t| {
            let b: &[u8] = &t;
            match b {
                b"Disabled" => Ok(Self::from_static(ReplicationRuleStatus::DISABLED)),
                b"Enabled" => Ok(Self::from_static(ReplicationRuleStatus::ENABLED)),
                _ => Ok(Self::from(t.unescape().map_err(DeError::InvalidXml)?.into_owned())),
            }
        })
    }
}
impl SerializeContent for ReplicationTime {
    fn serialize_content<W: Write>(&self, s: &mut Serializer<W>) -> SerResult {
        s.content("Status", &self.status)?;
        s.content("Time", &self.time)?;
        Ok(())
    }
}

impl<'xml> DeserializeContent<'xml> for ReplicationTime {
    fn deserialize_content(d: &mut Deserializer<'xml>) -> DeResult<Self> {
        let mut status: Option<ReplicationTimeStatus> = None;
        let mut time: Option<ReplicationTimeValue> = None;
        d.for_each_element(|d, x| match x {
            b"Status" => {
                if status.is_some() {
                    return Err(DeError::DuplicateField);
                }
                status = Some(d.content()?);
                Ok(())
            }
            b"Time" => {
                if time.is_some() {
                    return Err(DeError::DuplicateField);
                }
                time = Some(d.content()?);
                Ok(())
            }
            _ => Err(DeError::UnexpectedTagName),
        })?;
        Ok(Self {
            status: status.ok_or(DeError::MissingField)?,
            time: time.ok_or(DeError::MissingField)?,
        })
    }
}
impl SerializeContent for ReplicationTimeStatus {
    fn serialize_content<W: Write>(&self, s: &mut Serializer<W>) -> SerResult {
        self.as_str().serialize_content(s)
    }
}
impl<'xml> DeserializeContent<'xml> for ReplicationTimeStatus {
    fn deserialize_content(d: &mut Deserializer<'xml>) -> DeResult<Self> {
        d.text(|t| {
            let b: &[u8] = &t;
            match b {
                b"Disabled" => Ok(Self::from_static(ReplicationTimeStatus::DISABLED)),
                b"Enabled" => Ok(Self::from_static(ReplicationTimeStatus::ENABLED)),
                _ => Ok(Self::from(t.unescape().map_err(DeError::InvalidXml)?.into_owned())),
            }
        })
    }
}
impl SerializeContent for ReplicationTimeValue {
    fn serialize_content<W: Write>(&self, s: &mut Serializer<W>) -> SerResult {
        if let Some(ref val) = self.minutes {
            s.content("Minutes", val)?;
        }
        Ok(())
    }
}

impl<'xml> DeserializeContent<'xml> for ReplicationTimeValue {
    fn deserialize_content(d: &mut Deserializer<'xml>) -> DeResult<Self> {
        let mut minutes: Option<Minutes> = None;
        d.for_each_element(|d, x| match x {
            b"Minutes" => {
                if minutes.is_some() {
                    return Err(DeError::DuplicateField);
                }
                minutes = Some(d.content()?);
                Ok(())
            }
            _ => Err(DeError::UnexpectedTagName),
        })?;
        Ok(Self { minutes })
    }
}
impl SerializeContent for RequestPaymentConfiguration {
    fn serialize_content<W: Write>(&self, s: &mut Serializer<W>) -> SerResult {
        s.content("Payer", &self.payer)?;
        Ok(())
    }
}

impl<'xml> DeserializeContent<'xml> for RequestPaymentConfiguration {
    fn deserialize_content(d: &mut Deserializer<'xml>) -> DeResult<Self> {
        let mut payer: Option<Payer> = None;
        d.for_each_element(|d, x| match x {
            b"Payer" => {
                if payer.is_some() {
                    return Err(DeError::DuplicateField);
                }
                payer = Some(d.content()?);
                Ok(())
            }
            _ => Err(DeError::UnexpectedTagName),
        })?;
        Ok(Self {
            payer: payer.ok_or(DeError::MissingField)?,
        })
    }
}
impl SerializeContent for RequestProgress {
    fn serialize_content<W: Write>(&self, s: &mut Serializer<W>) -> SerResult {
        if let Some(ref val) = self.enabled {
            s.content("Enabled", val)?;
        }
        Ok(())
    }
}

impl<'xml> DeserializeContent<'xml> for RequestProgress {
    fn deserialize_content(d: &mut Deserializer<'xml>) -> DeResult<Self> {
        let mut enabled: Option<EnableRequestProgress> = None;
        d.for_each_element(|d, x| match x {
            b"Enabled" => {
                if enabled.is_some() {
                    return Err(DeError::DuplicateField);
                }
                enabled = Some(d.content()?);
                Ok(())
            }
            _ => Err(DeError::UnexpectedTagName),
        })?;
        Ok(Self { enabled })
    }
}
impl SerializeContent for RestoreRequest {
    fn serialize_content<W: Write>(&self, s: &mut Serializer<W>) -> SerResult {
        if let Some(ref val) = self.days {
            s.content("Days", val)?;
        }
        if let Some(ref val) = self.description {
            s.content("Description", val)?;
        }
        if let Some(ref val) = self.glacier_job_parameters {
            s.content("GlacierJobParameters", val)?;
        }
        if let Some(ref val) = self.output_location {
            s.content("OutputLocation", val)?;
        }
        if let Some(ref val) = self.select_parameters {
            s.content("SelectParameters", val)?;
        }
        if let Some(ref val) = self.tier {
            s.content("Tier", val)?;
        }
        if let Some(ref val) = self.type_ {
            s.content("Type", val)?;
        }
        Ok(())
    }
}

impl<'xml> DeserializeContent<'xml> for RestoreRequest {
    fn deserialize_content(d: &mut Deserializer<'xml>) -> DeResult<Self> {
        let mut days: Option<Days> = None;
        let mut description: Option<Description> = None;
        let mut glacier_job_parameters: Option<GlacierJobParameters> = None;
        let mut output_location: Option<OutputLocation> = None;
        let mut select_parameters: Option<SelectParameters> = None;
        let mut tier: Option<Tier> = None;
        let mut type_: Option<RestoreRequestType> = None;
        d.for_each_element(|d, x| match x {
            b"Days" => {
                if days.is_some() {
                    return Err(DeError::DuplicateField);
                }
                days = Some(d.content()?);
                Ok(())
            }
            b"Description" => {
                if description.is_some() {
                    return Err(DeError::DuplicateField);
                }
                description = Some(d.content()?);
                Ok(())
            }
            b"GlacierJobParameters" => {
                if glacier_job_parameters.is_some() {
                    return Err(DeError::DuplicateField);
                }
                glacier_job_parameters = Some(d.content()?);
                Ok(())
            }
            b"OutputLocation" => {
                if output_location.is_some() {
                    return Err(DeError::DuplicateField);
                }
                output_location = Some(d.content()?);
                Ok(())
            }
            b"SelectParameters" => {
                if select_parameters.is_some() {
                    return Err(DeError::DuplicateField);
                }
                select_parameters = Some(d.content()?);
                Ok(())
            }
            b"Tier" => {
                if tier.is_some() {
                    return Err(DeError::DuplicateField);
                }
                tier = Some(d.content()?);
                Ok(())
            }
            b"Type" => {
                if type_.is_some() {
                    return Err(DeError::DuplicateField);
                }
                type_ = Some(d.content()?);
                Ok(())
            }
            _ => Err(DeError::UnexpectedTagName),
        })?;
        Ok(Self {
            days,
            description,
            glacier_job_parameters,
            output_location,
            select_parameters,
            tier,
            type_,
        })
    }
}
impl SerializeContent for RestoreRequestType {
    fn serialize_content<W: Write>(&self, s: &mut Serializer<W>) -> SerResult {
        self.as_str().serialize_content(s)
    }
}
impl<'xml> DeserializeContent<'xml> for RestoreRequestType {
    fn deserialize_content(d: &mut Deserializer<'xml>) -> DeResult<Self> {
        d.text(|t| {
            let b: &[u8] = &t;
            match b {
                b"SELECT" => Ok(Self::from_static(RestoreRequestType::SELECT)),
                _ => Ok(Self::from(t.unescape().map_err(DeError::InvalidXml)?.into_owned())),
            }
        })
    }
}
impl SerializeContent for RestoreStatus {
    fn serialize_content<W: Write>(&self, s: &mut Serializer<W>) -> SerResult {
        if let Some(ref val) = self.is_restore_in_progress {
            s.content("IsRestoreInProgress", val)?;
        }
        if let Some(ref val) = self.restore_expiry_date {
            s.timestamp("RestoreExpiryDate", val, TimestampFormat::DateTime)?;
        }
        Ok(())
    }
}

impl<'xml> DeserializeContent<'xml> for RestoreStatus {
    fn deserialize_content(d: &mut Deserializer<'xml>) -> DeResult<Self> {
        let mut is_restore_in_progress: Option<IsRestoreInProgress> = None;
        let mut restore_expiry_date: Option<RestoreExpiryDate> = None;
        d.for_each_element(|d, x| match x {
            b"IsRestoreInProgress" => {
                if is_restore_in_progress.is_some() {
                    return Err(DeError::DuplicateField);
                }
                is_restore_in_progress = Some(d.content()?);
                Ok(())
            }
            b"RestoreExpiryDate" => {
                if restore_expiry_date.is_some() {
                    return Err(DeError::DuplicateField);
                }
                restore_expiry_date = Some(d.timestamp(TimestampFormat::DateTime)?);
                Ok(())
            }
            _ => Err(DeError::UnexpectedTagName),
        })?;
        Ok(Self {
            is_restore_in_progress,
            restore_expiry_date,
        })
    }
}
impl SerializeContent for RoutingRule {
    fn serialize_content<W: Write>(&self, s: &mut Serializer<W>) -> SerResult {
        if let Some(ref val) = self.condition {
            s.content("Condition", val)?;
        }
        s.content("Redirect", &self.redirect)?;
        Ok(())
    }
}

impl<'xml> DeserializeContent<'xml> for RoutingRule {
    fn deserialize_content(d: &mut Deserializer<'xml>) -> DeResult<Self> {
        let mut condition: Option<Condition> = None;
        let mut redirect: Option<Redirect> = None;
        d.for_each_element(|d, x| match x {
            b"Condition" => {
                if condition.is_some() {
                    return Err(DeError::DuplicateField);
                }
                condition = Some(d.content()?);
                Ok(())
            }
            b"Redirect" => {
                if redirect.is_some() {
                    return Err(DeError::DuplicateField);
                }
                redirect = Some(d.content()?);
                Ok(())
            }
            _ => Err(DeError::UnexpectedTagName),
        })?;
        Ok(Self {
            condition,
            redirect: redirect.ok_or(DeError::MissingField)?,
        })
    }
}
impl SerializeContent for S3KeyFilter {
    fn serialize_content<W: Write>(&self, s: &mut Serializer<W>) -> SerResult {
        if let Some(iter) = &self.filter_rules {
            s.flattened_list("FilterRule", iter)?;
        }
        Ok(())
    }
}

impl<'xml> DeserializeContent<'xml> for S3KeyFilter {
    fn deserialize_content(d: &mut Deserializer<'xml>) -> DeResult<Self> {
        let mut filter_rules: Option<FilterRuleList> = None;
        d.for_each_element(|d, x| match x {
            b"FilterRule" => {
                let ans: FilterRule = d.content()?;
                filter_rules.get_or_insert_with(List::new).push(ans);
                Ok(())
            }
            _ => Err(DeError::UnexpectedTagName),
        })?;
        Ok(Self { filter_rules })
    }
}
impl SerializeContent for S3Location {
    fn serialize_content<W: Write>(&self, s: &mut Serializer<W>) -> SerResult {
        if let Some(iter) = &self.access_control_list {
            s.list("AccessControlList", "Grant", iter)?;
        }
        s.content("BucketName", &self.bucket_name)?;
        if let Some(ref val) = self.canned_acl {
            s.content("CannedACL", val)?;
        }
        if let Some(ref val) = self.encryption {
            s.content("Encryption", val)?;
        }
        s.content("Prefix", &self.prefix)?;
        if let Some(ref val) = self.storage_class {
            s.content("StorageClass", val)?;
        }
        if let Some(ref val) = self.tagging {
            s.content("Tagging", val)?;
        }
        if let Some(iter) = &self.user_metadata {
            s.list("UserMetadata", "MetadataEntry", iter)?;
        }
        Ok(())
    }
}

impl<'xml> DeserializeContent<'xml> for S3Location {
    fn deserialize_content(d: &mut Deserializer<'xml>) -> DeResult<Self> {
        let mut access_control_list: Option<Grants> = None;
        let mut bucket_name: Option<BucketName> = None;
        let mut canned_acl: Option<ObjectCannedACL> = None;
        let mut encryption: Option<Encryption> = None;
        let mut prefix: Option<LocationPrefix> = None;
        let mut storage_class: Option<StorageClass> = None;
        let mut tagging: Option<Tagging> = None;
        let mut user_metadata: Option<UserMetadata> = None;
        d.for_each_element(|d, x| match x {
            b"AccessControlList" => {
                if access_control_list.is_some() {
                    return Err(DeError::DuplicateField);
                }
                access_control_list = Some(d.list_content("Grant")?);
                Ok(())
            }
            b"BucketName" => {
                if bucket_name.is_some() {
                    return Err(DeError::DuplicateField);
                }
                bucket_name = Some(d.content()?);
                Ok(())
            }
            b"CannedACL" => {
                if canned_acl.is_some() {
                    return Err(DeError::DuplicateField);
                }
                canned_acl = Some(d.content()?);
                Ok(())
            }
            b"Encryption" => {
                if encryption.is_some() {
                    return Err(DeError::DuplicateField);
                }
                encryption = Some(d.content()?);
                Ok(())
            }
            b"Prefix" => {
                if prefix.is_some() {
                    return Err(DeError::DuplicateField);
                }
                prefix = Some(d.content()?);
                Ok(())
            }
            b"StorageClass" => {
                if storage_class.is_some() {
                    return Err(DeError::DuplicateField);
                }
                storage_class = Some(d.content()?);
                Ok(())
            }
            b"Tagging" => {
                if tagging.is_some() {
                    return Err(DeError::DuplicateField);
                }
                tagging = Some(d.content()?);
                Ok(())
            }
            b"UserMetadata" => {
                if user_metadata.is_some() {
                    return Err(DeError::DuplicateField);
                }
                user_metadata = Some(d.list_content("MetadataEntry")?);
                Ok(())
            }
            _ => Err(DeError::UnexpectedTagName),
        })?;
        Ok(Self {
            access_control_list,
            bucket_name: bucket_name.ok_or(DeError::MissingField)?,
            canned_acl,
            encryption,
            prefix: prefix.ok_or(DeError::MissingField)?,
            storage_class,
            tagging,
            user_metadata,
        })
    }
}
impl SerializeContent for S3TablesDestination {
    fn serialize_content<W: Write>(&self, s: &mut Serializer<W>) -> SerResult {
        s.content("TableBucketArn", &self.table_bucket_arn)?;
        s.content("TableName", &self.table_name)?;
        Ok(())
    }
}

impl<'xml> DeserializeContent<'xml> for S3TablesDestination {
    fn deserialize_content(d: &mut Deserializer<'xml>) -> DeResult<Self> {
        let mut table_bucket_arn: Option<S3TablesBucketArn> = None;
        let mut table_name: Option<S3TablesName> = None;
        d.for_each_element(|d, x| match x {
            b"TableBucketArn" => {
                if table_bucket_arn.is_some() {
                    return Err(DeError::DuplicateField);
                }
                table_bucket_arn = Some(d.content()?);
                Ok(())
            }
            b"TableName" => {
                if table_name.is_some() {
                    return Err(DeError::DuplicateField);
                }
                table_name = Some(d.content()?);
                Ok(())
            }
            _ => Err(DeError::UnexpectedTagName),
        })?;
        Ok(Self {
            table_bucket_arn: table_bucket_arn.ok_or(DeError::MissingField)?,
            table_name: table_name.ok_or(DeError::MissingField)?,
        })
    }
}
impl SerializeContent for S3TablesDestinationResult {
    fn serialize_content<W: Write>(&self, s: &mut Serializer<W>) -> SerResult {
        s.content("TableArn", &self.table_arn)?;
        s.content("TableBucketArn", &self.table_bucket_arn)?;
        s.content("TableName", &self.table_name)?;
        s.content("TableNamespace", &self.table_namespace)?;
        Ok(())
    }
}

impl<'xml> DeserializeContent<'xml> for S3TablesDestinationResult {
    fn deserialize_content(d: &mut Deserializer<'xml>) -> DeResult<Self> {
        let mut table_arn: Option<S3TablesArn> = None;
        let mut table_bucket_arn: Option<S3TablesBucketArn> = None;
        let mut table_name: Option<S3TablesName> = None;
        let mut table_namespace: Option<S3TablesNamespace> = None;
        d.for_each_element(|d, x| match x {
            b"TableArn" => {
                if table_arn.is_some() {
                    return Err(DeError::DuplicateField);
                }
                table_arn = Some(d.content()?);
                Ok(())
            }
            b"TableBucketArn" => {
                if table_bucket_arn.is_some() {
                    return Err(DeError::DuplicateField);
                }
                table_bucket_arn = Some(d.content()?);
                Ok(())
            }
            b"TableName" => {
                if table_name.is_some() {
                    return Err(DeError::DuplicateField);
                }
                table_name = Some(d.content()?);
                Ok(())
            }
            b"TableNamespace" => {
                if table_namespace.is_some() {
                    return Err(DeError::DuplicateField);
                }
                table_namespace = Some(d.content()?);
                Ok(())
            }
            _ => Err(DeError::UnexpectedTagName),
        })?;
        Ok(Self {
            table_arn: table_arn.ok_or(DeError::MissingField)?,
            table_bucket_arn: table_bucket_arn.ok_or(DeError::MissingField)?,
            table_name: table_name.ok_or(DeError::MissingField)?,
            table_namespace: table_namespace.ok_or(DeError::MissingField)?,
        })
    }
}
impl SerializeContent for SSEKMS {
    fn serialize_content<W: Write>(&self, s: &mut Serializer<W>) -> SerResult {
        s.content("KeyId", &self.key_id)?;
        Ok(())
    }
}

impl<'xml> DeserializeContent<'xml> for SSEKMS {
    fn deserialize_content(d: &mut Deserializer<'xml>) -> DeResult<Self> {
        let mut key_id: Option<SSEKMSKeyId> = None;
        d.for_each_element(|d, x| match x {
            b"KeyId" => {
                if key_id.is_some() {
                    return Err(DeError::DuplicateField);
                }
                key_id = Some(d.content()?);
                Ok(())
            }
            _ => Err(DeError::UnexpectedTagName),
        })?;
        Ok(Self {
            key_id: key_id.ok_or(DeError::MissingField)?,
        })
    }
}
impl SerializeContent for SSES3 {
    fn serialize_content<W: Write>(&self, _: &mut Serializer<W>) -> SerResult {
        Ok(())
    }
}

impl<'xml> DeserializeContent<'xml> for SSES3 {
    fn deserialize_content(_: &mut Deserializer<'xml>) -> DeResult<Self> {
        Ok(Self {})
    }
}
impl SerializeContent for ScanRange {
    fn serialize_content<W: Write>(&self, s: &mut Serializer<W>) -> SerResult {
        if let Some(ref val) = self.end {
            s.content("End", val)?;
        }
        if let Some(ref val) = self.start {
            s.content("Start", val)?;
        }
        Ok(())
    }
}

impl<'xml> DeserializeContent<'xml> for ScanRange {
    fn deserialize_content(d: &mut Deserializer<'xml>) -> DeResult<Self> {
        let mut end: Option<End> = None;
        let mut start: Option<Start> = None;
        d.for_each_element(|d, x| match x {
            b"End" => {
                if end.is_some() {
                    return Err(DeError::DuplicateField);
                }
                end = Some(d.content()?);
                Ok(())
            }
            b"Start" => {
                if start.is_some() {
                    return Err(DeError::DuplicateField);
                }
                start = Some(d.content()?);
                Ok(())
            }
            _ => Err(DeError::UnexpectedTagName),
        })?;
        Ok(Self { end, start })
    }
}
impl SerializeContent for SelectObjectContentRequest {
    fn serialize_content<W: Write>(&self, s: &mut Serializer<W>) -> SerResult {
        s.content("Expression", &self.expression)?;
        s.content("ExpressionType", &self.expression_type)?;
        s.content("InputSerialization", &self.input_serialization)?;
        s.content("OutputSerialization", &self.output_serialization)?;
        if let Some(ref val) = self.request_progress {
            s.content("RequestProgress", val)?;
        }
        if let Some(ref val) = self.scan_range {
            s.content("ScanRange", val)?;
        }
        Ok(())
    }
}

impl<'xml> DeserializeContent<'xml> for SelectObjectContentRequest {
    fn deserialize_content(d: &mut Deserializer<'xml>) -> DeResult<Self> {
        let mut expression: Option<Expression> = None;
        let mut expression_type: Option<ExpressionType> = None;
        let mut input_serialization: Option<InputSerialization> = None;
        let mut output_serialization: Option<OutputSerialization> = None;
        let mut request_progress: Option<RequestProgress> = None;
        let mut scan_range: Option<ScanRange> = None;
        d.for_each_element(|d, x| match x {
            b"Expression" => {
                if expression.is_some() {
                    return Err(DeError::DuplicateField);
                }
                expression = Some(d.content()?);
                Ok(())
            }
            b"ExpressionType" => {
                if expression_type.is_some() {
                    return Err(DeError::DuplicateField);
                }
                expression_type = Some(d.content()?);
                Ok(())
            }
            b"InputSerialization" => {
                if input_serialization.is_some() {
                    return Err(DeError::DuplicateField);
                }
                input_serialization = Some(d.content()?);
                Ok(())
            }
            b"OutputSerialization" => {
                if output_serialization.is_some() {
                    return Err(DeError::DuplicateField);
                }
                output_serialization = Some(d.content()?);
                Ok(())
            }
            b"RequestProgress" => {
                if request_progress.is_some() {
                    return Err(DeError::DuplicateField);
                }
                request_progress = Some(d.content()?);
                Ok(())
            }
            b"ScanRange" => {
                if scan_range.is_some() {
                    return Err(DeError::DuplicateField);
                }
                scan_range = Some(d.content()?);
                Ok(())
            }
            _ => Err(DeError::UnexpectedTagName),
        })?;
        Ok(Self {
            expression: expression.ok_or(DeError::MissingField)?,
            expression_type: expression_type.ok_or(DeError::MissingField)?,
            input_serialization: input_serialization.ok_or(DeError::MissingField)?,
            output_serialization: output_serialization.ok_or(DeError::MissingField)?,
            request_progress,
            scan_range,
        })
    }
}
impl SerializeContent for SelectParameters {
    fn serialize_content<W: Write>(&self, s: &mut Serializer<W>) -> SerResult {
        s.content("Expression", &self.expression)?;
        s.content("ExpressionType", &self.expression_type)?;
        s.content("InputSerialization", &self.input_serialization)?;
        s.content("OutputSerialization", &self.output_serialization)?;
        Ok(())
    }
}

impl<'xml> DeserializeContent<'xml> for SelectParameters {
    fn deserialize_content(d: &mut Deserializer<'xml>) -> DeResult<Self> {
        let mut expression: Option<Expression> = None;
        let mut expression_type: Option<ExpressionType> = None;
        let mut input_serialization: Option<InputSerialization> = None;
        let mut output_serialization: Option<OutputSerialization> = None;
        d.for_each_element(|d, x| match x {
            b"Expression" => {
                if expression.is_some() {
                    return Err(DeError::DuplicateField);
                }
                expression = Some(d.content()?);
                Ok(())
            }
            b"ExpressionType" => {
                if expression_type.is_some() {
                    return Err(DeError::DuplicateField);
                }
                expression_type = Some(d.content()?);
                Ok(())
            }
            b"InputSerialization" => {
                if input_serialization.is_some() {
                    return Err(DeError::DuplicateField);
                }
                input_serialization = Some(d.content()?);
                Ok(())
            }
            b"OutputSerialization" => {
                if output_serialization.is_some() {
                    return Err(DeError::DuplicateField);
                }
                output_serialization = Some(d.content()?);
                Ok(())
            }
            _ => Err(DeError::UnexpectedTagName),
        })?;
        Ok(Self {
            expression: expression.ok_or(DeError::MissingField)?,
            expression_type: expression_type.ok_or(DeError::MissingField)?,
            input_serialization: input_serialization.ok_or(DeError::MissingField)?,
            output_serialization: output_serialization.ok_or(DeError::MissingField)?,
        })
    }
}
impl SerializeContent for ServerSideEncryption {
    fn serialize_content<W: Write>(&self, s: &mut Serializer<W>) -> SerResult {
        self.as_str().serialize_content(s)
    }
}
impl<'xml> DeserializeContent<'xml> for ServerSideEncryption {
    fn deserialize_content(d: &mut Deserializer<'xml>) -> DeResult<Self> {
        d.text(|t| {
            let b: &[u8] = &t;
            match b {
                b"AES256" => Ok(Self::from_static(ServerSideEncryption::AES256)),
                b"aws:kms" => Ok(Self::from_static(ServerSideEncryption::AWS_KMS)),
                b"aws:kms:dsse" => Ok(Self::from_static(ServerSideEncryption::AWS_KMS_DSSE)),
                _ => Ok(Self::from(t.unescape().map_err(DeError::InvalidXml)?.into_owned())),
            }
        })
    }
}
impl SerializeContent for ServerSideEncryptionByDefault {
    fn serialize_content<W: Write>(&self, s: &mut Serializer<W>) -> SerResult {
        if let Some(ref val) = self.kms_master_key_id {
            s.content("KMSMasterKeyID", val)?;
        }
        s.content("SSEAlgorithm", &self.sse_algorithm)?;
        Ok(())
    }
}

impl<'xml> DeserializeContent<'xml> for ServerSideEncryptionByDefault {
    fn deserialize_content(d: &mut Deserializer<'xml>) -> DeResult<Self> {
        let mut kms_master_key_id: Option<SSEKMSKeyId> = None;
        let mut sse_algorithm: Option<ServerSideEncryption> = None;
        d.for_each_element(|d, x| match x {
            b"KMSMasterKeyID" => {
                if kms_master_key_id.is_some() {
                    return Err(DeError::DuplicateField);
                }
                kms_master_key_id = Some(d.content()?);
                Ok(())
            }
            b"SSEAlgorithm" => {
                if sse_algorithm.is_some() {
                    return Err(DeError::DuplicateField);
                }
                sse_algorithm = Some(d.content()?);
                Ok(())
            }
            _ => Err(DeError::UnexpectedTagName),
        })?;
        Ok(Self {
            kms_master_key_id,
            sse_algorithm: sse_algorithm.ok_or(DeError::MissingField)?,
        })
    }
}
impl SerializeContent for ServerSideEncryptionConfiguration {
    fn serialize_content<W: Write>(&self, s: &mut Serializer<W>) -> SerResult {
        {
            let iter = &self.rules;
            s.flattened_list("Rule", iter)?;
        }
        Ok(())
    }
}

impl<'xml> DeserializeContent<'xml> for ServerSideEncryptionConfiguration {
    fn deserialize_content(d: &mut Deserializer<'xml>) -> DeResult<Self> {
        let mut rules: Option<ServerSideEncryptionRules> = None;
        d.for_each_element(|d, x| match x {
            b"Rule" => {
                let ans: ServerSideEncryptionRule = d.content()?;
                rules.get_or_insert_with(List::new).push(ans);
                Ok(())
            }
            _ => Err(DeError::UnexpectedTagName),
        })?;
        Ok(Self {
            rules: rules.ok_or(DeError::MissingField)?,
        })
    }
}
impl SerializeContent for ServerSideEncryptionRule {
    fn serialize_content<W: Write>(&self, s: &mut Serializer<W>) -> SerResult {
        if let Some(ref val) = self.apply_server_side_encryption_by_default {
            s.content("ApplyServerSideEncryptionByDefault", val)?;
        }
        if let Some(ref val) = self.bucket_key_enabled {
            s.content("BucketKeyEnabled", val)?;
        }
        Ok(())
    }
}

impl<'xml> DeserializeContent<'xml> for ServerSideEncryptionRule {
    fn deserialize_content(d: &mut Deserializer<'xml>) -> DeResult<Self> {
        let mut apply_server_side_encryption_by_default: Option<ServerSideEncryptionByDefault> = None;
        let mut bucket_key_enabled: Option<BucketKeyEnabled> = None;
        d.for_each_element(|d, x| match x {
            b"ApplyServerSideEncryptionByDefault" => {
                if apply_server_side_encryption_by_default.is_some() {
                    return Err(DeError::DuplicateField);
                }
                apply_server_side_encryption_by_default = Some(d.content()?);
                Ok(())
            }
            b"BucketKeyEnabled" => {
                if bucket_key_enabled.is_some() {
                    return Err(DeError::DuplicateField);
                }
                bucket_key_enabled = Some(d.content()?);
                Ok(())
            }
            _ => Err(DeError::UnexpectedTagName),
        })?;
        Ok(Self {
            apply_server_side_encryption_by_default,
            bucket_key_enabled,
        })
    }
}
impl SerializeContent for SimplePrefix {
    fn serialize_content<W: Write>(&self, _: &mut Serializer<W>) -> SerResult {
        Ok(())
    }
}

impl<'xml> DeserializeContent<'xml> for SimplePrefix {
    fn deserialize_content(_: &mut Deserializer<'xml>) -> DeResult<Self> {
        Ok(Self {})
    }
}
impl SerializeContent for SourceSelectionCriteria {
    fn serialize_content<W: Write>(&self, s: &mut Serializer<W>) -> SerResult {
        if let Some(ref val) = self.replica_modifications {
            s.content("ReplicaModifications", val)?;
        }
        if let Some(ref val) = self.sse_kms_encrypted_objects {
            s.content("SseKmsEncryptedObjects", val)?;
        }
        Ok(())
    }
}

impl<'xml> DeserializeContent<'xml> for SourceSelectionCriteria {
    fn deserialize_content(d: &mut Deserializer<'xml>) -> DeResult<Self> {
        let mut replica_modifications: Option<ReplicaModifications> = None;
        let mut sse_kms_encrypted_objects: Option<SseKmsEncryptedObjects> = None;
        d.for_each_element(|d, x| match x {
            b"ReplicaModifications" => {
                if replica_modifications.is_some() {
                    return Err(DeError::DuplicateField);
                }
                replica_modifications = Some(d.content()?);
                Ok(())
            }
            b"SseKmsEncryptedObjects" => {
                if sse_kms_encrypted_objects.is_some() {
                    return Err(DeError::DuplicateField);
                }
                sse_kms_encrypted_objects = Some(d.content()?);
                Ok(())
            }
            _ => Err(DeError::UnexpectedTagName),
        })?;
        Ok(Self {
            replica_modifications,
            sse_kms_encrypted_objects,
        })
    }
}
impl SerializeContent for SseKmsEncryptedObjects {
    fn serialize_content<W: Write>(&self, s: &mut Serializer<W>) -> SerResult {
        s.content("Status", &self.status)?;
        Ok(())
    }
}

impl<'xml> DeserializeContent<'xml> for SseKmsEncryptedObjects {
    fn deserialize_content(d: &mut Deserializer<'xml>) -> DeResult<Self> {
        let mut status: Option<SseKmsEncryptedObjectsStatus> = None;
        d.for_each_element(|d, x| match x {
            b"Status" => {
                if status.is_some() {
                    return Err(DeError::DuplicateField);
                }
                status = Some(d.content()?);
                Ok(())
            }
            _ => Err(DeError::UnexpectedTagName),
        })?;
        Ok(Self {
            status: status.ok_or(DeError::MissingField)?,
        })
    }
}
impl SerializeContent for SseKmsEncryptedObjectsStatus {
    fn serialize_content<W: Write>(&self, s: &mut Serializer<W>) -> SerResult {
        self.as_str().serialize_content(s)
    }
}
impl<'xml> DeserializeContent<'xml> for SseKmsEncryptedObjectsStatus {
    fn deserialize_content(d: &mut Deserializer<'xml>) -> DeResult<Self> {
        d.text(|t| {
            let b: &[u8] = &t;
            match b {
                b"Disabled" => Ok(Self::from_static(SseKmsEncryptedObjectsStatus::DISABLED)),
                b"Enabled" => Ok(Self::from_static(SseKmsEncryptedObjectsStatus::ENABLED)),
                _ => Ok(Self::from(t.unescape().map_err(DeError::InvalidXml)?.into_owned())),
            }
        })
    }
}
impl SerializeContent for Stats {
    fn serialize_content<W: Write>(&self, s: &mut Serializer<W>) -> SerResult {
        if let Some(ref val) = self.bytes_processed {
            s.content("BytesProcessed", val)?;
        }
        if let Some(ref val) = self.bytes_returned {
            s.content("BytesReturned", val)?;
        }
        if let Some(ref val) = self.bytes_scanned {
            s.content("BytesScanned", val)?;
        }
        Ok(())
    }
}

impl<'xml> DeserializeContent<'xml> for Stats {
    fn deserialize_content(d: &mut Deserializer<'xml>) -> DeResult<Self> {
        let mut bytes_processed: Option<BytesProcessed> = None;
        let mut bytes_returned: Option<BytesReturned> = None;
        let mut bytes_scanned: Option<BytesScanned> = None;
        d.for_each_element(|d, x| match x {
            b"BytesProcessed" => {
                if bytes_processed.is_some() {
                    return Err(DeError::DuplicateField);
                }
                bytes_processed = Some(d.content()?);
                Ok(())
            }
            b"BytesReturned" => {
                if bytes_returned.is_some() {
                    return Err(DeError::DuplicateField);
                }
                bytes_returned = Some(d.content()?);
                Ok(())
            }
            b"BytesScanned" => {
                if bytes_scanned.is_some() {
                    return Err(DeError::DuplicateField);
                }
                bytes_scanned = Some(d.content()?);
                Ok(())
            }
            _ => Err(DeError::UnexpectedTagName),
        })?;
        Ok(Self {
            bytes_processed,
            bytes_returned,
            bytes_scanned,
        })
    }
}
impl SerializeContent for StorageClass {
    fn serialize_content<W: Write>(&self, s: &mut Serializer<W>) -> SerResult {
        self.as_str().serialize_content(s)
    }
}
impl<'xml> DeserializeContent<'xml> for StorageClass {
    fn deserialize_content(d: &mut Deserializer<'xml>) -> DeResult<Self> {
        d.text(|t| {
            let b: &[u8] = &t;
            match b {
                b"DEEP_ARCHIVE" => Ok(Self::from_static(StorageClass::DEEP_ARCHIVE)),
                b"EXPRESS_ONEZONE" => Ok(Self::from_static(StorageClass::EXPRESS_ONEZONE)),
                b"GLACIER" => Ok(Self::from_static(StorageClass::GLACIER)),
                b"GLACIER_IR" => Ok(Self::from_static(StorageClass::GLACIER_IR)),
                b"INTELLIGENT_TIERING" => Ok(Self::from_static(StorageClass::INTELLIGENT_TIERING)),
                b"ONEZONE_IA" => Ok(Self::from_static(StorageClass::ONEZONE_IA)),
                b"OUTPOSTS" => Ok(Self::from_static(StorageClass::OUTPOSTS)),
                b"REDUCED_REDUNDANCY" => Ok(Self::from_static(StorageClass::REDUCED_REDUNDANCY)),
                b"SNOW" => Ok(Self::from_static(StorageClass::SNOW)),
                b"STANDARD" => Ok(Self::from_static(StorageClass::STANDARD)),
                b"STANDARD_IA" => Ok(Self::from_static(StorageClass::STANDARD_IA)),
                _ => Ok(Self::from(t.unescape().map_err(DeError::InvalidXml)?.into_owned())),
            }
        })
    }
}
impl SerializeContent for StorageClassAnalysis {
    fn serialize_content<W: Write>(&self, s: &mut Serializer<W>) -> SerResult {
        if let Some(ref val) = self.data_export {
            s.content("DataExport", val)?;
        }
        Ok(())
    }
}

impl<'xml> DeserializeContent<'xml> for StorageClassAnalysis {
    fn deserialize_content(d: &mut Deserializer<'xml>) -> DeResult<Self> {
        let mut data_export: Option<StorageClassAnalysisDataExport> = None;
        d.for_each_element(|d, x| match x {
            b"DataExport" => {
                if data_export.is_some() {
                    return Err(DeError::DuplicateField);
                }
                data_export = Some(d.content()?);
                Ok(())
            }
            _ => Err(DeError::UnexpectedTagName),
        })?;
        Ok(Self { data_export })
    }
}
impl SerializeContent for StorageClassAnalysisDataExport {
    fn serialize_content<W: Write>(&self, s: &mut Serializer<W>) -> SerResult {
        s.content("Destination", &self.destination)?;
        s.content("OutputSchemaVersion", &self.output_schema_version)?;
        Ok(())
    }
}

impl<'xml> DeserializeContent<'xml> for StorageClassAnalysisDataExport {
    fn deserialize_content(d: &mut Deserializer<'xml>) -> DeResult<Self> {
        let mut destination: Option<AnalyticsExportDestination> = None;
        let mut output_schema_version: Option<StorageClassAnalysisSchemaVersion> = None;
        d.for_each_element(|d, x| match x {
            b"Destination" => {
                if destination.is_some() {
                    return Err(DeError::DuplicateField);
                }
                destination = Some(d.content()?);
                Ok(())
            }
            b"OutputSchemaVersion" => {
                if output_schema_version.is_some() {
                    return Err(DeError::DuplicateField);
                }
                output_schema_version = Some(d.content()?);
                Ok(())
            }
            _ => Err(DeError::UnexpectedTagName),
        })?;
        Ok(Self {
            destination: destination.ok_or(DeError::MissingField)?,
            output_schema_version: output_schema_version.ok_or(DeError::MissingField)?,
        })
    }
}
impl SerializeContent for StorageClassAnalysisSchemaVersion {
    fn serialize_content<W: Write>(&self, s: &mut Serializer<W>) -> SerResult {
        self.as_str().serialize_content(s)
    }
}
impl<'xml> DeserializeContent<'xml> for StorageClassAnalysisSchemaVersion {
    fn deserialize_content(d: &mut Deserializer<'xml>) -> DeResult<Self> {
        d.text(|t| {
            let b: &[u8] = &t;
            match b {
                b"V_1" => Ok(Self::from_static(StorageClassAnalysisSchemaVersion::V_1)),
                _ => Ok(Self::from(t.unescape().map_err(DeError::InvalidXml)?.into_owned())),
            }
        })
    }
}
impl SerializeContent for Tag {
    fn serialize_content<W: Write>(&self, s: &mut Serializer<W>) -> SerResult {
        if let Some(ref val) = self.key {
            s.content("Key", val)?;
        }
        if let Some(ref val) = self.value {
            s.content("Value", val)?;
        }
        Ok(())
    }
}

impl<'xml> DeserializeContent<'xml> for Tag {
    fn deserialize_content(d: &mut Deserializer<'xml>) -> DeResult<Self> {
        let mut key: Option<ObjectKey> = None;
        let mut value: Option<Value> = None;
        d.for_each_element(|d, x| match x {
            b"Key" => {
                if key.is_some() {
                    return Err(DeError::DuplicateField);
                }
                key = Some(d.content()?);
                Ok(())
            }
            b"Value" => {
                if value.is_some() {
                    return Err(DeError::DuplicateField);
                }
                value = Some(d.content()?);
                Ok(())
            }
            _ => Err(DeError::UnexpectedTagName),
        })?;
        Ok(Self { key, value })
    }
}
impl SerializeContent for Tagging {
    fn serialize_content<W: Write>(&self, s: &mut Serializer<W>) -> SerResult {
        {
            let iter = &self.tag_set;
            s.list("TagSet", "Tag", iter)?;
        }
        Ok(())
    }
}

impl<'xml> DeserializeContent<'xml> for Tagging {
    fn deserialize_content(d: &mut Deserializer<'xml>) -> DeResult<Self> {
        let mut tag_set: Option<TagSet> = None;
        d.for_each_element(|d, x| match x {
            b"TagSet" => {
                if tag_set.is_some() {
                    return Err(DeError::DuplicateField);
                }
                tag_set = Some(d.list_content("Tag")?);
                Ok(())
            }
            _ => Err(DeError::UnexpectedTagName),
        })?;
        Ok(Self {
            tag_set: tag_set.ok_or(DeError::MissingField)?,
        })
    }
}
impl SerializeContent for TargetGrant {
    fn serialize_content<W: Write>(&self, s: &mut Serializer<W>) -> SerResult {
        if let Some(ref val) = self.grantee {
            let attrs = [
                ("xmlns:xsi", "http://www.w3.org/2001/XMLSchema-instance"),
                ("xsi:type", val.type_.as_str()),
            ];
            s.content_with_attrs("Grantee", &attrs, val)?;
        }
        if let Some(ref val) = self.permission {
            s.content("Permission", val)?;
        }
        Ok(())
    }
}

impl<'xml> DeserializeContent<'xml> for TargetGrant {
    fn deserialize_content(d: &mut Deserializer<'xml>) -> DeResult<Self> {
        let mut grantee: Option<Grantee> = None;
        let mut permission: Option<BucketLogsPermission> = None;
        d.for_each_element_with_start(|d, x, start| match x {
            b"Grantee" => {
                if grantee.is_some() {
                    return Err(DeError::DuplicateField);
                }
                let mut type_: Option<Type> = None;
                for attr in start.attributes() {
                    let Ok(attr) = attr else { return Err(DeError::InvalidAttribute) };
                    if attr.key.as_ref() == b"xsi:type" {
                        type_ = Some(attr.unescape_value().map_err(DeError::InvalidXml)?.into_owned().into());
                    }
                }
                let mut display_name: Option<DisplayName> = None;
                let mut email_address: Option<EmailAddress> = None;
                let mut id: Option<ID> = None;
                let mut uri: Option<URI> = None;
                d.for_each_element(|d, x| match x {
                    b"DisplayName" => {
                        if display_name.is_some() {
                            return Err(DeError::DuplicateField);
                        }
                        display_name = Some(d.content()?);
                        Ok(())
                    }
                    b"EmailAddress" => {
                        if email_address.is_some() {
                            return Err(DeError::DuplicateField);
                        }
                        email_address = Some(d.content()?);
                        Ok(())
                    }
                    b"ID" => {
                        if id.is_some() {
                            return Err(DeError::DuplicateField);
                        }
                        id = Some(d.content()?);
                        Ok(())
                    }
                    b"URI" => {
                        if uri.is_some() {
                            return Err(DeError::DuplicateField);
                        }
                        uri = Some(d.content()?);
                        Ok(())
                    }
                    _ => Err(DeError::UnexpectedTagName),
                })?;
                grantee = Some(Grantee {
                    display_name,
                    email_address,
                    id,
                    type_: type_.ok_or(DeError::MissingField)?,
                    uri,
                });
                Ok(())
            }
            b"Permission" => {
                if permission.is_some() {
                    return Err(DeError::DuplicateField);
                }
                permission = Some(d.content()?);
                Ok(())
            }
            _ => Err(DeError::UnexpectedTagName),
        })?;
        Ok(Self { grantee, permission })
    }
}
impl SerializeContent for TargetObjectKeyFormat {
    fn serialize_content<W: Write>(&self, s: &mut Serializer<W>) -> SerResult {
        if let Some(ref val) = self.partitioned_prefix {
            s.content("PartitionedPrefix", val)?;
        }
        if let Some(ref val) = self.simple_prefix {
            s.content("SimplePrefix", val)?;
        }
        Ok(())
    }
}

impl<'xml> DeserializeContent<'xml> for TargetObjectKeyFormat {
    fn deserialize_content(d: &mut Deserializer<'xml>) -> DeResult<Self> {
        let mut partitioned_prefix: Option<PartitionedPrefix> = None;
        let mut simple_prefix: Option<SimplePrefix> = None;
        d.for_each_element(|d, x| match x {
            b"PartitionedPrefix" => {
                if partitioned_prefix.is_some() {
                    return Err(DeError::DuplicateField);
                }
                partitioned_prefix = Some(d.content()?);
                Ok(())
            }
            b"SimplePrefix" => {
                if simple_prefix.is_some() {
                    return Err(DeError::DuplicateField);
                }
                simple_prefix = Some(d.content()?);
                Ok(())
            }
            _ => Err(DeError::UnexpectedTagName),
        })?;
        Ok(Self {
            partitioned_prefix,
            simple_prefix,
        })
    }
}
impl SerializeContent for Tier {
    fn serialize_content<W: Write>(&self, s: &mut Serializer<W>) -> SerResult {
        self.as_str().serialize_content(s)
    }
}
impl<'xml> DeserializeContent<'xml> for Tier {
    fn deserialize_content(d: &mut Deserializer<'xml>) -> DeResult<Self> {
        d.text(|t| {
            let b: &[u8] = &t;
            match b {
                b"Bulk" => Ok(Self::from_static(Tier::BULK)),
                b"Expedited" => Ok(Self::from_static(Tier::EXPEDITED)),
                b"Standard" => Ok(Self::from_static(Tier::STANDARD)),
                _ => Ok(Self::from(t.unescape().map_err(DeError::InvalidXml)?.into_owned())),
            }
        })
    }
}
impl SerializeContent for Tiering {
    fn serialize_content<W: Write>(&self, s: &mut Serializer<W>) -> SerResult {
        s.content("AccessTier", &self.access_tier)?;
        s.content("Days", &self.days)?;
        Ok(())
    }
}

impl<'xml> DeserializeContent<'xml> for Tiering {
    fn deserialize_content(d: &mut Deserializer<'xml>) -> DeResult<Self> {
        let mut access_tier: Option<IntelligentTieringAccessTier> = None;
        let mut days: Option<IntelligentTieringDays> = None;
        d.for_each_element(|d, x| match x {
            b"AccessTier" => {
                if access_tier.is_some() {
                    return Err(DeError::DuplicateField);
                }
                access_tier = Some(d.content()?);
                Ok(())
            }
            b"Days" => {
                if days.is_some() {
                    return Err(DeError::DuplicateField);
                }
                days = Some(d.content()?);
                Ok(())
            }
            _ => Err(DeError::UnexpectedTagName),
        })?;
        Ok(Self {
            access_tier: access_tier.ok_or(DeError::MissingField)?,
            days: days.ok_or(DeError::MissingField)?,
        })
    }
}
impl SerializeContent for TopicConfiguration {
    fn serialize_content<W: Write>(&self, s: &mut Serializer<W>) -> SerResult {
        {
            let iter = &self.events;
            s.flattened_list("Event", iter)?;
        }
        if let Some(ref val) = self.filter {
            s.content("Filter", val)?;
        }
        if let Some(ref val) = self.id {
            s.content("Id", val)?;
        }
        s.content("Topic", &self.topic_arn)?;
        Ok(())
    }
}

impl<'xml> DeserializeContent<'xml> for TopicConfiguration {
    fn deserialize_content(d: &mut Deserializer<'xml>) -> DeResult<Self> {
        let mut events: Option<EventList> = None;
        let mut filter: Option<NotificationConfigurationFilter> = None;
        let mut id: Option<NotificationId> = None;
        let mut topic_arn: Option<TopicArn> = None;
        d.for_each_element(|d, x| match x {
            b"Event" => {
                let ans: Event = d.content()?;
                events.get_or_insert_with(List::new).push(ans);
                Ok(())
            }
            b"Filter" => {
                if filter.is_some() {
                    return Err(DeError::DuplicateField);
                }
                filter = Some(d.content()?);
                Ok(())
            }
            b"Id" => {
                if id.is_some() {
                    return Err(DeError::DuplicateField);
                }
                id = Some(d.content()?);
                Ok(())
            }
            b"Topic" => {
                if topic_arn.is_some() {
                    return Err(DeError::DuplicateField);
                }
                topic_arn = Some(d.content()?);
                Ok(())
            }
            _ => Err(DeError::UnexpectedTagName),
        })?;
        Ok(Self {
            events: events.ok_or(DeError::MissingField)?,
            filter,
            id,
            topic_arn: topic_arn.ok_or(DeError::MissingField)?,
        })
    }
}
impl SerializeContent for Transition {
    fn serialize_content<W: Write>(&self, s: &mut Serializer<W>) -> SerResult {
        if let Some(ref val) = self.date {
            s.timestamp("Date", val, TimestampFormat::DateTime)?;
        }
        if let Some(ref val) = self.days {
            s.content("Days", val)?;
        }
        if let Some(ref val) = self.storage_class {
            s.content("StorageClass", val)?;
        }
        Ok(())
    }
}

impl<'xml> DeserializeContent<'xml> for Transition {
    fn deserialize_content(d: &mut Deserializer<'xml>) -> DeResult<Self> {
        let mut date: Option<Date> = None;
        let mut days: Option<Days> = None;
        let mut storage_class: Option<TransitionStorageClass> = None;
        d.for_each_element(|d, x| match x {
            b"Date" => {
                if date.is_some() {
                    return Err(DeError::DuplicateField);
                }
                date = Some(d.timestamp(TimestampFormat::DateTime)?);
                Ok(())
            }
            b"Days" => {
                if days.is_some() {
                    return Err(DeError::DuplicateField);
                }
                days = Some(d.content()?);
                Ok(())
            }
            b"StorageClass" => {
                if storage_class.is_some() {
                    return Err(DeError::DuplicateField);
                }
                storage_class = Some(d.content()?);
                Ok(())
            }
            _ => Err(DeError::UnexpectedTagName),
        })?;
        Ok(Self {
            date,
            days,
            storage_class,
        })
    }
}
impl SerializeContent for TransitionStorageClass {
    fn serialize_content<W: Write>(&self, s: &mut Serializer<W>) -> SerResult {
        self.as_str().serialize_content(s)
    }
}
impl<'xml> DeserializeContent<'xml> for TransitionStorageClass {
    fn deserialize_content(d: &mut Deserializer<'xml>) -> DeResult<Self> {
        d.text(|t| {
            let b: &[u8] = &t;
            match b {
                b"DEEP_ARCHIVE" => Ok(Self::from_static(TransitionStorageClass::DEEP_ARCHIVE)),
                b"GLACIER" => Ok(Self::from_static(TransitionStorageClass::GLACIER)),
                b"GLACIER_IR" => Ok(Self::from_static(TransitionStorageClass::GLACIER_IR)),
                b"INTELLIGENT_TIERING" => Ok(Self::from_static(TransitionStorageClass::INTELLIGENT_TIERING)),
                b"ONEZONE_IA" => Ok(Self::from_static(TransitionStorageClass::ONEZONE_IA)),
                b"STANDARD_IA" => Ok(Self::from_static(TransitionStorageClass::STANDARD_IA)),
                _ => Ok(Self::from(t.unescape().map_err(DeError::InvalidXml)?.into_owned())),
            }
        })
    }
}
impl SerializeContent for Type {
    fn serialize_content<W: Write>(&self, s: &mut Serializer<W>) -> SerResult {
        self.as_str().serialize_content(s)
    }
}
impl<'xml> DeserializeContent<'xml> for Type {
    fn deserialize_content(d: &mut Deserializer<'xml>) -> DeResult<Self> {
        d.text(|t| {
            let b: &[u8] = &t;
            match b {
                b"AmazonCustomerByEmail" => Ok(Self::from_static(Type::AMAZON_CUSTOMER_BY_EMAIL)),
                b"CanonicalUser" => Ok(Self::from_static(Type::CANONICAL_USER)),
                b"Group" => Ok(Self::from_static(Type::GROUP)),
                _ => Ok(Self::from(t.unescape().map_err(DeError::InvalidXml)?.into_owned())),
            }
        })
    }
}
impl SerializeContent for VersioningConfiguration {
    fn serialize_content<W: Write>(&self, s: &mut Serializer<W>) -> SerResult {
        if let Some(ref val) = self.exclude_folders {
            s.content("ExcludeFolders", val)?;
        }
        if let Some(iter) = &self.excluded_prefixes {
            s.flattened_list("ExcludedPrefixes", iter)?;
        }
        if let Some(ref val) = self.mfa_delete {
            s.content("MfaDelete", val)?;
        }
        if let Some(ref val) = self.status {
            s.content("Status", val)?;
        }
        Ok(())
    }
}

impl<'xml> DeserializeContent<'xml> for VersioningConfiguration {
    fn deserialize_content(d: &mut Deserializer<'xml>) -> DeResult<Self> {
        let mut exclude_folders: Option<ExcludeFolders> = None;
        let mut excluded_prefixes: Option<ExcludedPrefixes> = None;
        let mut mfa_delete: Option<MFADelete> = None;
        let mut status: Option<BucketVersioningStatus> = None;
        d.for_each_element(|d, x| match x {
            b"ExcludeFolders" => {
                if exclude_folders.is_some() {
                    return Err(DeError::DuplicateField);
                }
                exclude_folders = Some(d.content()?);
                Ok(())
            }
            b"ExcludedPrefixes" => {
                let ans: ExcludedPrefix = d.content()?;
                excluded_prefixes.get_or_insert_with(List::new).push(ans);
                Ok(())
            }
            b"MfaDelete" => {
                if mfa_delete.is_some() {
                    return Err(DeError::DuplicateField);
                }
                mfa_delete = Some(d.content()?);
                Ok(())
            }
            b"Status" => {
                if status.is_some() {
                    return Err(DeError::DuplicateField);
                }
                status = Some(d.content()?);
                Ok(())
            }
            _ => Err(DeError::UnexpectedTagName),
        })?;
        Ok(Self {
            exclude_folders,
            excluded_prefixes,
            mfa_delete,
            status,
        })
    }
}
impl SerializeContent for WebsiteConfiguration {
    fn serialize_content<W: Write>(&self, s: &mut Serializer<W>) -> SerResult {
        if let Some(ref val) = self.error_document {
            s.content("ErrorDocument", val)?;
        }
        if let Some(ref val) = self.index_document {
            s.content("IndexDocument", val)?;
        }
        if let Some(ref val) = self.redirect_all_requests_to {
            s.content("RedirectAllRequestsTo", val)?;
        }
        if let Some(iter) = &self.routing_rules {
            s.list("RoutingRules", "RoutingRule", iter)?;
        }
        Ok(())
    }
}

impl<'xml> DeserializeContent<'xml> for WebsiteConfiguration {
    fn deserialize_content(d: &mut Deserializer<'xml>) -> DeResult<Self> {
        let mut error_document: Option<ErrorDocument> = None;
        let mut index_document: Option<IndexDocument> = None;
        let mut redirect_all_requests_to: Option<RedirectAllRequestsTo> = None;
        let mut routing_rules: Option<RoutingRules> = None;
        d.for_each_element(|d, x| match x {
            b"ErrorDocument" => {
                if error_document.is_some() {
                    return Err(DeError::DuplicateField);
                }
                error_document = Some(d.content()?);
                Ok(())
            }
            b"IndexDocument" => {
                if index_document.is_some() {
                    return Err(DeError::DuplicateField);
                }
                index_document = Some(d.content()?);
                Ok(())
            }
            b"RedirectAllRequestsTo" => {
                if redirect_all_requests_to.is_some() {
                    return Err(DeError::DuplicateField);
                }
                redirect_all_requests_to = Some(d.content()?);
                Ok(())
            }
            b"RoutingRules" => {
                if routing_rules.is_some() {
                    return Err(DeError::DuplicateField);
                }
                routing_rules = Some(d.list_content("RoutingRule")?);
                Ok(())
            }
            _ => Err(DeError::UnexpectedTagName),
        })?;
        Ok(Self {
            error_document,
            index_document,
            redirect_all_requests_to,
            routing_rules,
        })
    }
}
